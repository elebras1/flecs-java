// Generated by jextract

package com.github.elebras1.flecs;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct {
 *     ecs_entities_memory_t entities;
 *     ecs_component_memory_t components;
 *     ecs_component_index_memory_t component_index;
 *     ecs_query_memory_t queries;
 *     ecs_table_memory_t tables;
 *     ecs_table_histogram_t table_histogram;
 *     ecs_misc_memory_t misc;
 *     ecs_allocator_memory_t allocators;
 *     double collection_time;
 * }
 * }
 */
public class EcsWorldMemory {

    EcsWorldMemory() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        ecs_entities_memory_t.layout().withName("entities"),
        ecs_component_memory_t.layout().withName("components"),
        ecs_component_index_memory_t.layout().withName("component_index"),
        ecs_query_memory_t.layout().withName("queries"),
        ecs_table_memory_t.layout().withName("tables"),
        ecs_table_histogram_t.layout().withName("table_histogram"),
        ecs_misc_memory_t.layout().withName("misc"),
        ecs_allocator_memory_t.layout().withName("allocators"),
        flecs_h.C_DOUBLE.withName("collection_time")
    ).withName("$anon$13703:9");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout entities$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("entities"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ecs_entities_memory_t entities
     * }
     */
    public static final GroupLayout entities$layout() {
        return entities$LAYOUT;
    }

    private static final long entities$OFFSET = $LAYOUT.byteOffset(groupElement("entities"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ecs_entities_memory_t entities
     * }
     */
    public static final long entities$offset() {
        return entities$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ecs_entities_memory_t entities
     * }
     */
    public static MemorySegment entities(MemorySegment struct) {
        return struct.asSlice(entities$OFFSET, entities$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ecs_entities_memory_t entities
     * }
     */
    public static void entities(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, entities$OFFSET, entities$LAYOUT.byteSize());
    }

    private static final GroupLayout components$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("components"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ecs_component_memory_t components
     * }
     */
    public static final GroupLayout components$layout() {
        return components$LAYOUT;
    }

    private static final long components$OFFSET = $LAYOUT.byteOffset(groupElement("components"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ecs_component_memory_t components
     * }
     */
    public static final long components$offset() {
        return components$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ecs_component_memory_t components
     * }
     */
    public static MemorySegment components(MemorySegment struct) {
        return struct.asSlice(components$OFFSET, components$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ecs_component_memory_t components
     * }
     */
    public static void components(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, components$OFFSET, components$LAYOUT.byteSize());
    }

    private static final GroupLayout component_index$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("component_index"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ecs_component_index_memory_t component_index
     * }
     */
    public static final GroupLayout component_index$layout() {
        return component_index$LAYOUT;
    }

    private static final long component_index$OFFSET = $LAYOUT.byteOffset(groupElement("component_index"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ecs_component_index_memory_t component_index
     * }
     */
    public static final long component_index$offset() {
        return component_index$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ecs_component_index_memory_t component_index
     * }
     */
    public static MemorySegment component_index(MemorySegment struct) {
        return struct.asSlice(component_index$OFFSET, component_index$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ecs_component_index_memory_t component_index
     * }
     */
    public static void component_index(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, component_index$OFFSET, component_index$LAYOUT.byteSize());
    }

    private static final GroupLayout queries$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("queries"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ecs_query_memory_t queries
     * }
     */
    public static final GroupLayout queries$layout() {
        return queries$LAYOUT;
    }

    private static final long queries$OFFSET = $LAYOUT.byteOffset(groupElement("queries"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ecs_query_memory_t queries
     * }
     */
    public static final long queries$offset() {
        return queries$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ecs_query_memory_t queries
     * }
     */
    public static MemorySegment queries(MemorySegment struct) {
        return struct.asSlice(queries$OFFSET, queries$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ecs_query_memory_t queries
     * }
     */
    public static void queries(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, queries$OFFSET, queries$LAYOUT.byteSize());
    }

    private static final GroupLayout tables$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("tables"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ecs_table_memory_t tables
     * }
     */
    public static final GroupLayout tables$layout() {
        return tables$LAYOUT;
    }

    private static final long tables$OFFSET = $LAYOUT.byteOffset(groupElement("tables"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ecs_table_memory_t tables
     * }
     */
    public static final long tables$offset() {
        return tables$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ecs_table_memory_t tables
     * }
     */
    public static MemorySegment tables(MemorySegment struct) {
        return struct.asSlice(tables$OFFSET, tables$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ecs_table_memory_t tables
     * }
     */
    public static void tables(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, tables$OFFSET, tables$LAYOUT.byteSize());
    }

    private static final GroupLayout table_histogram$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("table_histogram"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ecs_table_histogram_t table_histogram
     * }
     */
    public static final GroupLayout table_histogram$layout() {
        return table_histogram$LAYOUT;
    }

    private static final long table_histogram$OFFSET = $LAYOUT.byteOffset(groupElement("table_histogram"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ecs_table_histogram_t table_histogram
     * }
     */
    public static final long table_histogram$offset() {
        return table_histogram$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ecs_table_histogram_t table_histogram
     * }
     */
    public static MemorySegment table_histogram(MemorySegment struct) {
        return struct.asSlice(table_histogram$OFFSET, table_histogram$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ecs_table_histogram_t table_histogram
     * }
     */
    public static void table_histogram(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, table_histogram$OFFSET, table_histogram$LAYOUT.byteSize());
    }

    private static final GroupLayout misc$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("misc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ecs_misc_memory_t misc
     * }
     */
    public static final GroupLayout misc$layout() {
        return misc$LAYOUT;
    }

    private static final long misc$OFFSET = $LAYOUT.byteOffset(groupElement("misc"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ecs_misc_memory_t misc
     * }
     */
    public static final long misc$offset() {
        return misc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ecs_misc_memory_t misc
     * }
     */
    public static MemorySegment misc(MemorySegment struct) {
        return struct.asSlice(misc$OFFSET, misc$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ecs_misc_memory_t misc
     * }
     */
    public static void misc(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, misc$OFFSET, misc$LAYOUT.byteSize());
    }

    private static final GroupLayout allocators$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("allocators"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ecs_allocator_memory_t allocators
     * }
     */
    public static final GroupLayout allocators$layout() {
        return allocators$LAYOUT;
    }

    private static final long allocators$OFFSET = $LAYOUT.byteOffset(groupElement("allocators"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ecs_allocator_memory_t allocators
     * }
     */
    public static final long allocators$offset() {
        return allocators$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ecs_allocator_memory_t allocators
     * }
     */
    public static MemorySegment allocators(MemorySegment struct) {
        return struct.asSlice(allocators$OFFSET, allocators$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ecs_allocator_memory_t allocators
     * }
     */
    public static void allocators(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, allocators$OFFSET, allocators$LAYOUT.byteSize());
    }

    private static final OfDouble collection_time$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("collection_time"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double collection_time
     * }
     */
    public static final OfDouble collection_time$layout() {
        return collection_time$LAYOUT;
    }

    private static final long collection_time$OFFSET = $LAYOUT.byteOffset(groupElement("collection_time"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double collection_time
     * }
     */
    public static final long collection_time$offset() {
        return collection_time$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double collection_time
     * }
     */
    public static double collection_time(MemorySegment struct) {
        return struct.get(collection_time$LAYOUT, collection_time$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double collection_time
     * }
     */
    public static void collection_time(MemorySegment struct, double fieldValue) {
        struct.set(collection_time$LAYOUT, collection_time$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

