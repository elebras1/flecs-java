// Generated by jextract

package com.github.elebras1.flecs;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

class flecs_h_1 extends flecs_h$shared {

    flecs_h_1() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    private static final int FLECS_VERSION_MAJOR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FLECS_VERSION_MAJOR 4
     * }
     */
    public static int FLECS_VERSION_MAJOR() {
        return FLECS_VERSION_MAJOR;
    }
    private static final int FLECS_VERSION_MINOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FLECS_VERSION_MINOR 1
     * }
     */
    public static int FLECS_VERSION_MINOR() {
        return FLECS_VERSION_MINOR;
    }
    private static final int FLECS_VERSION_PATCH = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FLECS_VERSION_PATCH 4
     * }
     */
    public static int FLECS_VERSION_PATCH() {
        return FLECS_VERSION_PATCH;
    }
    private static final int FLECS_HI_COMPONENT_ID = (int)256L;
    /**
     * {@snippet lang=c :
     * #define FLECS_HI_COMPONENT_ID 256
     * }
     */
    public static int FLECS_HI_COMPONENT_ID() {
        return FLECS_HI_COMPONENT_ID;
    }
    private static final int FLECS_HI_ID_RECORD_ID = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FLECS_HI_ID_RECORD_ID 1024
     * }
     */
    public static int FLECS_HI_ID_RECORD_ID() {
        return FLECS_HI_ID_RECORD_ID;
    }
    private static final int FLECS_SPARSE_PAGE_BITS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define FLECS_SPARSE_PAGE_BITS 6
     * }
     */
    public static int FLECS_SPARSE_PAGE_BITS() {
        return FLECS_SPARSE_PAGE_BITS;
    }
    private static final int FLECS_ENTITY_PAGE_BITS = (int)10L;
    /**
     * {@snippet lang=c :
     * #define FLECS_ENTITY_PAGE_BITS 10
     * }
     */
    public static int FLECS_ENTITY_PAGE_BITS() {
        return FLECS_ENTITY_PAGE_BITS;
    }
    private static final int FLECS_ID_DESC_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define FLECS_ID_DESC_MAX 32
     * }
     */
    public static int FLECS_ID_DESC_MAX() {
        return FLECS_ID_DESC_MAX;
    }
    private static final int FLECS_EVENT_DESC_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FLECS_EVENT_DESC_MAX 8
     * }
     */
    public static int FLECS_EVENT_DESC_MAX() {
        return FLECS_EVENT_DESC_MAX;
    }
    private static final int FLECS_VARIABLE_COUNT_MAX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define FLECS_VARIABLE_COUNT_MAX 64
     * }
     */
    public static int FLECS_VARIABLE_COUNT_MAX() {
        return FLECS_VARIABLE_COUNT_MAX;
    }
    private static final int FLECS_TERM_COUNT_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define FLECS_TERM_COUNT_MAX 32
     * }
     */
    public static int FLECS_TERM_COUNT_MAX() {
        return FLECS_TERM_COUNT_MAX;
    }
    private static final int FLECS_TERM_ARG_COUNT_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FLECS_TERM_ARG_COUNT_MAX 16
     * }
     */
    public static int FLECS_TERM_ARG_COUNT_MAX() {
        return FLECS_TERM_ARG_COUNT_MAX;
    }
    private static final int FLECS_QUERY_VARIABLE_COUNT_MAX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define FLECS_QUERY_VARIABLE_COUNT_MAX 64
     * }
     */
    public static int FLECS_QUERY_VARIABLE_COUNT_MAX() {
        return FLECS_QUERY_VARIABLE_COUNT_MAX;
    }
    private static final int FLECS_QUERY_SCOPE_NESTING_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FLECS_QUERY_SCOPE_NESTING_MAX 8
     * }
     */
    public static int FLECS_QUERY_SCOPE_NESTING_MAX() {
        return FLECS_QUERY_SCOPE_NESTING_MAX;
    }
    private static final int FLECS_DAG_DEPTH_MAX = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FLECS_DAG_DEPTH_MAX 128
     * }
     */
    public static int FLECS_DAG_DEPTH_MAX() {
        return FLECS_DAG_DEPTH_MAX;
    }
    private static final int _ASSERT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ASSERT_H 1
     * }
     */
    public static int _ASSERT_H() {
        return _ASSERT_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2X 0
     * }
     */
    public static int __GLIBC_USE_ISOC2X() {
        return __GLIBC_USE_ISOC2X;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int __GLIBC_USE_C2X_STRTOL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_C2X_STRTOL 0
     * }
     */
    public static int __GLIBC_USE_C2X_STRTOL() {
        return __GLIBC_USE_C2X_STRTOL;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)39L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 39
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int _STRING_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRING_H 1
     * }
     */
    public static int _STRING_H() {
        return _STRING_H;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int _BITS_TYPES_LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES_LOCALE_T_H() {
        return _BITS_TYPES_LOCALE_T_H;
    }
    private static final int _BITS_TYPES___LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES___LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES___LOCALE_T_H() {
        return _BITS_TYPES___LOCALE_T_H;
    }
    private static final int _STRINGS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRINGS_H 1
     * }
     */
    public static int _STRINGS_H() {
        return _STRINGS_H;
    }
    private static final int _STDLIB_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDLIB_H 1
     * }
     */
    public static int _STDLIB_H() {
        return _STDLIB_H;
    }
    private static final int WNOHANG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WNOHANG 1
     * }
     */
    public static int WNOHANG() {
        return WNOHANG;
    }
    private static final int WUNTRACED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WUNTRACED 2
     * }
     */
    public static int WUNTRACED() {
        return WUNTRACED;
    }
    private static final int WSTOPPED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WSTOPPED 2
     * }
     */
    public static int WSTOPPED() {
        return WSTOPPED;
    }
    private static final int WEXITED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WEXITED 4
     * }
     */
    public static int WEXITED() {
        return WEXITED;
    }
    private static final int WCONTINUED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WCONTINUED 8
     * }
     */
    public static int WCONTINUED() {
        return WCONTINUED;
    }
    private static final int WNOWAIT = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define WNOWAIT 16777216
     * }
     */
    public static int WNOWAIT() {
        return WNOWAIT;
    }
    private static final int __WNOTHREAD = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define __WNOTHREAD 536870912
     * }
     */
    public static int __WNOTHREAD() {
        return __WNOTHREAD;
    }
    private static final int __WALL = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define __WALL 1073741824
     * }
     */
    public static int __WALL() {
        return __WALL;
    }
    private static final int __W_CONTINUED = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define __W_CONTINUED 65535
     * }
     */
    public static int __W_CONTINUED() {
        return __W_CONTINUED;
    }
    private static final int __WCOREFLAG = (int)128L;
    /**
     * {@snippet lang=c :
     * #define __WCOREFLAG 128
     * }
     */
    public static int __WCOREFLAG() {
        return __WCOREFLAG;
    }
    private static final int __HAVE_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128 0
     * }
     */
    public static int __HAVE_FLOAT128() {
        return __HAVE_FLOAT128;
    }
    private static final int __HAVE_DISTINCT_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128() {
        return __HAVE_DISTINCT_FLOAT128;
    }
    private static final int __HAVE_FLOAT64X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X 1
     * }
     */
    public static int __HAVE_FLOAT64X() {
        return __HAVE_FLOAT64X;
    }
    private static final int __HAVE_FLOAT64X_LONG_DOUBLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X_LONG_DOUBLE 1
     * }
     */
    public static int __HAVE_FLOAT64X_LONG_DOUBLE() {
        return __HAVE_FLOAT64X_LONG_DOUBLE;
    }
    private static final int __HAVE_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT16 0
     * }
     */
    public static int __HAVE_FLOAT16() {
        return __HAVE_FLOAT16;
    }
    private static final int __HAVE_FLOAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32 1
     * }
     */
    public static int __HAVE_FLOAT32() {
        return __HAVE_FLOAT32;
    }
    private static final int __HAVE_FLOAT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64 1
     * }
     */
    public static int __HAVE_FLOAT64() {
        return __HAVE_FLOAT64;
    }
    private static final int __HAVE_FLOAT32X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32X 1
     * }
     */
    public static int __HAVE_FLOAT32X() {
        return __HAVE_FLOAT32X;
    }
    private static final int __HAVE_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128X 0
     * }
     */
    public static int __HAVE_FLOAT128X() {
        return __HAVE_FLOAT128X;
    }
    private static final int __HAVE_DISTINCT_FLOAT32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32() {
        return __HAVE_DISTINCT_FLOAT32;
    }
    private static final int __HAVE_DISTINCT_FLOAT64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64() {
        return __HAVE_DISTINCT_FLOAT64;
    }
    private static final int __HAVE_DISTINCT_FLOAT32X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32X() {
        return __HAVE_DISTINCT_FLOAT32X;
    }
    private static final int __HAVE_DISTINCT_FLOAT64X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64X() {
        return __HAVE_DISTINCT_FLOAT64X;
    }
    private static final int __HAVE_FLOATN_NOT_TYPEDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOATN_NOT_TYPEDEF 0
     * }
     */
    public static int __HAVE_FLOATN_NOT_TYPEDEF() {
        return __HAVE_FLOATN_NOT_TYPEDEF;
    }
    private static final int __ldiv_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __ldiv_t_defined 1
     * }
     */
    public static int __ldiv_t_defined() {
        return __ldiv_t_defined;
    }
    private static final int __lldiv_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __lldiv_t_defined 1
     * }
     */
    public static int __lldiv_t_defined() {
        return __lldiv_t_defined;
    }
    private static final int RAND_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define RAND_MAX 2147483647
     * }
     */
    public static int RAND_MAX() {
        return RAND_MAX;
    }
    private static final int EXIT_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXIT_FAILURE 1
     * }
     */
    public static int EXIT_FAILURE() {
        return EXIT_FAILURE;
    }
    private static final int EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXIT_SUCCESS 0
     * }
     */
    public static int EXIT_SUCCESS() {
        return EXIT_SUCCESS;
    }
    private static final int _SYS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_TYPES_H 1
     * }
     */
    public static int _SYS_TYPES_H() {
        return _SYS_TYPES_H;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int __clock_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clock_t_defined 1
     * }
     */
    public static int __clock_t_defined() {
        return __clock_t_defined;
    }
    private static final int __clockid_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clockid_t_defined 1
     * }
     */
    public static int __clockid_t_defined() {
        return __clockid_t_defined;
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int __timer_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timer_t_defined 1
     * }
     */
    public static int __timer_t_defined() {
        return __timer_t_defined;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int __BIT_TYPES_DEFINED__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __BIT_TYPES_DEFINED__ 1
     * }
     */
    public static int __BIT_TYPES_DEFINED__() {
        return __BIT_TYPES_DEFINED__;
    }
    private static final int _ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ENDIAN_H 1
     * }
     */
    public static int _ENDIAN_H() {
        return _ENDIAN_H;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int _BITS_BYTESWAP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_BYTESWAP_H 1
     * }
     */
    public static int _BITS_BYTESWAP_H() {
        return _BITS_BYTESWAP_H;
    }
    private static final int _BITS_UINTN_IDENTITY_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_UINTN_IDENTITY_H 1
     * }
     */
    public static int _BITS_UINTN_IDENTITY_H() {
        return _BITS_UINTN_IDENTITY_H;
    }
    private static final int _SYS_SELECT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SELECT_H 1
     * }
     */
    public static int _SYS_SELECT_H() {
        return _SYS_SELECT_H;
    }
    private static final int __sigset_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __sigset_t_defined 1
     * }
     */
    public static int __sigset_t_defined() {
        return __sigset_t_defined;
    }
    private static final int __timeval_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timeval_defined 1
     * }
     */
    public static int __timeval_defined() {
        return __timeval_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_PTHREADTYPES_COMMON_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_COMMON_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_COMMON_H() {
        return _BITS_PTHREADTYPES_COMMON_H;
    }
    private static final int _THREAD_SHARED_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_SHARED_TYPES_H 1
     * }
     */
    public static int _THREAD_SHARED_TYPES_H() {
        return _THREAD_SHARED_TYPES_H;
    }
    private static final int _BITS_PTHREADTYPES_ARCH_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_ARCH_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_ARCH_H() {
        return _BITS_PTHREADTYPES_ARCH_H;
    }
    private static final int __SIZEOF_PTHREAD_MUTEX_T = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEX_T 40
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEX_T() {
        return __SIZEOF_PTHREAD_MUTEX_T;
    }
    private static final int __SIZEOF_PTHREAD_ATTR_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_ATTR_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_ATTR_T() {
        return __SIZEOF_PTHREAD_ATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCK_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCK_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCK_T() {
        return __SIZEOF_PTHREAD_RWLOCK_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIER_T = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIER_T 32
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIER_T() {
        return __SIZEOF_PTHREAD_BARRIER_T;
    }
    private static final int __SIZEOF_PTHREAD_MUTEXATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEXATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEXATTR_T() {
        return __SIZEOF_PTHREAD_MUTEXATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_COND_T = (int)48L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_COND_T 48
     * }
     */
    public static int __SIZEOF_PTHREAD_COND_T() {
        return __SIZEOF_PTHREAD_COND_T;
    }
    private static final int __SIZEOF_PTHREAD_CONDATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_CONDATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_CONDATTR_T() {
        return __SIZEOF_PTHREAD_CONDATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCKATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCKATTR_T() {
        return __SIZEOF_PTHREAD_RWLOCKATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIERATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIERATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIERATTR_T() {
        return __SIZEOF_PTHREAD_BARRIERATTR_T;
    }
    private static final int _THREAD_MUTEX_INTERNAL_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_MUTEX_INTERNAL_H 1
     * }
     */
    public static int _THREAD_MUTEX_INTERNAL_H() {
        return _THREAD_MUTEX_INTERNAL_H;
    }
    private static final int __PTHREAD_MUTEX_HAVE_PREV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_HAVE_PREV 1
     * }
     */
    public static int __PTHREAD_MUTEX_HAVE_PREV() {
        return __PTHREAD_MUTEX_HAVE_PREV;
    }
    private static final int __have_pthread_attr_t = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __have_pthread_attr_t 1
     * }
     */
    public static int __have_pthread_attr_t() {
        return __have_pthread_attr_t;
    }
    private static final int _ALLOCA_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ALLOCA_H 1
     * }
     */
    public static int _ALLOCA_H() {
        return _ALLOCA_H;
    }
    private static final int _STDINT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDINT_H 1
     * }
     */
    public static int _STDINT_H() {
        return _STDINT_H;
    }
    private static final int _BITS_WCHAR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_WCHAR_H 1
     * }
     */
    public static int _BITS_WCHAR_H() {
        return _BITS_WCHAR_H;
    }
    private static final int _BITS_STDINT_UINTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_UINTN_H 1
     * }
     */
    public static int _BITS_STDINT_UINTN_H() {
        return _BITS_STDINT_UINTN_H;
    }
    private static final int _BITS_STDINT_LEAST_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_LEAST_H 1
     * }
     */
    public static int _BITS_STDINT_LEAST_H() {
        return _BITS_STDINT_LEAST_H;
    }
    private static final int true_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define true 1
     * }
     */
    public static int true_() {
        return true_;
    }
    private static final int false_ = (int)0L;
    /**
     * {@snippet lang=c :
     * #define false 0
     * }
     */
    public static int false_() {
        return false_;
    }
    private static final int __bool_true_false_are_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __bool_true_false_are_defined 1
     * }
     */
    public static int __bool_true_false_are_defined() {
        return __bool_true_false_are_defined;
    }
    private static final int ECS_TABLE_MEMORY_HISTOGRAM_BUCKET_COUNT = (int)14L;
    /**
     * {@snippet lang=c :
     * #define ECS_TABLE_MEMORY_HISTOGRAM_BUCKET_COUNT 14
     * }
     */
    public static int ECS_TABLE_MEMORY_HISTOGRAM_BUCKET_COUNT() {
        return ECS_TABLE_MEMORY_HISTOGRAM_BUCKET_COUNT;
    }

    private static class __assert_fail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__assert_fail");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static FunctionDescriptor __assert_fail$descriptor() {
        return __assert_fail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static MethodHandle __assert_fail$handle() {
        return __assert_fail.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static MemorySegment __assert_fail$address() {
        return __assert_fail.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static void __assert_fail(MemorySegment __assertion, MemorySegment __file, int __line, MemorySegment __function) {
        var mh$ = __assert_fail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__assert_fail", __assertion, __file, __line, __function);
            }
            mh$.invokeExact(__assertion, __file, __line, __function);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __assert_perror_fail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__assert_perror_fail");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static FunctionDescriptor __assert_perror_fail$descriptor() {
        return __assert_perror_fail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static MethodHandle __assert_perror_fail$handle() {
        return __assert_perror_fail.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static MemorySegment __assert_perror_fail$address() {
        return __assert_perror_fail.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static void __assert_perror_fail(int __errnum, MemorySegment __file, int __line, MemorySegment __function) {
        var mh$ = __assert_perror_fail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__assert_perror_fail", __errnum, __file, __line, __function);
            }
            mh$.invokeExact(__errnum, __file, __line, __function);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __assert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__assert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __assert(const char *__assertion, const char *__file, int __line)
     * }
     */
    public static FunctionDescriptor __assert$descriptor() {
        return __assert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __assert(const char *__assertion, const char *__file, int __line)
     * }
     */
    public static MethodHandle __assert$handle() {
        return __assert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __assert(const char *__assertion, const char *__file, int __line)
     * }
     */
    public static MemorySegment __assert$address() {
        return __assert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __assert(const char *__assertion, const char *__file, int __line)
     * }
     */
    public static void __assert(MemorySegment __assertion, MemorySegment __file, int __line) {
        var mh$ = __assert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__assert", __assertion, __file, __line);
            }
            mh$.invokeExact(__assertion, __file, __line);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = flecs_h.C_LONG;

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment memcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memmove(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy(MemorySegment __dest, MemorySegment __src, int __c, long __n) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", __dest, __src, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __c, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memset(MemorySegment __s, int __c, long __n) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int memcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __memcmpeq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__memcmpeq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor __memcmpeq$descriptor() {
        return __memcmpeq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle __memcmpeq$handle() {
        return __memcmpeq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment __memcmpeq$address() {
        return __memcmpeq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int __memcmpeq(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = __memcmpeq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__memcmpeq", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr(MemorySegment __s, int __c, long __n) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcat(MemorySegment __dest, MemorySegment __src) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncat(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static int strcoll(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strxfrm(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct __locale_struct {
     *     struct __locale_data *__locales[13];
     *     const unsigned short *__ctype_b;
     *     const int *__ctype_tolower;
     *     const int *__ctype_toupper;
     *     const char *__names[13];
     * } *__locale_t
     * }
     */
    public static final AddressLayout __locale_t = flecs_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __locale_t locale_t
     * }
     */
    public static final AddressLayout locale_t = flecs_h.C_POINTER;

    private static class strcoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static FunctionDescriptor strcoll_l$descriptor() {
        return strcoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static MethodHandle strcoll_l$handle() {
        return strcoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static MemorySegment strcoll_l$address() {
        return strcoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static int strcoll_l(MemorySegment __s1, MemorySegment __s2, MemorySegment __l) {
        var mh$ = strcoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll_l", __s1, __s2, __l);
            }
            return (int)mh$.invokeExact(__s1, __s2, __l);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strxfrm_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static FunctionDescriptor strxfrm_l$descriptor() {
        return strxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static MethodHandle strxfrm_l$handle() {
        return strxfrm_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static MemorySegment strxfrm_l$address() {
        return strxfrm_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static long strxfrm_l(MemorySegment __dest, MemorySegment __src, long __n, MemorySegment __l) {
        var mh$ = strxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm_l", __dest, __src, __n, __l);
            }
            return (long)mh$.invokeExact(__dest, __src, __n, __l);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MemorySegment strdup(MemorySegment __s) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static FunctionDescriptor strndup$descriptor() {
        return strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MethodHandle strndup$handle() {
        return strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MemorySegment strndup$address() {
        return strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MemorySegment strndup(MemorySegment __string, long __n) {
        var mh$ = strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strndup", __string, __n);
            }
            return (MemorySegment)mh$.invokeExact(__string, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr(MemorySegment __s, int __c) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr(MemorySegment __s, int __c) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchrnul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strchrnul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchrnul$descriptor() {
        return strchrnul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchrnul$handle() {
        return strchrnul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchrnul$address() {
        return strchrnul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchrnul(MemorySegment __s, int __c) {
        var mh$ = strchrnul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchrnul", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static long strcspn(MemorySegment __s, MemorySegment __reject) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", __s, __reject);
            }
            return (long)mh$.invokeExact(__s, __reject);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static long strspn(MemorySegment __s, MemorySegment __accept) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", __s, __accept);
            }
            return (long)mh$.invokeExact(__s, __accept);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment __s, MemorySegment __accept) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", __s, __accept);
            }
            return (MemorySegment)mh$.invokeExact(__s, __accept);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strstr(MemorySegment __haystack, MemorySegment __needle) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", __haystack, __needle);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __needle);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MemorySegment strtok(MemorySegment __s, MemorySegment __delim) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", __s, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static FunctionDescriptor __strtok_r$descriptor() {
        return __strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MethodHandle __strtok_r$handle() {
        return __strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment __strtok_r$address() {
        return __strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment __strtok_r(MemorySegment __s, MemorySegment __delim, MemorySegment __save_ptr) {
        var mh$ = __strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__strtok_r", __s, __delim, __save_ptr);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim, __save_ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static FunctionDescriptor strtok_r$descriptor() {
        return strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MethodHandle strtok_r$handle() {
        return strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment strtok_r$address() {
        return strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment strtok_r(MemorySegment __s, MemorySegment __delim, MemorySegment __save_ptr) {
        var mh$ = strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_r", __s, __delim, __save_ptr);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim, __save_ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasestr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcasestr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static FunctionDescriptor strcasestr$descriptor() {
        return strcasestr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static MethodHandle strcasestr$handle() {
        return strcasestr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strcasestr$address() {
        return strcasestr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strcasestr(MemorySegment __haystack, MemorySegment __needle) {
        var mh$ = strcasestr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasestr", __haystack, __needle);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __needle);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memmem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static FunctionDescriptor memmem$descriptor() {
        return memmem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static MethodHandle memmem$handle() {
        return memmem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static MemorySegment memmem$address() {
        return memmem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static MemorySegment memmem(MemorySegment __haystack, long __haystacklen, MemorySegment __needle, long __needlelen) {
        var mh$ = memmem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmem", __haystack, __haystacklen, __needle, __needlelen);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __haystacklen, __needle, __needlelen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __mempcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__mempcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor __mempcpy$descriptor() {
        return __mempcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle __mempcpy$handle() {
        return __mempcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __mempcpy$address() {
        return __mempcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __mempcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = __mempcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__mempcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mempcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mempcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor mempcpy$descriptor() {
        return mempcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle mempcpy$handle() {
        return mempcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment mempcpy$address() {
        return mempcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment mempcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = mempcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mempcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static long strlen(MemorySegment __s) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static long strnlen(MemorySegment __string, long __maxlen) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", __string, __maxlen);
            }
            return (long)mh$.invokeExact(__string, __maxlen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror(int __errnum) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", __errnum);
            }
            return (MemorySegment)mh$.invokeExact(__errnum);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__xpg_strerror_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strerror_r$descriptor() {
        return strerror_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static MethodHandle strerror_r$handle() {
        return strerror_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static MemorySegment strerror_r$address() {
        return strerror_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static int strerror_r(int __errnum, MemorySegment __buf, long __buflen) {
        var mh$ = strerror_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_r", __errnum, __buf, __buflen);
            }
            return (int)mh$.invokeExact(__errnum, __buf, __buflen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strerror_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static FunctionDescriptor strerror_l$descriptor() {
        return strerror_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MethodHandle strerror_l$handle() {
        return strerror_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MemorySegment strerror_l$address() {
        return strerror_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MemorySegment strerror_l(int __errnum, MemorySegment __l) {
        var mh$ = strerror_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_l", __errnum, __l);
            }
            return (MemorySegment)mh$.invokeExact(__errnum, __l);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor bcmp$descriptor() {
        return bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle bcmp$handle() {
        return bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment bcmp$address() {
        return bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int bcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static FunctionDescriptor bcopy$descriptor() {
        return bcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static MethodHandle bcopy$handle() {
        return bcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static MemorySegment bcopy$address() {
        return bcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static void bcopy(MemorySegment __src, MemorySegment __dest, long __n) {
        var mh$ = bcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcopy", __src, __dest, __n);
            }
            mh$.invokeExact(__src, __dest, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor bzero$descriptor() {
        return bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static MethodHandle bzero$handle() {
        return bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static MemorySegment bzero$address() {
        return bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static void bzero(MemorySegment __s, long __n) {
        var mh$ = bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bzero", __s, __n);
            }
            mh$.invokeExact(__s, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor index$descriptor() {
        return index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MethodHandle index$handle() {
        return index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MemorySegment index$address() {
        return index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MemorySegment index(MemorySegment __s, int __c) {
        var mh$ = index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("index", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor rindex$descriptor() {
        return rindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MethodHandle rindex$handle() {
        return rindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MemorySegment rindex$address() {
        return rindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MemorySegment rindex(MemorySegment __s, int __c) {
        var mh$ = rindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rindex", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static FunctionDescriptor ffs$descriptor() {
        return ffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static MethodHandle ffs$handle() {
        return ffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static MemorySegment ffs$address() {
        return ffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static int ffs(int __i) {
        var mh$ = ffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffs", __i);
            }
            return (int)mh$.invokeExact(__i);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ffsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static FunctionDescriptor ffsl$descriptor() {
        return ffsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static MethodHandle ffsl$handle() {
        return ffsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static MemorySegment ffsl$address() {
        return ffsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static int ffsl(long __l) {
        var mh$ = ffsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsl", __l);
            }
            return (int)mh$.invokeExact(__l);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ffsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static FunctionDescriptor ffsll$descriptor() {
        return ffsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static MethodHandle ffsll$handle() {
        return ffsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static MemorySegment ffsll$address() {
        return ffsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static int ffsll(long __ll) {
        var mh$ = ffsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsll", __ll);
            }
            return (int)mh$.invokeExact(__ll);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcasecmp$descriptor() {
        return strcasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcasecmp$handle() {
        return strcasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcasecmp$address() {
        return strcasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcasecmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncasecmp$descriptor() {
        return strncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncasecmp$handle() {
        return strncasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncasecmp$address() {
        return strncasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncasecmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcasecmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strcasecmp_l$descriptor() {
        return strcasecmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static MethodHandle strcasecmp_l$handle() {
        return strcasecmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static MemorySegment strcasecmp_l$address() {
        return strcasecmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static int strcasecmp_l(MemorySegment __s1, MemorySegment __s2, MemorySegment __loc) {
        var mh$ = strcasecmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp_l", __s1, __s2, __loc);
            }
            return (int)mh$.invokeExact(__s1, __s2, __loc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncasecmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strncasecmp_l$descriptor() {
        return strncasecmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static MethodHandle strncasecmp_l$handle() {
        return strncasecmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static MemorySegment strncasecmp_l$address() {
        return strncasecmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static int strncasecmp_l(MemorySegment __s1, MemorySegment __s2, long __n, MemorySegment __loc) {
        var mh$ = strncasecmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp_l", __s1, __s2, __n, __loc);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n, __loc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class explicit_bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("explicit_bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor explicit_bzero$descriptor() {
        return explicit_bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static MethodHandle explicit_bzero$handle() {
        return explicit_bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static MemorySegment explicit_bzero$address() {
        return explicit_bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static void explicit_bzero(MemorySegment __s, long __n) {
        var mh$ = explicit_bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("explicit_bzero", __s, __n);
            }
            mh$.invokeExact(__s, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strsep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static FunctionDescriptor strsep$descriptor() {
        return strsep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MethodHandle strsep$handle() {
        return strsep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MemorySegment strsep$address() {
        return strsep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MemorySegment strsep(MemorySegment __stringp, MemorySegment __delim) {
        var mh$ = strsep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsep", __stringp, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__stringp, __delim);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static FunctionDescriptor strsignal$descriptor() {
        return strsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MethodHandle strsignal$handle() {
        return strsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal$address() {
        return strsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal(int __sig) {
        var mh$ = strsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal", __sig);
            }
            return (MemorySegment)mh$.invokeExact(__sig);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor __stpcpy$descriptor() {
        return __stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle __stpcpy$handle() {
        return __stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment __stpcpy$address() {
        return __stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment __stpcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = __stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stpcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor stpcpy$descriptor() {
        return stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle stpcpy$handle() {
        return stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment stpcpy$address() {
        return stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment stpcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor __stpncpy$descriptor() {
        return __stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle __stpncpy$handle() {
        return __stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __stpncpy$address() {
        return __stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __stpncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = __stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stpncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor stpncpy$descriptor() {
        return stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle stpncpy$handle() {
        return stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy$address() {
        return stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strlcpy$descriptor() {
        return strlcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strlcpy$handle() {
        return strlcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strlcpy$address() {
        return strlcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strlcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strlcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcpy", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strlcat$descriptor() {
        return strlcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strlcat$handle() {
        return strlcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strlcat$address() {
        return strlcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strlcat(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strlcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcat", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef float _Float32
     * }
     */
    public static final OfFloat _Float32 = flecs_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double _Float64
     * }
     */
    public static final OfDouble _Float64 = flecs_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double _Float32x
     * }
     */
    public static final OfDouble _Float32x = flecs_h.C_DOUBLE;

    private static class __ctype_get_mb_cur_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__ctype_get_mb_cur_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static FunctionDescriptor __ctype_get_mb_cur_max$descriptor() {
        return __ctype_get_mb_cur_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MethodHandle __ctype_get_mb_cur_max$handle() {
        return __ctype_get_mb_cur_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MemorySegment __ctype_get_mb_cur_max$address() {
        return __ctype_get_mb_cur_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static long __ctype_get_mb_cur_max() {
        var mh$ = __ctype_get_mb_cur_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctype_get_mb_cur_max");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_DOUBLE,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static double atof(MemorySegment __nptr) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", __nptr);
            }
            return (double)mh$.invokeExact(__nptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static int atoi(MemorySegment __nptr) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", __nptr);
            }
            return (int)mh$.invokeExact(__nptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static long atol(MemorySegment __nptr) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static long atoll(MemorySegment __nptr) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_DOUBLE,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static double strtod(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", __nptr, __endptr);
            }
            return (double)mh$.invokeExact(__nptr, __endptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_FLOAT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static float strtof(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", __nptr, __endptr);
            }
            return (float)mh$.invokeExact(__nptr, __endptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a(long __n) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", __n);
            }
            return (MemorySegment)mh$.invokeExact(__n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static long a64l(MemorySegment __s) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = flecs_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = flecs_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = flecs_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = flecs_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = flecs_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = flecs_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = flecs_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = flecs_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = flecs_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = flecs_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = flecs_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = flecs_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = flecs_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = flecs_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfLong nlink_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = flecs_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = flecs_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = flecs_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = flecs_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = flecs_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = flecs_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = flecs_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = flecs_h.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfLong blksize_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __tss_t
     * }
     */
    public static final OfInt __tss_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __thrd_t
     * }
     */
    public static final OfLong __thrd_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = flecs_h.C_INT;

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static void srandom(int __seed) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate(int __seed, MemorySegment __statebuf, long __statelen) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", __seed, __statebuf, __statelen);
            }
            return (MemorySegment)mh$.invokeExact(__seed, __statebuf, __statelen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate(MemorySegment __statebuf) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", __statebuf);
            }
            return (MemorySegment)mh$.invokeExact(__statebuf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("random_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static FunctionDescriptor random_r$descriptor() {
        return random_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MethodHandle random_r$handle() {
        return random_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MemorySegment random_r$address() {
        return random_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static int random_r(MemorySegment __buf, MemorySegment __result) {
        var mh$ = random_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random_r", __buf, __result);
            }
            return (int)mh$.invokeExact(__buf, __result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srandom_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static FunctionDescriptor srandom_r$descriptor() {
        return srandom_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MethodHandle srandom_r$handle() {
        return srandom_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MemorySegment srandom_r$address() {
        return srandom_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static int srandom_r(int __seed, MemorySegment __buf) {
        var mh$ = srandom_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom_r", __seed, __buf);
            }
            return (int)mh$.invokeExact(__seed, __buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("initstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor initstate_r$descriptor() {
        return initstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle initstate_r$handle() {
        return initstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment initstate_r$address() {
        return initstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static int initstate_r(int __seed, MemorySegment __statebuf, long __statelen, MemorySegment __buf) {
        var mh$ = initstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate_r", __seed, __statebuf, __statelen, __buf);
            }
            return (int)mh$.invokeExact(__seed, __statebuf, __statelen, __buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor setstate_r$descriptor() {
        return setstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle setstate_r$handle() {
        return setstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment setstate_r$address() {
        return setstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static int setstate_r(MemorySegment __statebuf, MemorySegment __buf) {
        var mh$ = setstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate_r", __statebuf, __buf);
            }
            return (int)mh$.invokeExact(__statebuf, __buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static void srand(int __seed) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static int rand_r(MemorySegment __seed) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", __seed);
            }
            return (int)mh$.invokeExact(__seed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_DOUBLE    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_DOUBLE,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static double erand48(MemorySegment __xsubi) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", __xsubi);
            }
            return (double)mh$.invokeExact(__xsubi);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static long nrand48(MemorySegment __xsubi) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static long jrand48(MemorySegment __xsubi) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static void srand48(long __seedval) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", __seedval);
            }
            mh$.invokeExact(__seedval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48(MemorySegment __seed16v) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", __seed16v);
            }
            return (MemorySegment)mh$.invokeExact(__seed16v);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static void lcong48(MemorySegment __param) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", __param);
            }
            mh$.invokeExact(__param);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("drand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor drand48_r$descriptor() {
        return drand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle drand48_r$handle() {
        return drand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment drand48_r$address() {
        return drand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int drand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = drand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("erand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor erand48_r$descriptor() {
        return erand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle erand48_r$handle() {
        return erand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment erand48_r$address() {
        return erand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int erand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = erand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor lrand48_r$descriptor() {
        return lrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle lrand48_r$handle() {
        return lrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment lrand48_r$address() {
        return lrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int lrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = lrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor nrand48_r$descriptor() {
        return nrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle nrand48_r$handle() {
        return nrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment nrand48_r$address() {
        return nrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int nrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = nrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor mrand48_r$descriptor() {
        return mrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle mrand48_r$handle() {
        return mrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment mrand48_r$address() {
        return mrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int mrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = mrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("jrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor jrand48_r$descriptor() {
        return jrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle jrand48_r$handle() {
        return jrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment jrand48_r$address() {
        return jrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int jrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = jrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor srand48_r$descriptor() {
        return srand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle srand48_r$handle() {
        return srand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment srand48_r$address() {
        return srand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static int srand48_r(long __seedval, MemorySegment __buffer) {
        var mh$ = srand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48_r", __seedval, __buffer);
            }
            return (int)mh$.invokeExact(__seedval, __buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("seed48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor seed48_r$descriptor() {
        return seed48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle seed48_r$handle() {
        return seed48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment seed48_r$address() {
        return seed48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static int seed48_r(MemorySegment __seed16v, MemorySegment __buffer) {
        var mh$ = seed48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48_r", __seed16v, __buffer);
            }
            return (int)mh$.invokeExact(__seed16v, __buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lcong48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor lcong48_r$descriptor() {
        return lcong48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle lcong48_r$handle() {
        return lcong48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment lcong48_r$address() {
        return lcong48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static int lcong48_r(MemorySegment __param, MemorySegment __buffer) {
        var mh$ = lcong48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48_r", __param, __buffer);
            }
            return (int)mh$.invokeExact(__param, __buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static MemorySegment arc4random$address() {
        return arc4random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static MemorySegment arc4random_buf$address() {
        return arc4random_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __size) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __size);
            }
            mh$.invokeExact(__buf, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static MemorySegment arc4random_uniform$address() {
        return arc4random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __nmemb, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__nmemb, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static void free(MemorySegment __ptr) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", __ptr);
            }
            mh$.invokeExact(__ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("reallocarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocarray$descriptor() {
        return reallocarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle reallocarray$handle() {
        return reallocarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray$address() {
        return reallocarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray(MemorySegment __ptr, long __nmemb, long __size) {
        var mh$ = reallocarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocarray", __ptr, __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __nmemb, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca(long __size) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc(long __size) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static int atexit(MemorySegment __func) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment __func) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class on_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("on_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static FunctionDescriptor on_exit$descriptor() {
        return on_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MethodHandle on_exit$handle() {
        return on_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MemorySegment on_exit$address() {
        return on_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static int on_exit(MemorySegment __func, MemorySegment __arg) {
        var mh$ = on_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("on_exit", __func, __arg);
            }
            return (int)mh$.invokeExact(__func, __arg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static void exit(int __status) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static void quick_exit(int __status) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static void _Exit(int __status) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv(MemorySegment __name) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static int putenv(MemorySegment __string) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", __string);
            }
            return (int)mh$.invokeExact(__string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __replace) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __replace);
            }
            return (int)mh$.invokeExact(__name, __value, __replace);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static int unsetenv(MemorySegment __name) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clearenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static FunctionDescriptor clearenv$descriptor() {
        return clearenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MethodHandle clearenv$handle() {
        return clearenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MemorySegment clearenv$address() {
        return clearenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static int clearenv() {
        var mh$ = clearenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearenv");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp(MemorySegment __template) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static int mkstemp(MemorySegment __template) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", __template);
            }
            return (int)mh$.invokeExact(__template);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mkstemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static FunctionDescriptor mkstemps$descriptor() {
        return mkstemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MethodHandle mkstemps$handle() {
        return mkstemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MemorySegment mkstemps$address() {
        return mkstemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static int mkstemps(MemorySegment __template, int __suffixlen) {
        var mh$ = mkstemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemps", __template, __suffixlen);
            }
            return (int)mh$.invokeExact(__template, __suffixlen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mkdtemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkdtemp$descriptor() {
        return mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MethodHandle mkdtemp$handle() {
        return mkdtemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp$address() {
        return mkdtemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp(MemorySegment __template) {
        var mh$ = mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static int system(MemorySegment __command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", __command);
            }
            return (int)mh$.invokeExact(__command);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("realpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath(MemorySegment __name, MemorySegment __resolved) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", __name, __resolved);
            }
            return (MemorySegment)mh$.invokeExact(__name, __resolved);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nmemb, __size, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nmemb, __size, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static void qsort(MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nmemb, __size, __compar);
            }
            mh$.invokeExact(__base, __nmemb, __size, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static int abs(int __x) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static long labs(long __x) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG_LONG,
            flecs_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static long llabs(long __x) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int __numer, int __denom) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            flecs_h.C_LONG_LONG,
            flecs_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_DOUBLE,
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_DOUBLE,
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_DOUBLE,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt(double __value, int __ndigit, MemorySegment __buf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", __value, __ndigit, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_DOUBLE,
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor ecvt_r$descriptor() {
        return ecvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle ecvt_r$handle() {
        return ecvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment ecvt_r$address() {
        return ecvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int ecvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = ecvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_DOUBLE,
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fcvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor fcvt_r$descriptor() {
        return fcvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle fcvt_r$handle() {
        return fcvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment fcvt_r$address() {
        return fcvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int fcvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = fcvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static int mbtowc(MemorySegment __pwc, MemorySegment __s, long __n) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", __pwc, __s, __n);
            }
            return (int)mh$.invokeExact(__pwc, __s, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static int wctomb(MemorySegment __s, int __wchar) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", __s, __wchar);
            }
            return (int)mh$.invokeExact(__s, __wchar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static long mbstowcs(MemorySegment __pwcs, MemorySegment __s, long __n) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", __pwcs, __s, __n);
            }
            return (long)mh$.invokeExact(__pwcs, __s, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static long wcstombs(MemorySegment __s, MemorySegment __pwcs, long __n) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", __s, __pwcs, __n);
            }
            return (long)mh$.invokeExact(__s, __pwcs, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static int rpmatch(MemorySegment __response) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", __response);
            }
            return (int)mh$.invokeExact(__response);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static int getsubopt(MemorySegment __optionp, MemorySegment __tokens, MemorySegment __valuep) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", __optionp, __tokens, __valuep);
            }
            return (int)mh$.invokeExact(__optionp, __tokens, __valuep);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static int getloadavg(MemorySegment __loadavg, int __nelem) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", __loadavg, __nelem);
            }
            return (int)mh$.invokeExact(__loadavg, __nelem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = flecs_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = flecs_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = flecs_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = flecs_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = flecs_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = flecs_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = flecs_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = flecs_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t ecs_flags8_t
     * }
     */
    public static final OfByte ecs_flags8_t = flecs_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t ecs_flags16_t
     * }
     */
    public static final OfShort ecs_flags16_t = flecs_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t ecs_flags32_t
     * }
     */
    public static final OfInt ecs_flags32_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t ecs_flags64_t
     * }
     */
    public static final OfLong ecs_flags64_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int32_t ecs_size_t
     * }
     */
    public static final OfInt ecs_size_t = flecs_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t ecs_id_t
     * }
     */
    public static final OfLong ecs_id_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef ecs_id_t ecs_entity_t
     * }
     */
    public static final OfLong ecs_entity_t = flecs_h.C_LONG;

    private static class ecs_vec_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_init(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static FunctionDescriptor ecs_vec_init$descriptor() {
        return ecs_vec_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_init(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MethodHandle ecs_vec_init$handle() {
        return ecs_vec_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_init(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MemorySegment ecs_vec_init$address() {
        return ecs_vec_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_init(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static void ecs_vec_init(MemorySegment allocator, MemorySegment vec, int size, int elem_count) {
        var mh$ = ecs_vec_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_init", allocator, vec, size, elem_count);
            }
            mh$.invokeExact(allocator, vec, size, elem_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_init_w_dbg_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_init_w_dbg_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_init_w_dbg_info(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count, const char *type_name)
     * }
     */
    public static FunctionDescriptor ecs_vec_init_w_dbg_info$descriptor() {
        return ecs_vec_init_w_dbg_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_init_w_dbg_info(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count, const char *type_name)
     * }
     */
    public static MethodHandle ecs_vec_init_w_dbg_info$handle() {
        return ecs_vec_init_w_dbg_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_init_w_dbg_info(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count, const char *type_name)
     * }
     */
    public static MemorySegment ecs_vec_init_w_dbg_info$address() {
        return ecs_vec_init_w_dbg_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_init_w_dbg_info(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count, const char *type_name)
     * }
     */
    public static void ecs_vec_init_w_dbg_info(MemorySegment allocator, MemorySegment vec, int size, int elem_count, MemorySegment type_name) {
        var mh$ = ecs_vec_init_w_dbg_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_init_w_dbg_info", allocator, vec, size, elem_count, type_name);
            }
            mh$.invokeExact(allocator, vec, size, elem_count, type_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_init_if {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_init_if");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_init_if(ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_vec_init_if$descriptor() {
        return ecs_vec_init_if.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_init_if(ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_vec_init_if$handle() {
        return ecs_vec_init_if.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_init_if(ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_init_if$address() {
        return ecs_vec_init_if.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_init_if(ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static void ecs_vec_init_if(MemorySegment vec, int size) {
        var mh$ = ecs_vec_init_if.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_init_if", vec, size);
            }
            mh$.invokeExact(vec, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_fini(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_vec_fini$descriptor() {
        return ecs_vec_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_fini(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_vec_fini$handle() {
        return ecs_vec_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_fini(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_fini$address() {
        return ecs_vec_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_fini(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static void ecs_vec_fini(MemorySegment allocator, MemorySegment vec, int size) {
        var mh$ = ecs_vec_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_fini", allocator, vec, size);
            }
            mh$.invokeExact(allocator, vec, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_vec_t *ecs_vec_reset(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_vec_reset$descriptor() {
        return ecs_vec_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_vec_t *ecs_vec_reset(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_vec_reset$handle() {
        return ecs_vec_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_vec_t *ecs_vec_reset(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_reset$address() {
        return ecs_vec_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_vec_t *ecs_vec_reset(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_reset(MemorySegment allocator, MemorySegment vec, int size) {
        var mh$ = ecs_vec_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_reset", allocator, vec, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, vec, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_clear(ecs_vec_t *vec)
     * }
     */
    public static FunctionDescriptor ecs_vec_clear$descriptor() {
        return ecs_vec_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_clear(ecs_vec_t *vec)
     * }
     */
    public static MethodHandle ecs_vec_clear$handle() {
        return ecs_vec_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_clear(ecs_vec_t *vec)
     * }
     */
    public static MemorySegment ecs_vec_clear$address() {
        return ecs_vec_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_clear(ecs_vec_t *vec)
     * }
     */
    public static void ecs_vec_clear(MemorySegment vec) {
        var mh$ = ecs_vec_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_clear", vec);
            }
            mh$.invokeExact(vec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_vec_append(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_vec_append$descriptor() {
        return ecs_vec_append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_vec_append(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_vec_append$handle() {
        return ecs_vec_append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_vec_append(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_append$address() {
        return ecs_vec_append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_vec_append(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_append(MemorySegment allocator, MemorySegment vec, int size) {
        var mh$ = ecs_vec_append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_append", allocator, vec, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, vec, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_remove(ecs_vec_t *vec, ecs_size_t size, int32_t elem)
     * }
     */
    public static FunctionDescriptor ecs_vec_remove$descriptor() {
        return ecs_vec_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_remove(ecs_vec_t *vec, ecs_size_t size, int32_t elem)
     * }
     */
    public static MethodHandle ecs_vec_remove$handle() {
        return ecs_vec_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_remove(ecs_vec_t *vec, ecs_size_t size, int32_t elem)
     * }
     */
    public static MemorySegment ecs_vec_remove$address() {
        return ecs_vec_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_remove(ecs_vec_t *vec, ecs_size_t size, int32_t elem)
     * }
     */
    public static void ecs_vec_remove(MemorySegment vec, int size, int elem) {
        var mh$ = ecs_vec_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_remove", vec, size, elem);
            }
            mh$.invokeExact(vec, size, elem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_remove_ordered {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_remove_ordered");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_remove_ordered(ecs_vec_t *v, ecs_size_t size, int32_t index)
     * }
     */
    public static FunctionDescriptor ecs_vec_remove_ordered$descriptor() {
        return ecs_vec_remove_ordered.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_remove_ordered(ecs_vec_t *v, ecs_size_t size, int32_t index)
     * }
     */
    public static MethodHandle ecs_vec_remove_ordered$handle() {
        return ecs_vec_remove_ordered.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_remove_ordered(ecs_vec_t *v, ecs_size_t size, int32_t index)
     * }
     */
    public static MemorySegment ecs_vec_remove_ordered$address() {
        return ecs_vec_remove_ordered.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_remove_ordered(ecs_vec_t *v, ecs_size_t size, int32_t index)
     * }
     */
    public static void ecs_vec_remove_ordered(MemorySegment v, int size, int index) {
        var mh$ = ecs_vec_remove_ordered.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_remove_ordered", v, size, index);
            }
            mh$.invokeExact(v, size, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_remove_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_remove_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_remove_last(ecs_vec_t *vec)
     * }
     */
    public static FunctionDescriptor ecs_vec_remove_last$descriptor() {
        return ecs_vec_remove_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_remove_last(ecs_vec_t *vec)
     * }
     */
    public static MethodHandle ecs_vec_remove_last$handle() {
        return ecs_vec_remove_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_remove_last(ecs_vec_t *vec)
     * }
     */
    public static MemorySegment ecs_vec_remove_last$address() {
        return ecs_vec_remove_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_remove_last(ecs_vec_t *vec)
     * }
     */
    public static void ecs_vec_remove_last(MemorySegment vec) {
        var mh$ = ecs_vec_remove_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_remove_last", vec);
            }
            mh$.invokeExact(vec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_vec_t.layout(),
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_vec_t ecs_vec_copy(struct ecs_allocator_t *allocator, const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_vec_copy$descriptor() {
        return ecs_vec_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_vec_t ecs_vec_copy(struct ecs_allocator_t *allocator, const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_vec_copy$handle() {
        return ecs_vec_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_vec_t ecs_vec_copy(struct ecs_allocator_t *allocator, const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_copy$address() {
        return ecs_vec_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_vec_t ecs_vec_copy(struct ecs_allocator_t *allocator, const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_copy(SegmentAllocator _allocator, MemorySegment allocator, MemorySegment vec, int size) {
        var mh$ = ecs_vec_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_copy", _allocator, allocator, vec, size);
            }
            return (MemorySegment)mh$.invokeExact(_allocator, allocator, vec, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_copy_shrink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_vec_t.layout(),
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_copy_shrink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_vec_t ecs_vec_copy_shrink(struct ecs_allocator_t *allocator, const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_vec_copy_shrink$descriptor() {
        return ecs_vec_copy_shrink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_vec_t ecs_vec_copy_shrink(struct ecs_allocator_t *allocator, const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_vec_copy_shrink$handle() {
        return ecs_vec_copy_shrink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_vec_t ecs_vec_copy_shrink(struct ecs_allocator_t *allocator, const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_copy_shrink$address() {
        return ecs_vec_copy_shrink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_vec_t ecs_vec_copy_shrink(struct ecs_allocator_t *allocator, const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_copy_shrink(SegmentAllocator _allocator, MemorySegment allocator, MemorySegment vec, int size) {
        var mh$ = ecs_vec_copy_shrink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_copy_shrink", _allocator, allocator, vec, size);
            }
            return (MemorySegment)mh$.invokeExact(_allocator, allocator, vec, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_reclaim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_reclaim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_reclaim(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_vec_reclaim$descriptor() {
        return ecs_vec_reclaim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_reclaim(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_vec_reclaim$handle() {
        return ecs_vec_reclaim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_reclaim(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_reclaim$address() {
        return ecs_vec_reclaim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_reclaim(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static void ecs_vec_reclaim(MemorySegment allocator, MemorySegment vec, int size) {
        var mh$ = ecs_vec_reclaim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_reclaim", allocator, vec, size);
            }
            mh$.invokeExact(allocator, vec, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_set_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_set_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_set_size(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static FunctionDescriptor ecs_vec_set_size$descriptor() {
        return ecs_vec_set_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_set_size(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MethodHandle ecs_vec_set_size$handle() {
        return ecs_vec_set_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_set_size(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MemorySegment ecs_vec_set_size$address() {
        return ecs_vec_set_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_set_size(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static void ecs_vec_set_size(MemorySegment allocator, MemorySegment vec, int size, int elem_count) {
        var mh$ = ecs_vec_set_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_set_size", allocator, vec, size, elem_count);
            }
            mh$.invokeExact(allocator, vec, size, elem_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_set_min_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_set_min_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_size(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static FunctionDescriptor ecs_vec_set_min_size$descriptor() {
        return ecs_vec_set_min_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_size(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MethodHandle ecs_vec_set_min_size$handle() {
        return ecs_vec_set_min_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_size(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MemorySegment ecs_vec_set_min_size$address() {
        return ecs_vec_set_min_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_set_min_size(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static void ecs_vec_set_min_size(MemorySegment allocator, MemorySegment vec, int size, int elem_count) {
        var mh$ = ecs_vec_set_min_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_set_min_size", allocator, vec, size, elem_count);
            }
            mh$.invokeExact(allocator, vec, size, elem_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_set_min_size_w_type_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_set_min_size_w_type_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_size_w_type_info(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count, const ecs_type_info_t *ti)
     * }
     */
    public static FunctionDescriptor ecs_vec_set_min_size_w_type_info$descriptor() {
        return ecs_vec_set_min_size_w_type_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_size_w_type_info(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count, const ecs_type_info_t *ti)
     * }
     */
    public static MethodHandle ecs_vec_set_min_size_w_type_info$handle() {
        return ecs_vec_set_min_size_w_type_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_size_w_type_info(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count, const ecs_type_info_t *ti)
     * }
     */
    public static MemorySegment ecs_vec_set_min_size_w_type_info$address() {
        return ecs_vec_set_min_size_w_type_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_set_min_size_w_type_info(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count, const ecs_type_info_t *ti)
     * }
     */
    public static void ecs_vec_set_min_size_w_type_info(MemorySegment allocator, MemorySegment vec, int size, int elem_count, MemorySegment ti) {
        var mh$ = ecs_vec_set_min_size_w_type_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_set_min_size_w_type_info", allocator, vec, size, elem_count, ti);
            }
            mh$.invokeExact(allocator, vec, size, elem_count, ti);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_set_min_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_set_min_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_count(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static FunctionDescriptor ecs_vec_set_min_count$descriptor() {
        return ecs_vec_set_min_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_count(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MethodHandle ecs_vec_set_min_count$handle() {
        return ecs_vec_set_min_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_count(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MemorySegment ecs_vec_set_min_count$address() {
        return ecs_vec_set_min_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_set_min_count(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static void ecs_vec_set_min_count(MemorySegment allocator, MemorySegment vec, int size, int elem_count) {
        var mh$ = ecs_vec_set_min_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_set_min_count", allocator, vec, size, elem_count);
            }
            mh$.invokeExact(allocator, vec, size, elem_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_set_min_count_zeromem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_set_min_count_zeromem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_count_zeromem(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static FunctionDescriptor ecs_vec_set_min_count_zeromem$descriptor() {
        return ecs_vec_set_min_count_zeromem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_count_zeromem(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MethodHandle ecs_vec_set_min_count_zeromem$handle() {
        return ecs_vec_set_min_count_zeromem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_count_zeromem(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MemorySegment ecs_vec_set_min_count_zeromem$address() {
        return ecs_vec_set_min_count_zeromem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_set_min_count_zeromem(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static void ecs_vec_set_min_count_zeromem(MemorySegment allocator, MemorySegment vec, int size, int elem_count) {
        var mh$ = ecs_vec_set_min_count_zeromem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_set_min_count_zeromem", allocator, vec, size, elem_count);
            }
            mh$.invokeExact(allocator, vec, size, elem_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_set_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_set_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_set_count(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static FunctionDescriptor ecs_vec_set_count$descriptor() {
        return ecs_vec_set_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_set_count(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MethodHandle ecs_vec_set_count$handle() {
        return ecs_vec_set_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_set_count(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MemorySegment ecs_vec_set_count$address() {
        return ecs_vec_set_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_set_count(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static void ecs_vec_set_count(MemorySegment allocator, MemorySegment vec, int size, int elem_count) {
        var mh$ = ecs_vec_set_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_set_count", allocator, vec, size, elem_count);
            }
            mh$.invokeExact(allocator, vec, size, elem_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_set_count_w_type_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_set_count_w_type_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_set_count_w_type_info(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count, const ecs_type_info_t *ti)
     * }
     */
    public static FunctionDescriptor ecs_vec_set_count_w_type_info$descriptor() {
        return ecs_vec_set_count_w_type_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_set_count_w_type_info(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count, const ecs_type_info_t *ti)
     * }
     */
    public static MethodHandle ecs_vec_set_count_w_type_info$handle() {
        return ecs_vec_set_count_w_type_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_set_count_w_type_info(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count, const ecs_type_info_t *ti)
     * }
     */
    public static MemorySegment ecs_vec_set_count_w_type_info$address() {
        return ecs_vec_set_count_w_type_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_set_count_w_type_info(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count, const ecs_type_info_t *ti)
     * }
     */
    public static void ecs_vec_set_count_w_type_info(MemorySegment allocator, MemorySegment vec, int size, int elem_count, MemorySegment ti) {
        var mh$ = ecs_vec_set_count_w_type_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_set_count_w_type_info", allocator, vec, size, elem_count, ti);
            }
            mh$.invokeExact(allocator, vec, size, elem_count, ti);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_set_min_count_w_type_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_set_min_count_w_type_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_count_w_type_info(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count, const ecs_type_info_t *ti)
     * }
     */
    public static FunctionDescriptor ecs_vec_set_min_count_w_type_info$descriptor() {
        return ecs_vec_set_min_count_w_type_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_count_w_type_info(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count, const ecs_type_info_t *ti)
     * }
     */
    public static MethodHandle ecs_vec_set_min_count_w_type_info$handle() {
        return ecs_vec_set_min_count_w_type_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_count_w_type_info(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count, const ecs_type_info_t *ti)
     * }
     */
    public static MemorySegment ecs_vec_set_min_count_w_type_info$address() {
        return ecs_vec_set_min_count_w_type_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_set_min_count_w_type_info(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count, const ecs_type_info_t *ti)
     * }
     */
    public static void ecs_vec_set_min_count_w_type_info(MemorySegment allocator, MemorySegment vec, int size, int elem_count, MemorySegment ti) {
        var mh$ = ecs_vec_set_min_count_w_type_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_set_min_count_w_type_info", allocator, vec, size, elem_count, ti);
            }
            mh$.invokeExact(allocator, vec, size, elem_count, ti);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_grow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_grow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_vec_grow(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static FunctionDescriptor ecs_vec_grow$descriptor() {
        return ecs_vec_grow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_vec_grow(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MethodHandle ecs_vec_grow$handle() {
        return ecs_vec_grow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_vec_grow(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MemorySegment ecs_vec_grow$address() {
        return ecs_vec_grow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_vec_grow(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MemorySegment ecs_vec_grow(MemorySegment allocator, MemorySegment vec, int size, int elem_count) {
        var mh$ = ecs_vec_grow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_grow", allocator, vec, size, elem_count);
            }
            return (MemorySegment)mh$.invokeExact(allocator, vec, size, elem_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_vec_count(const ecs_vec_t *vec)
     * }
     */
    public static FunctionDescriptor ecs_vec_count$descriptor() {
        return ecs_vec_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_vec_count(const ecs_vec_t *vec)
     * }
     */
    public static MethodHandle ecs_vec_count$handle() {
        return ecs_vec_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_vec_count(const ecs_vec_t *vec)
     * }
     */
    public static MemorySegment ecs_vec_count$address() {
        return ecs_vec_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_vec_count(const ecs_vec_t *vec)
     * }
     */
    public static int ecs_vec_count(MemorySegment vec) {
        var mh$ = ecs_vec_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_count", vec);
            }
            return (int)mh$.invokeExact(vec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_vec_size(const ecs_vec_t *vec)
     * }
     */
    public static FunctionDescriptor ecs_vec_size$descriptor() {
        return ecs_vec_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_vec_size(const ecs_vec_t *vec)
     * }
     */
    public static MethodHandle ecs_vec_size$handle() {
        return ecs_vec_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_vec_size(const ecs_vec_t *vec)
     * }
     */
    public static MemorySegment ecs_vec_size$address() {
        return ecs_vec_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_vec_size(const ecs_vec_t *vec)
     * }
     */
    public static int ecs_vec_size(MemorySegment vec) {
        var mh$ = ecs_vec_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_size", vec);
            }
            return (int)mh$.invokeExact(vec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_vec_get(const ecs_vec_t *vec, ecs_size_t size, int32_t index)
     * }
     */
    public static FunctionDescriptor ecs_vec_get$descriptor() {
        return ecs_vec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_vec_get(const ecs_vec_t *vec, ecs_size_t size, int32_t index)
     * }
     */
    public static MethodHandle ecs_vec_get$handle() {
        return ecs_vec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_vec_get(const ecs_vec_t *vec, ecs_size_t size, int32_t index)
     * }
     */
    public static MemorySegment ecs_vec_get$address() {
        return ecs_vec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_vec_get(const ecs_vec_t *vec, ecs_size_t size, int32_t index)
     * }
     */
    public static MemorySegment ecs_vec_get(MemorySegment vec, int size, int index) {
        var mh$ = ecs_vec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_get", vec, size, index);
            }
            return (MemorySegment)mh$.invokeExact(vec, size, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_first {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_first");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_vec_first(const ecs_vec_t *vec)
     * }
     */
    public static FunctionDescriptor ecs_vec_first$descriptor() {
        return ecs_vec_first.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_vec_first(const ecs_vec_t *vec)
     * }
     */
    public static MethodHandle ecs_vec_first$handle() {
        return ecs_vec_first.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_vec_first(const ecs_vec_t *vec)
     * }
     */
    public static MemorySegment ecs_vec_first$address() {
        return ecs_vec_first.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_vec_first(const ecs_vec_t *vec)
     * }
     */
    public static MemorySegment ecs_vec_first(MemorySegment vec) {
        var mh$ = ecs_vec_first.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_first", vec);
            }
            return (MemorySegment)mh$.invokeExact(vec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_vec_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_vec_last(const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_vec_last$descriptor() {
        return ecs_vec_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_vec_last(const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_vec_last$handle() {
        return ecs_vec_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_vec_last(const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_last$address() {
        return ecs_vec_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_vec_last(const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_last(MemorySegment vec, int size) {
        var mh$ = ecs_vec_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_last", vec, size);
            }
            return (MemorySegment)mh$.invokeExact(vec, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_sparse_init(ecs_sparse_t *result, struct ecs_allocator_t *allocator, struct ecs_block_allocator_t *page_allocator, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor flecs_sparse_init$descriptor() {
        return flecs_sparse_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_sparse_init(ecs_sparse_t *result, struct ecs_allocator_t *allocator, struct ecs_block_allocator_t *page_allocator, ecs_size_t size)
     * }
     */
    public static MethodHandle flecs_sparse_init$handle() {
        return flecs_sparse_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_sparse_init(ecs_sparse_t *result, struct ecs_allocator_t *allocator, struct ecs_block_allocator_t *page_allocator, ecs_size_t size)
     * }
     */
    public static MemorySegment flecs_sparse_init$address() {
        return flecs_sparse_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_sparse_init(ecs_sparse_t *result, struct ecs_allocator_t *allocator, struct ecs_block_allocator_t *page_allocator, ecs_size_t size)
     * }
     */
    public static void flecs_sparse_init(MemorySegment result, MemorySegment allocator, MemorySegment page_allocator, int size) {
        var mh$ = flecs_sparse_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_init", result, allocator, page_allocator, size);
            }
            mh$.invokeExact(result, allocator, page_allocator, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_sparse_fini(ecs_sparse_t *sparse)
     * }
     */
    public static FunctionDescriptor flecs_sparse_fini$descriptor() {
        return flecs_sparse_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_sparse_fini(ecs_sparse_t *sparse)
     * }
     */
    public static MethodHandle flecs_sparse_fini$handle() {
        return flecs_sparse_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_sparse_fini(ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment flecs_sparse_fini$address() {
        return flecs_sparse_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_sparse_fini(ecs_sparse_t *sparse)
     * }
     */
    public static void flecs_sparse_fini(MemorySegment sparse) {
        var mh$ = flecs_sparse_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_fini", sparse);
            }
            mh$.invokeExact(sparse);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_sparse_clear(ecs_sparse_t *sparse)
     * }
     */
    public static FunctionDescriptor flecs_sparse_clear$descriptor() {
        return flecs_sparse_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_sparse_clear(ecs_sparse_t *sparse)
     * }
     */
    public static MethodHandle flecs_sparse_clear$handle() {
        return flecs_sparse_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_sparse_clear(ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment flecs_sparse_clear$address() {
        return flecs_sparse_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_sparse_clear(ecs_sparse_t *sparse)
     * }
     */
    public static void flecs_sparse_clear(MemorySegment sparse) {
        var mh$ = flecs_sparse_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_clear", sparse);
            }
            mh$.invokeExact(sparse);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_sparse_add(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static FunctionDescriptor flecs_sparse_add$descriptor() {
        return flecs_sparse_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_sparse_add(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static MethodHandle flecs_sparse_add$handle() {
        return flecs_sparse_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_sparse_add(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static MemorySegment flecs_sparse_add$address() {
        return flecs_sparse_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_sparse_add(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static MemorySegment flecs_sparse_add(MemorySegment sparse, int elem_size) {
        var mh$ = flecs_sparse_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_add", sparse, elem_size);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_last_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_last_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t flecs_sparse_last_id(const ecs_sparse_t *sparse)
     * }
     */
    public static FunctionDescriptor flecs_sparse_last_id$descriptor() {
        return flecs_sparse_last_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t flecs_sparse_last_id(const ecs_sparse_t *sparse)
     * }
     */
    public static MethodHandle flecs_sparse_last_id$handle() {
        return flecs_sparse_last_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t flecs_sparse_last_id(const ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment flecs_sparse_last_id$address() {
        return flecs_sparse_last_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t flecs_sparse_last_id(const ecs_sparse_t *sparse)
     * }
     */
    public static long flecs_sparse_last_id(MemorySegment sparse) {
        var mh$ = flecs_sparse_last_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_last_id", sparse);
            }
            return (long)mh$.invokeExact(sparse);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_new_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_new_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t flecs_sparse_new_id(ecs_sparse_t *sparse)
     * }
     */
    public static FunctionDescriptor flecs_sparse_new_id$descriptor() {
        return flecs_sparse_new_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t flecs_sparse_new_id(ecs_sparse_t *sparse)
     * }
     */
    public static MethodHandle flecs_sparse_new_id$handle() {
        return flecs_sparse_new_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t flecs_sparse_new_id(ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment flecs_sparse_new_id$address() {
        return flecs_sparse_new_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t flecs_sparse_new_id(ecs_sparse_t *sparse)
     * }
     */
    public static long flecs_sparse_new_id(MemorySegment sparse) {
        var mh$ = flecs_sparse_new_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_new_id", sparse);
            }
            return (long)mh$.invokeExact(sparse);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool flecs_sparse_remove(ecs_sparse_t *sparse, ecs_size_t size, uint64_t id)
     * }
     */
    public static FunctionDescriptor flecs_sparse_remove$descriptor() {
        return flecs_sparse_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool flecs_sparse_remove(ecs_sparse_t *sparse, ecs_size_t size, uint64_t id)
     * }
     */
    public static MethodHandle flecs_sparse_remove$handle() {
        return flecs_sparse_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool flecs_sparse_remove(ecs_sparse_t *sparse, ecs_size_t size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_remove$address() {
        return flecs_sparse_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool flecs_sparse_remove(ecs_sparse_t *sparse, ecs_size_t size, uint64_t id)
     * }
     */
    public static boolean flecs_sparse_remove(MemorySegment sparse, int size, long id) {
        var mh$ = flecs_sparse_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_remove", sparse, size, id);
            }
            return (boolean)mh$.invokeExact(sparse, size, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_remove_w_gen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_remove_w_gen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool flecs_sparse_remove_w_gen(ecs_sparse_t *sparse, ecs_size_t size, uint64_t id)
     * }
     */
    public static FunctionDescriptor flecs_sparse_remove_w_gen$descriptor() {
        return flecs_sparse_remove_w_gen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool flecs_sparse_remove_w_gen(ecs_sparse_t *sparse, ecs_size_t size, uint64_t id)
     * }
     */
    public static MethodHandle flecs_sparse_remove_w_gen$handle() {
        return flecs_sparse_remove_w_gen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool flecs_sparse_remove_w_gen(ecs_sparse_t *sparse, ecs_size_t size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_remove_w_gen$address() {
        return flecs_sparse_remove_w_gen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool flecs_sparse_remove_w_gen(ecs_sparse_t *sparse, ecs_size_t size, uint64_t id)
     * }
     */
    public static boolean flecs_sparse_remove_w_gen(MemorySegment sparse, int size, long id) {
        var mh$ = flecs_sparse_remove_w_gen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_remove_w_gen", sparse, size, id);
            }
            return (boolean)mh$.invokeExact(sparse, size, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_is_alive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_is_alive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool flecs_sparse_is_alive(const ecs_sparse_t *sparse, uint64_t id)
     * }
     */
    public static FunctionDescriptor flecs_sparse_is_alive$descriptor() {
        return flecs_sparse_is_alive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool flecs_sparse_is_alive(const ecs_sparse_t *sparse, uint64_t id)
     * }
     */
    public static MethodHandle flecs_sparse_is_alive$handle() {
        return flecs_sparse_is_alive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool flecs_sparse_is_alive(const ecs_sparse_t *sparse, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_is_alive$address() {
        return flecs_sparse_is_alive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool flecs_sparse_is_alive(const ecs_sparse_t *sparse, uint64_t id)
     * }
     */
    public static boolean flecs_sparse_is_alive(MemorySegment sparse, long id) {
        var mh$ = flecs_sparse_is_alive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_is_alive", sparse, id);
            }
            return (boolean)mh$.invokeExact(sparse, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_get_dense {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_get_dense");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_sparse_get_dense(const ecs_sparse_t *sparse, ecs_size_t elem_size, int32_t index)
     * }
     */
    public static FunctionDescriptor flecs_sparse_get_dense$descriptor() {
        return flecs_sparse_get_dense.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_sparse_get_dense(const ecs_sparse_t *sparse, ecs_size_t elem_size, int32_t index)
     * }
     */
    public static MethodHandle flecs_sparse_get_dense$handle() {
        return flecs_sparse_get_dense.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_sparse_get_dense(const ecs_sparse_t *sparse, ecs_size_t elem_size, int32_t index)
     * }
     */
    public static MemorySegment flecs_sparse_get_dense$address() {
        return flecs_sparse_get_dense.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_sparse_get_dense(const ecs_sparse_t *sparse, ecs_size_t elem_size, int32_t index)
     * }
     */
    public static MemorySegment flecs_sparse_get_dense(MemorySegment sparse, int elem_size, int index) {
        var mh$ = flecs_sparse_get_dense.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_get_dense", sparse, elem_size, index);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t flecs_sparse_count(const ecs_sparse_t *sparse)
     * }
     */
    public static FunctionDescriptor flecs_sparse_count$descriptor() {
        return flecs_sparse_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t flecs_sparse_count(const ecs_sparse_t *sparse)
     * }
     */
    public static MethodHandle flecs_sparse_count$handle() {
        return flecs_sparse_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t flecs_sparse_count(const ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment flecs_sparse_count$address() {
        return flecs_sparse_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t flecs_sparse_count(const ecs_sparse_t *sparse)
     * }
     */
    public static int flecs_sparse_count(MemorySegment sparse) {
        var mh$ = flecs_sparse_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_count", sparse);
            }
            return (int)mh$.invokeExact(sparse);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_has {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_has");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool flecs_sparse_has(const ecs_sparse_t *sparse, uint64_t id)
     * }
     */
    public static FunctionDescriptor flecs_sparse_has$descriptor() {
        return flecs_sparse_has.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool flecs_sparse_has(const ecs_sparse_t *sparse, uint64_t id)
     * }
     */
    public static MethodHandle flecs_sparse_has$handle() {
        return flecs_sparse_has.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool flecs_sparse_has(const ecs_sparse_t *sparse, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_has$address() {
        return flecs_sparse_has.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool flecs_sparse_has(const ecs_sparse_t *sparse, uint64_t id)
     * }
     */
    public static boolean flecs_sparse_has(MemorySegment sparse, long id) {
        var mh$ = flecs_sparse_has.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_has", sparse, id);
            }
            return (boolean)mh$.invokeExact(sparse, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_sparse_get(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static FunctionDescriptor flecs_sparse_get$descriptor() {
        return flecs_sparse_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_sparse_get(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MethodHandle flecs_sparse_get$handle() {
        return flecs_sparse_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_sparse_get(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_get$address() {
        return flecs_sparse_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_sparse_get(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_get(MemorySegment sparse, int elem_size, long id) {
        var mh$ = flecs_sparse_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_get", sparse, elem_size, id);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_sparse_insert(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static FunctionDescriptor flecs_sparse_insert$descriptor() {
        return flecs_sparse_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_sparse_insert(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MethodHandle flecs_sparse_insert$handle() {
        return flecs_sparse_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_sparse_insert(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_insert$address() {
        return flecs_sparse_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_sparse_insert(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_insert(MemorySegment sparse, int elem_size, long id) {
        var mh$ = flecs_sparse_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_insert", sparse, elem_size, id);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_ensure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_ensure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_sparse_ensure(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id, _Bool *is_new)
     * }
     */
    public static FunctionDescriptor flecs_sparse_ensure$descriptor() {
        return flecs_sparse_ensure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_sparse_ensure(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id, _Bool *is_new)
     * }
     */
    public static MethodHandle flecs_sparse_ensure$handle() {
        return flecs_sparse_ensure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_sparse_ensure(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id, _Bool *is_new)
     * }
     */
    public static MemorySegment flecs_sparse_ensure$address() {
        return flecs_sparse_ensure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_sparse_ensure(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id, _Bool *is_new)
     * }
     */
    public static MemorySegment flecs_sparse_ensure(MemorySegment sparse, int elem_size, long id, MemorySegment is_new) {
        var mh$ = flecs_sparse_ensure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_ensure", sparse, elem_size, id, is_new);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size, id, is_new);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_ensure_fast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_ensure_fast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_sparse_ensure_fast(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static FunctionDescriptor flecs_sparse_ensure_fast$descriptor() {
        return flecs_sparse_ensure_fast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_sparse_ensure_fast(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MethodHandle flecs_sparse_ensure_fast$handle() {
        return flecs_sparse_ensure_fast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_sparse_ensure_fast(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_ensure_fast$address() {
        return flecs_sparse_ensure_fast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_sparse_ensure_fast(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_ensure_fast(MemorySegment sparse, int elem_size, long id) {
        var mh$ = flecs_sparse_ensure_fast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_ensure_fast", sparse, elem_size, id);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_ids {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_ids");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const uint64_t *flecs_sparse_ids(const ecs_sparse_t *sparse)
     * }
     */
    public static FunctionDescriptor flecs_sparse_ids$descriptor() {
        return flecs_sparse_ids.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const uint64_t *flecs_sparse_ids(const ecs_sparse_t *sparse)
     * }
     */
    public static MethodHandle flecs_sparse_ids$handle() {
        return flecs_sparse_ids.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const uint64_t *flecs_sparse_ids(const ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment flecs_sparse_ids$address() {
        return flecs_sparse_ids.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const uint64_t *flecs_sparse_ids(const ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment flecs_sparse_ids(MemorySegment sparse) {
        var mh$ = flecs_sparse_ids.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_ids", sparse);
            }
            return (MemorySegment)mh$.invokeExact(sparse);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_shrink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_sparse_shrink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_sparse_shrink(ecs_sparse_t *sparse)
     * }
     */
    public static FunctionDescriptor flecs_sparse_shrink$descriptor() {
        return flecs_sparse_shrink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_sparse_shrink(ecs_sparse_t *sparse)
     * }
     */
    public static MethodHandle flecs_sparse_shrink$handle() {
        return flecs_sparse_shrink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_sparse_shrink(ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment flecs_sparse_shrink$address() {
        return flecs_sparse_shrink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_sparse_shrink(ecs_sparse_t *sparse)
     * }
     */
    public static void flecs_sparse_shrink(MemorySegment sparse) {
        var mh$ = flecs_sparse_shrink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_shrink", sparse);
            }
            mh$.invokeExact(sparse);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_sparse_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_sparse_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_sparse_init(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static FunctionDescriptor ecs_sparse_init$descriptor() {
        return ecs_sparse_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_sparse_init(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static MethodHandle ecs_sparse_init$handle() {
        return ecs_sparse_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_sparse_init(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static MemorySegment ecs_sparse_init$address() {
        return ecs_sparse_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_sparse_init(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static void ecs_sparse_init(MemorySegment sparse, int elem_size) {
        var mh$ = ecs_sparse_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_sparse_init", sparse, elem_size);
            }
            mh$.invokeExact(sparse, elem_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_sparse_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_sparse_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_sparse_add(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static FunctionDescriptor ecs_sparse_add$descriptor() {
        return ecs_sparse_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_sparse_add(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static MethodHandle ecs_sparse_add$handle() {
        return ecs_sparse_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_sparse_add(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static MemorySegment ecs_sparse_add$address() {
        return ecs_sparse_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_sparse_add(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static MemorySegment ecs_sparse_add(MemorySegment sparse, int elem_size) {
        var mh$ = ecs_sparse_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_sparse_add", sparse, elem_size);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_sparse_last_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_sparse_last_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t ecs_sparse_last_id(const ecs_sparse_t *sparse)
     * }
     */
    public static FunctionDescriptor ecs_sparse_last_id$descriptor() {
        return ecs_sparse_last_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t ecs_sparse_last_id(const ecs_sparse_t *sparse)
     * }
     */
    public static MethodHandle ecs_sparse_last_id$handle() {
        return ecs_sparse_last_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t ecs_sparse_last_id(const ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment ecs_sparse_last_id$address() {
        return ecs_sparse_last_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t ecs_sparse_last_id(const ecs_sparse_t *sparse)
     * }
     */
    public static long ecs_sparse_last_id(MemorySegment sparse) {
        var mh$ = ecs_sparse_last_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_sparse_last_id", sparse);
            }
            return (long)mh$.invokeExact(sparse);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_sparse_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_sparse_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_sparse_count(const ecs_sparse_t *sparse)
     * }
     */
    public static FunctionDescriptor ecs_sparse_count$descriptor() {
        return ecs_sparse_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_sparse_count(const ecs_sparse_t *sparse)
     * }
     */
    public static MethodHandle ecs_sparse_count$handle() {
        return ecs_sparse_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_sparse_count(const ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment ecs_sparse_count$address() {
        return ecs_sparse_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_sparse_count(const ecs_sparse_t *sparse)
     * }
     */
    public static int ecs_sparse_count(MemorySegment sparse) {
        var mh$ = ecs_sparse_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_sparse_count", sparse);
            }
            return (int)mh$.invokeExact(sparse);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_sparse_get_dense {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_sparse_get_dense");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_sparse_get_dense(const ecs_sparse_t *sparse, ecs_size_t elem_size, int32_t index)
     * }
     */
    public static FunctionDescriptor ecs_sparse_get_dense$descriptor() {
        return ecs_sparse_get_dense.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_sparse_get_dense(const ecs_sparse_t *sparse, ecs_size_t elem_size, int32_t index)
     * }
     */
    public static MethodHandle ecs_sparse_get_dense$handle() {
        return ecs_sparse_get_dense.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_sparse_get_dense(const ecs_sparse_t *sparse, ecs_size_t elem_size, int32_t index)
     * }
     */
    public static MemorySegment ecs_sparse_get_dense$address() {
        return ecs_sparse_get_dense.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_sparse_get_dense(const ecs_sparse_t *sparse, ecs_size_t elem_size, int32_t index)
     * }
     */
    public static MemorySegment ecs_sparse_get_dense(MemorySegment sparse, int elem_size, int index) {
        var mh$ = ecs_sparse_get_dense.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_sparse_get_dense", sparse, elem_size, index);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_sparse_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_sparse_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_sparse_get(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static FunctionDescriptor ecs_sparse_get$descriptor() {
        return ecs_sparse_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_sparse_get(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MethodHandle ecs_sparse_get$handle() {
        return ecs_sparse_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_sparse_get(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment ecs_sparse_get$address() {
        return ecs_sparse_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_sparse_get(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment ecs_sparse_get(MemorySegment sparse, int elem_size, long id) {
        var mh$ = ecs_sparse_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_sparse_get", sparse, elem_size, id);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_ballocator_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_ballocator_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_ballocator_init(ecs_block_allocator_t *ba, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor flecs_ballocator_init$descriptor() {
        return flecs_ballocator_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_ballocator_init(ecs_block_allocator_t *ba, ecs_size_t size)
     * }
     */
    public static MethodHandle flecs_ballocator_init$handle() {
        return flecs_ballocator_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_ballocator_init(ecs_block_allocator_t *ba, ecs_size_t size)
     * }
     */
    public static MemorySegment flecs_ballocator_init$address() {
        return flecs_ballocator_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_ballocator_init(ecs_block_allocator_t *ba, ecs_size_t size)
     * }
     */
    public static void flecs_ballocator_init(MemorySegment ba, int size) {
        var mh$ = flecs_ballocator_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_ballocator_init", ba, size);
            }
            mh$.invokeExact(ba, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_ballocator_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_ballocator_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_block_allocator_t *flecs_ballocator_new(ecs_size_t size)
     * }
     */
    public static FunctionDescriptor flecs_ballocator_new$descriptor() {
        return flecs_ballocator_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_block_allocator_t *flecs_ballocator_new(ecs_size_t size)
     * }
     */
    public static MethodHandle flecs_ballocator_new$handle() {
        return flecs_ballocator_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_block_allocator_t *flecs_ballocator_new(ecs_size_t size)
     * }
     */
    public static MemorySegment flecs_ballocator_new$address() {
        return flecs_ballocator_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_block_allocator_t *flecs_ballocator_new(ecs_size_t size)
     * }
     */
    public static MemorySegment flecs_ballocator_new(int size) {
        var mh$ = flecs_ballocator_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_ballocator_new", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_ballocator_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_ballocator_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_ballocator_fini(ecs_block_allocator_t *ba)
     * }
     */
    public static FunctionDescriptor flecs_ballocator_fini$descriptor() {
        return flecs_ballocator_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_ballocator_fini(ecs_block_allocator_t *ba)
     * }
     */
    public static MethodHandle flecs_ballocator_fini$handle() {
        return flecs_ballocator_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_ballocator_fini(ecs_block_allocator_t *ba)
     * }
     */
    public static MemorySegment flecs_ballocator_fini$address() {
        return flecs_ballocator_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_ballocator_fini(ecs_block_allocator_t *ba)
     * }
     */
    public static void flecs_ballocator_fini(MemorySegment ba) {
        var mh$ = flecs_ballocator_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_ballocator_fini", ba);
            }
            mh$.invokeExact(ba);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_ballocator_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_ballocator_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_ballocator_free(ecs_block_allocator_t *ba)
     * }
     */
    public static FunctionDescriptor flecs_ballocator_free$descriptor() {
        return flecs_ballocator_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_ballocator_free(ecs_block_allocator_t *ba)
     * }
     */
    public static MethodHandle flecs_ballocator_free$handle() {
        return flecs_ballocator_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_ballocator_free(ecs_block_allocator_t *ba)
     * }
     */
    public static MemorySegment flecs_ballocator_free$address() {
        return flecs_ballocator_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_ballocator_free(ecs_block_allocator_t *ba)
     * }
     */
    public static void flecs_ballocator_free(MemorySegment ba) {
        var mh$ = flecs_ballocator_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_ballocator_free", ba);
            }
            mh$.invokeExact(ba);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_balloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_balloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_balloc(ecs_block_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor flecs_balloc$descriptor() {
        return flecs_balloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_balloc(ecs_block_allocator_t *allocator)
     * }
     */
    public static MethodHandle flecs_balloc$handle() {
        return flecs_balloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_balloc(ecs_block_allocator_t *allocator)
     * }
     */
    public static MemorySegment flecs_balloc$address() {
        return flecs_balloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_balloc(ecs_block_allocator_t *allocator)
     * }
     */
    public static MemorySegment flecs_balloc(MemorySegment allocator) {
        var mh$ = flecs_balloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_balloc", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_balloc_w_dbg_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_balloc_w_dbg_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_balloc_w_dbg_info(ecs_block_allocator_t *allocator, const char *type_name)
     * }
     */
    public static FunctionDescriptor flecs_balloc_w_dbg_info$descriptor() {
        return flecs_balloc_w_dbg_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_balloc_w_dbg_info(ecs_block_allocator_t *allocator, const char *type_name)
     * }
     */
    public static MethodHandle flecs_balloc_w_dbg_info$handle() {
        return flecs_balloc_w_dbg_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_balloc_w_dbg_info(ecs_block_allocator_t *allocator, const char *type_name)
     * }
     */
    public static MemorySegment flecs_balloc_w_dbg_info$address() {
        return flecs_balloc_w_dbg_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_balloc_w_dbg_info(ecs_block_allocator_t *allocator, const char *type_name)
     * }
     */
    public static MemorySegment flecs_balloc_w_dbg_info(MemorySegment allocator, MemorySegment type_name) {
        var mh$ = flecs_balloc_w_dbg_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_balloc_w_dbg_info", allocator, type_name);
            }
            return (MemorySegment)mh$.invokeExact(allocator, type_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_bcalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_bcalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_bcalloc(ecs_block_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor flecs_bcalloc$descriptor() {
        return flecs_bcalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_bcalloc(ecs_block_allocator_t *allocator)
     * }
     */
    public static MethodHandle flecs_bcalloc$handle() {
        return flecs_bcalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_bcalloc(ecs_block_allocator_t *allocator)
     * }
     */
    public static MemorySegment flecs_bcalloc$address() {
        return flecs_bcalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_bcalloc(ecs_block_allocator_t *allocator)
     * }
     */
    public static MemorySegment flecs_bcalloc(MemorySegment allocator) {
        var mh$ = flecs_bcalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_bcalloc", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_bcalloc_w_dbg_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_bcalloc_w_dbg_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_bcalloc_w_dbg_info(ecs_block_allocator_t *allocator, const char *type_name)
     * }
     */
    public static FunctionDescriptor flecs_bcalloc_w_dbg_info$descriptor() {
        return flecs_bcalloc_w_dbg_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_bcalloc_w_dbg_info(ecs_block_allocator_t *allocator, const char *type_name)
     * }
     */
    public static MethodHandle flecs_bcalloc_w_dbg_info$handle() {
        return flecs_bcalloc_w_dbg_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_bcalloc_w_dbg_info(ecs_block_allocator_t *allocator, const char *type_name)
     * }
     */
    public static MemorySegment flecs_bcalloc_w_dbg_info$address() {
        return flecs_bcalloc_w_dbg_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_bcalloc_w_dbg_info(ecs_block_allocator_t *allocator, const char *type_name)
     * }
     */
    public static MemorySegment flecs_bcalloc_w_dbg_info(MemorySegment allocator, MemorySegment type_name) {
        var mh$ = flecs_bcalloc_w_dbg_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_bcalloc_w_dbg_info", allocator, type_name);
            }
            return (MemorySegment)mh$.invokeExact(allocator, type_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_bfree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_bfree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_bfree(ecs_block_allocator_t *allocator, void *memory)
     * }
     */
    public static FunctionDescriptor flecs_bfree$descriptor() {
        return flecs_bfree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_bfree(ecs_block_allocator_t *allocator, void *memory)
     * }
     */
    public static MethodHandle flecs_bfree$handle() {
        return flecs_bfree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_bfree(ecs_block_allocator_t *allocator, void *memory)
     * }
     */
    public static MemorySegment flecs_bfree$address() {
        return flecs_bfree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_bfree(ecs_block_allocator_t *allocator, void *memory)
     * }
     */
    public static void flecs_bfree(MemorySegment allocator, MemorySegment memory) {
        var mh$ = flecs_bfree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_bfree", allocator, memory);
            }
            mh$.invokeExact(allocator, memory);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_bfree_w_dbg_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_bfree_w_dbg_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_bfree_w_dbg_info(ecs_block_allocator_t *allocator, void *memory, const char *type_name)
     * }
     */
    public static FunctionDescriptor flecs_bfree_w_dbg_info$descriptor() {
        return flecs_bfree_w_dbg_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_bfree_w_dbg_info(ecs_block_allocator_t *allocator, void *memory, const char *type_name)
     * }
     */
    public static MethodHandle flecs_bfree_w_dbg_info$handle() {
        return flecs_bfree_w_dbg_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_bfree_w_dbg_info(ecs_block_allocator_t *allocator, void *memory, const char *type_name)
     * }
     */
    public static MemorySegment flecs_bfree_w_dbg_info$address() {
        return flecs_bfree_w_dbg_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_bfree_w_dbg_info(ecs_block_allocator_t *allocator, void *memory, const char *type_name)
     * }
     */
    public static void flecs_bfree_w_dbg_info(MemorySegment allocator, MemorySegment memory, MemorySegment type_name) {
        var mh$ = flecs_bfree_w_dbg_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_bfree_w_dbg_info", allocator, memory, type_name);
            }
            mh$.invokeExact(allocator, memory, type_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_brealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_brealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_brealloc(ecs_block_allocator_t *dst, ecs_block_allocator_t *src, void *memory)
     * }
     */
    public static FunctionDescriptor flecs_brealloc$descriptor() {
        return flecs_brealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_brealloc(ecs_block_allocator_t *dst, ecs_block_allocator_t *src, void *memory)
     * }
     */
    public static MethodHandle flecs_brealloc$handle() {
        return flecs_brealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_brealloc(ecs_block_allocator_t *dst, ecs_block_allocator_t *src, void *memory)
     * }
     */
    public static MemorySegment flecs_brealloc$address() {
        return flecs_brealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_brealloc(ecs_block_allocator_t *dst, ecs_block_allocator_t *src, void *memory)
     * }
     */
    public static MemorySegment flecs_brealloc(MemorySegment dst, MemorySegment src, MemorySegment memory) {
        var mh$ = flecs_brealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_brealloc", dst, src, memory);
            }
            return (MemorySegment)mh$.invokeExact(dst, src, memory);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_brealloc_w_dbg_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_brealloc_w_dbg_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_brealloc_w_dbg_info(ecs_block_allocator_t *dst, ecs_block_allocator_t *src, void *memory, const char *type_name)
     * }
     */
    public static FunctionDescriptor flecs_brealloc_w_dbg_info$descriptor() {
        return flecs_brealloc_w_dbg_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_brealloc_w_dbg_info(ecs_block_allocator_t *dst, ecs_block_allocator_t *src, void *memory, const char *type_name)
     * }
     */
    public static MethodHandle flecs_brealloc_w_dbg_info$handle() {
        return flecs_brealloc_w_dbg_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_brealloc_w_dbg_info(ecs_block_allocator_t *dst, ecs_block_allocator_t *src, void *memory, const char *type_name)
     * }
     */
    public static MemorySegment flecs_brealloc_w_dbg_info$address() {
        return flecs_brealloc_w_dbg_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_brealloc_w_dbg_info(ecs_block_allocator_t *dst, ecs_block_allocator_t *src, void *memory, const char *type_name)
     * }
     */
    public static MemorySegment flecs_brealloc_w_dbg_info(MemorySegment dst, MemorySegment src, MemorySegment memory, MemorySegment type_name) {
        var mh$ = flecs_brealloc_w_dbg_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_brealloc_w_dbg_info", dst, src, memory, type_name);
            }
            return (MemorySegment)mh$.invokeExact(dst, src, memory, type_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_bdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_bdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_bdup(ecs_block_allocator_t *ba, void *memory)
     * }
     */
    public static FunctionDescriptor flecs_bdup$descriptor() {
        return flecs_bdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_bdup(ecs_block_allocator_t *ba, void *memory)
     * }
     */
    public static MethodHandle flecs_bdup$handle() {
        return flecs_bdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_bdup(ecs_block_allocator_t *ba, void *memory)
     * }
     */
    public static MemorySegment flecs_bdup$address() {
        return flecs_bdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_bdup(ecs_block_allocator_t *ba, void *memory)
     * }
     */
    public static MemorySegment flecs_bdup(MemorySegment ba, MemorySegment memory) {
        var mh$ = flecs_bdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_bdup", ba, memory);
            }
            return (MemorySegment)mh$.invokeExact(ba, memory);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stack_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_stack_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_stack_init(ecs_stack_t *stack)
     * }
     */
    public static FunctionDescriptor flecs_stack_init$descriptor() {
        return flecs_stack_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_stack_init(ecs_stack_t *stack)
     * }
     */
    public static MethodHandle flecs_stack_init$handle() {
        return flecs_stack_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_stack_init(ecs_stack_t *stack)
     * }
     */
    public static MemorySegment flecs_stack_init$address() {
        return flecs_stack_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_stack_init(ecs_stack_t *stack)
     * }
     */
    public static void flecs_stack_init(MemorySegment stack) {
        var mh$ = flecs_stack_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stack_init", stack);
            }
            mh$.invokeExact(stack);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stack_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_stack_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_stack_fini(ecs_stack_t *stack)
     * }
     */
    public static FunctionDescriptor flecs_stack_fini$descriptor() {
        return flecs_stack_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_stack_fini(ecs_stack_t *stack)
     * }
     */
    public static MethodHandle flecs_stack_fini$handle() {
        return flecs_stack_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_stack_fini(ecs_stack_t *stack)
     * }
     */
    public static MemorySegment flecs_stack_fini$address() {
        return flecs_stack_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_stack_fini(ecs_stack_t *stack)
     * }
     */
    public static void flecs_stack_fini(MemorySegment stack) {
        var mh$ = flecs_stack_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stack_fini", stack);
            }
            mh$.invokeExact(stack);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stack_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_stack_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_stack_alloc(ecs_stack_t *stack, ecs_size_t size, ecs_size_t align)
     * }
     */
    public static FunctionDescriptor flecs_stack_alloc$descriptor() {
        return flecs_stack_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_stack_alloc(ecs_stack_t *stack, ecs_size_t size, ecs_size_t align)
     * }
     */
    public static MethodHandle flecs_stack_alloc$handle() {
        return flecs_stack_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_stack_alloc(ecs_stack_t *stack, ecs_size_t size, ecs_size_t align)
     * }
     */
    public static MemorySegment flecs_stack_alloc$address() {
        return flecs_stack_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_stack_alloc(ecs_stack_t *stack, ecs_size_t size, ecs_size_t align)
     * }
     */
    public static MemorySegment flecs_stack_alloc(MemorySegment stack, int size, int align) {
        var mh$ = flecs_stack_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stack_alloc", stack, size, align);
            }
            return (MemorySegment)mh$.invokeExact(stack, size, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stack_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_stack_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_stack_calloc(ecs_stack_t *stack, ecs_size_t size, ecs_size_t align)
     * }
     */
    public static FunctionDescriptor flecs_stack_calloc$descriptor() {
        return flecs_stack_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_stack_calloc(ecs_stack_t *stack, ecs_size_t size, ecs_size_t align)
     * }
     */
    public static MethodHandle flecs_stack_calloc$handle() {
        return flecs_stack_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_stack_calloc(ecs_stack_t *stack, ecs_size_t size, ecs_size_t align)
     * }
     */
    public static MemorySegment flecs_stack_calloc$address() {
        return flecs_stack_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_stack_calloc(ecs_stack_t *stack, ecs_size_t size, ecs_size_t align)
     * }
     */
    public static MemorySegment flecs_stack_calloc(MemorySegment stack, int size, int align) {
        var mh$ = flecs_stack_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stack_calloc", stack, size, align);
            }
            return (MemorySegment)mh$.invokeExact(stack, size, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stack_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_stack_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_stack_free(void *ptr, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor flecs_stack_free$descriptor() {
        return flecs_stack_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_stack_free(void *ptr, ecs_size_t size)
     * }
     */
    public static MethodHandle flecs_stack_free$handle() {
        return flecs_stack_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_stack_free(void *ptr, ecs_size_t size)
     * }
     */
    public static MemorySegment flecs_stack_free$address() {
        return flecs_stack_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_stack_free(void *ptr, ecs_size_t size)
     * }
     */
    public static void flecs_stack_free(MemorySegment ptr, int size) {
        var mh$ = flecs_stack_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stack_free", ptr, size);
            }
            mh$.invokeExact(ptr, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stack_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_stack_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_stack_reset(ecs_stack_t *stack)
     * }
     */
    public static FunctionDescriptor flecs_stack_reset$descriptor() {
        return flecs_stack_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_stack_reset(ecs_stack_t *stack)
     * }
     */
    public static MethodHandle flecs_stack_reset$handle() {
        return flecs_stack_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_stack_reset(ecs_stack_t *stack)
     * }
     */
    public static MemorySegment flecs_stack_reset$address() {
        return flecs_stack_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_stack_reset(ecs_stack_t *stack)
     * }
     */
    public static void flecs_stack_reset(MemorySegment stack) {
        var mh$ = flecs_stack_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stack_reset", stack);
            }
            mh$.invokeExact(stack);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stack_get_cursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_stack_get_cursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_stack_cursor_t *flecs_stack_get_cursor(ecs_stack_t *stack)
     * }
     */
    public static FunctionDescriptor flecs_stack_get_cursor$descriptor() {
        return flecs_stack_get_cursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_stack_cursor_t *flecs_stack_get_cursor(ecs_stack_t *stack)
     * }
     */
    public static MethodHandle flecs_stack_get_cursor$handle() {
        return flecs_stack_get_cursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_stack_cursor_t *flecs_stack_get_cursor(ecs_stack_t *stack)
     * }
     */
    public static MemorySegment flecs_stack_get_cursor$address() {
        return flecs_stack_get_cursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_stack_cursor_t *flecs_stack_get_cursor(ecs_stack_t *stack)
     * }
     */
    public static MemorySegment flecs_stack_get_cursor(MemorySegment stack) {
        var mh$ = flecs_stack_get_cursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stack_get_cursor", stack);
            }
            return (MemorySegment)mh$.invokeExact(stack);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stack_restore_cursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_stack_restore_cursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_stack_restore_cursor(ecs_stack_t *stack, ecs_stack_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor flecs_stack_restore_cursor$descriptor() {
        return flecs_stack_restore_cursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_stack_restore_cursor(ecs_stack_t *stack, ecs_stack_cursor_t *cursor)
     * }
     */
    public static MethodHandle flecs_stack_restore_cursor$handle() {
        return flecs_stack_restore_cursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_stack_restore_cursor(ecs_stack_t *stack, ecs_stack_cursor_t *cursor)
     * }
     */
    public static MemorySegment flecs_stack_restore_cursor$address() {
        return flecs_stack_restore_cursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_stack_restore_cursor(ecs_stack_t *stack, ecs_stack_cursor_t *cursor)
     * }
     */
    public static void flecs_stack_restore_cursor(MemorySegment stack, MemorySegment cursor) {
        var mh$ = flecs_stack_restore_cursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stack_restore_cursor", stack, cursor);
            }
            mh$.invokeExact(stack, cursor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint64_t ecs_map_data_t
     * }
     */
    public static final OfLong ecs_map_data_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef ecs_map_data_t ecs_map_key_t
     * }
     */
    public static final OfLong ecs_map_key_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef ecs_map_data_t ecs_map_val_t
     * }
     */
    public static final OfLong ecs_map_val_t = flecs_h.C_LONG;

    private static class ecs_map_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_map_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_init(ecs_map_t *map, struct ecs_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor ecs_map_init$descriptor() {
        return ecs_map_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_init(ecs_map_t *map, struct ecs_allocator_t *allocator)
     * }
     */
    public static MethodHandle ecs_map_init$handle() {
        return ecs_map_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_init(ecs_map_t *map, struct ecs_allocator_t *allocator)
     * }
     */
    public static MemorySegment ecs_map_init$address() {
        return ecs_map_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_init(ecs_map_t *map, struct ecs_allocator_t *allocator)
     * }
     */
    public static void ecs_map_init(MemorySegment map, MemorySegment allocator) {
        var mh$ = ecs_map_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_init", map, allocator);
            }
            mh$.invokeExact(map, allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_init_if {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_map_init_if");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_init_if(ecs_map_t *map, struct ecs_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor ecs_map_init_if$descriptor() {
        return ecs_map_init_if.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_init_if(ecs_map_t *map, struct ecs_allocator_t *allocator)
     * }
     */
    public static MethodHandle ecs_map_init_if$handle() {
        return ecs_map_init_if.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_init_if(ecs_map_t *map, struct ecs_allocator_t *allocator)
     * }
     */
    public static MemorySegment ecs_map_init_if$address() {
        return ecs_map_init_if.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_init_if(ecs_map_t *map, struct ecs_allocator_t *allocator)
     * }
     */
    public static void ecs_map_init_if(MemorySegment map, MemorySegment allocator) {
        var mh$ = ecs_map_init_if.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_init_if", map, allocator);
            }
            mh$.invokeExact(map, allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_reclaim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_map_reclaim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_reclaim(ecs_map_t *map)
     * }
     */
    public static FunctionDescriptor ecs_map_reclaim$descriptor() {
        return ecs_map_reclaim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_reclaim(ecs_map_t *map)
     * }
     */
    public static MethodHandle ecs_map_reclaim$handle() {
        return ecs_map_reclaim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_reclaim(ecs_map_t *map)
     * }
     */
    public static MemorySegment ecs_map_reclaim$address() {
        return ecs_map_reclaim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_reclaim(ecs_map_t *map)
     * }
     */
    public static void ecs_map_reclaim(MemorySegment map) {
        var mh$ = ecs_map_reclaim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_reclaim", map);
            }
            mh$.invokeExact(map);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_map_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_fini(ecs_map_t *map)
     * }
     */
    public static FunctionDescriptor ecs_map_fini$descriptor() {
        return ecs_map_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_fini(ecs_map_t *map)
     * }
     */
    public static MethodHandle ecs_map_fini$handle() {
        return ecs_map_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_fini(ecs_map_t *map)
     * }
     */
    public static MemorySegment ecs_map_fini$address() {
        return ecs_map_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_fini(ecs_map_t *map)
     * }
     */
    public static void ecs_map_fini(MemorySegment map) {
        var mh$ = ecs_map_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_fini", map);
            }
            mh$.invokeExact(map);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_map_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_map_val_t *ecs_map_get(const ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static FunctionDescriptor ecs_map_get$descriptor() {
        return ecs_map_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_map_val_t *ecs_map_get(const ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MethodHandle ecs_map_get$handle() {
        return ecs_map_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_map_val_t *ecs_map_get(const ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_get$address() {
        return ecs_map_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_map_val_t *ecs_map_get(const ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_get(MemorySegment map, long key) {
        var mh$ = ecs_map_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_get", map, key);
            }
            return (MemorySegment)mh$.invokeExact(map, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_get_deref_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_map_get_deref_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_map_get_deref_(const ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static FunctionDescriptor ecs_map_get_deref_$descriptor() {
        return ecs_map_get_deref_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_map_get_deref_(const ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MethodHandle ecs_map_get_deref_$handle() {
        return ecs_map_get_deref_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_map_get_deref_(const ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_get_deref_$address() {
        return ecs_map_get_deref_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_map_get_deref_(const ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_get_deref_(MemorySegment map, long key) {
        var mh$ = ecs_map_get_deref_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_get_deref_", map, key);
            }
            return (MemorySegment)mh$.invokeExact(map, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_ensure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_map_ensure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_map_val_t *ecs_map_ensure(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static FunctionDescriptor ecs_map_ensure$descriptor() {
        return ecs_map_ensure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_map_val_t *ecs_map_ensure(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MethodHandle ecs_map_ensure$handle() {
        return ecs_map_ensure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_map_val_t *ecs_map_ensure(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_ensure$address() {
        return ecs_map_ensure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_map_val_t *ecs_map_ensure(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_ensure(MemorySegment map, long key) {
        var mh$ = ecs_map_ensure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_ensure", map, key);
            }
            return (MemorySegment)mh$.invokeExact(map, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_ensure_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_map_ensure_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_map_ensure_alloc(ecs_map_t *map, ecs_size_t elem_size, ecs_map_key_t key)
     * }
     */
    public static FunctionDescriptor ecs_map_ensure_alloc$descriptor() {
        return ecs_map_ensure_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_map_ensure_alloc(ecs_map_t *map, ecs_size_t elem_size, ecs_map_key_t key)
     * }
     */
    public static MethodHandle ecs_map_ensure_alloc$handle() {
        return ecs_map_ensure_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_map_ensure_alloc(ecs_map_t *map, ecs_size_t elem_size, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_ensure_alloc$address() {
        return ecs_map_ensure_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_map_ensure_alloc(ecs_map_t *map, ecs_size_t elem_size, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_ensure_alloc(MemorySegment map, int elem_size, long key) {
        var mh$ = ecs_map_ensure_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_ensure_alloc", map, elem_size, key);
            }
            return (MemorySegment)mh$.invokeExact(map, elem_size, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_map_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_insert(ecs_map_t *map, ecs_map_key_t key, ecs_map_val_t value)
     * }
     */
    public static FunctionDescriptor ecs_map_insert$descriptor() {
        return ecs_map_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_insert(ecs_map_t *map, ecs_map_key_t key, ecs_map_val_t value)
     * }
     */
    public static MethodHandle ecs_map_insert$handle() {
        return ecs_map_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_insert(ecs_map_t *map, ecs_map_key_t key, ecs_map_val_t value)
     * }
     */
    public static MemorySegment ecs_map_insert$address() {
        return ecs_map_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_insert(ecs_map_t *map, ecs_map_key_t key, ecs_map_val_t value)
     * }
     */
    public static void ecs_map_insert(MemorySegment map, long key, long value) {
        var mh$ = ecs_map_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_insert", map, key, value);
            }
            mh$.invokeExact(map, key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_insert_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_map_insert_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_map_insert_alloc(ecs_map_t *map, ecs_size_t elem_size, ecs_map_key_t key)
     * }
     */
    public static FunctionDescriptor ecs_map_insert_alloc$descriptor() {
        return ecs_map_insert_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_map_insert_alloc(ecs_map_t *map, ecs_size_t elem_size, ecs_map_key_t key)
     * }
     */
    public static MethodHandle ecs_map_insert_alloc$handle() {
        return ecs_map_insert_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_map_insert_alloc(ecs_map_t *map, ecs_size_t elem_size, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_insert_alloc$address() {
        return ecs_map_insert_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_map_insert_alloc(ecs_map_t *map, ecs_size_t elem_size, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_insert_alloc(MemorySegment map, int elem_size, long key) {
        var mh$ = ecs_map_insert_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_insert_alloc", map, elem_size, key);
            }
            return (MemorySegment)mh$.invokeExact(map, elem_size, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_map_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_map_val_t ecs_map_remove(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static FunctionDescriptor ecs_map_remove$descriptor() {
        return ecs_map_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_map_val_t ecs_map_remove(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MethodHandle ecs_map_remove$handle() {
        return ecs_map_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_map_val_t ecs_map_remove(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_remove$address() {
        return ecs_map_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_map_val_t ecs_map_remove(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static long ecs_map_remove(MemorySegment map, long key) {
        var mh$ = ecs_map_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_remove", map, key);
            }
            return (long)mh$.invokeExact(map, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_remove_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_map_remove_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_remove_free(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static FunctionDescriptor ecs_map_remove_free$descriptor() {
        return ecs_map_remove_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_remove_free(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MethodHandle ecs_map_remove_free$handle() {
        return ecs_map_remove_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_remove_free(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_remove_free$address() {
        return ecs_map_remove_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_remove_free(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static void ecs_map_remove_free(MemorySegment map, long key) {
        var mh$ = ecs_map_remove_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_remove_free", map, key);
            }
            mh$.invokeExact(map, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_map_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_clear(ecs_map_t *map)
     * }
     */
    public static FunctionDescriptor ecs_map_clear$descriptor() {
        return ecs_map_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_clear(ecs_map_t *map)
     * }
     */
    public static MethodHandle ecs_map_clear$handle() {
        return ecs_map_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_clear(ecs_map_t *map)
     * }
     */
    public static MemorySegment ecs_map_clear$address() {
        return ecs_map_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_clear(ecs_map_t *map)
     * }
     */
    public static void ecs_map_clear(MemorySegment map) {
        var mh$ = ecs_map_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_clear", map);
            }
            mh$.invokeExact(map);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_map_iter_t.layout(),
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_map_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_map_iter_t ecs_map_iter(const ecs_map_t *map)
     * }
     */
    public static FunctionDescriptor ecs_map_iter$descriptor() {
        return ecs_map_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_map_iter_t ecs_map_iter(const ecs_map_t *map)
     * }
     */
    public static MethodHandle ecs_map_iter$handle() {
        return ecs_map_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_map_iter_t ecs_map_iter(const ecs_map_t *map)
     * }
     */
    public static MemorySegment ecs_map_iter$address() {
        return ecs_map_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_map_iter_t ecs_map_iter(const ecs_map_t *map)
     * }
     */
    public static MemorySegment ecs_map_iter(SegmentAllocator allocator, MemorySegment map) {
        var mh$ = ecs_map_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_iter", allocator, map);
            }
            return (MemorySegment)mh$.invokeExact(allocator, map);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_iter_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_map_iter_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_map_iter_valid(ecs_map_iter_t *iter)
     * }
     */
    public static FunctionDescriptor ecs_map_iter_valid$descriptor() {
        return ecs_map_iter_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_map_iter_valid(ecs_map_iter_t *iter)
     * }
     */
    public static MethodHandle ecs_map_iter_valid$handle() {
        return ecs_map_iter_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_map_iter_valid(ecs_map_iter_t *iter)
     * }
     */
    public static MemorySegment ecs_map_iter_valid$address() {
        return ecs_map_iter_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_map_iter_valid(ecs_map_iter_t *iter)
     * }
     */
    public static boolean ecs_map_iter_valid(MemorySegment iter) {
        var mh$ = ecs_map_iter_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_iter_valid", iter);
            }
            return (boolean)mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_map_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_map_next(ecs_map_iter_t *iter)
     * }
     */
    public static FunctionDescriptor ecs_map_next$descriptor() {
        return ecs_map_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_map_next(ecs_map_iter_t *iter)
     * }
     */
    public static MethodHandle ecs_map_next$handle() {
        return ecs_map_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_map_next(ecs_map_iter_t *iter)
     * }
     */
    public static MemorySegment ecs_map_next$address() {
        return ecs_map_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_map_next(ecs_map_iter_t *iter)
     * }
     */
    public static boolean ecs_map_next(MemorySegment iter) {
        var mh$ = ecs_map_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_next", iter);
            }
            return (boolean)mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_map_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_copy(ecs_map_t *dst, const ecs_map_t *src)
     * }
     */
    public static FunctionDescriptor ecs_map_copy$descriptor() {
        return ecs_map_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_copy(ecs_map_t *dst, const ecs_map_t *src)
     * }
     */
    public static MethodHandle ecs_map_copy$handle() {
        return ecs_map_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_copy(ecs_map_t *dst, const ecs_map_t *src)
     * }
     */
    public static MemorySegment ecs_map_copy$address() {
        return ecs_map_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_copy(ecs_map_t *dst, const ecs_map_t *src)
     * }
     */
    public static void ecs_map_copy(MemorySegment dst, MemorySegment src) {
        var mh$ = ecs_map_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_copy", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_block_allocator_alloc_count$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("ecs_block_allocator_alloc_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_block_allocator_alloc_count
     * }
     */
    public static OfLong ecs_block_allocator_alloc_count$layout() {
        return ecs_block_allocator_alloc_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_block_allocator_alloc_count
     * }
     */
    public static MemorySegment ecs_block_allocator_alloc_count$segment() {
        return ecs_block_allocator_alloc_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_block_allocator_alloc_count
     * }
     */
    public static long ecs_block_allocator_alloc_count() {
        return ecs_block_allocator_alloc_count$constants.SEGMENT.get(ecs_block_allocator_alloc_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_block_allocator_alloc_count
     * }
     */
    public static void ecs_block_allocator_alloc_count(long varValue) {
        ecs_block_allocator_alloc_count$constants.SEGMENT.set(ecs_block_allocator_alloc_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_block_allocator_free_count$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("ecs_block_allocator_free_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_block_allocator_free_count
     * }
     */
    public static OfLong ecs_block_allocator_free_count$layout() {
        return ecs_block_allocator_free_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_block_allocator_free_count
     * }
     */
    public static MemorySegment ecs_block_allocator_free_count$segment() {
        return ecs_block_allocator_free_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_block_allocator_free_count
     * }
     */
    public static long ecs_block_allocator_free_count() {
        return ecs_block_allocator_free_count$constants.SEGMENT.get(ecs_block_allocator_free_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_block_allocator_free_count
     * }
     */
    public static void ecs_block_allocator_free_count(long varValue) {
        ecs_block_allocator_free_count$constants.SEGMENT.set(ecs_block_allocator_free_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_stack_allocator_alloc_count$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("ecs_stack_allocator_alloc_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_stack_allocator_alloc_count
     * }
     */
    public static OfLong ecs_stack_allocator_alloc_count$layout() {
        return ecs_stack_allocator_alloc_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_stack_allocator_alloc_count
     * }
     */
    public static MemorySegment ecs_stack_allocator_alloc_count$segment() {
        return ecs_stack_allocator_alloc_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_stack_allocator_alloc_count
     * }
     */
    public static long ecs_stack_allocator_alloc_count() {
        return ecs_stack_allocator_alloc_count$constants.SEGMENT.get(ecs_stack_allocator_alloc_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_stack_allocator_alloc_count
     * }
     */
    public static void ecs_stack_allocator_alloc_count(long varValue) {
        ecs_stack_allocator_alloc_count$constants.SEGMENT.set(ecs_stack_allocator_alloc_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_stack_allocator_free_count$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("ecs_stack_allocator_free_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_stack_allocator_free_count
     * }
     */
    public static OfLong ecs_stack_allocator_free_count$layout() {
        return ecs_stack_allocator_free_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_stack_allocator_free_count
     * }
     */
    public static MemorySegment ecs_stack_allocator_free_count$segment() {
        return ecs_stack_allocator_free_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_stack_allocator_free_count
     * }
     */
    public static long ecs_stack_allocator_free_count() {
        return ecs_stack_allocator_free_count$constants.SEGMENT.get(ecs_stack_allocator_free_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_stack_allocator_free_count
     * }
     */
    public static void ecs_stack_allocator_free_count(long varValue) {
        ecs_stack_allocator_free_count$constants.SEGMENT.set(ecs_stack_allocator_free_count$constants.LAYOUT, 0L, varValue);
    }

    private static class flecs_allocator_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_allocator_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_allocator_init(ecs_allocator_t *a)
     * }
     */
    public static FunctionDescriptor flecs_allocator_init$descriptor() {
        return flecs_allocator_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_allocator_init(ecs_allocator_t *a)
     * }
     */
    public static MethodHandle flecs_allocator_init$handle() {
        return flecs_allocator_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_allocator_init(ecs_allocator_t *a)
     * }
     */
    public static MemorySegment flecs_allocator_init$address() {
        return flecs_allocator_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_allocator_init(ecs_allocator_t *a)
     * }
     */
    public static void flecs_allocator_init(MemorySegment a) {
        var mh$ = flecs_allocator_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_allocator_init", a);
            }
            mh$.invokeExact(a);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_allocator_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_allocator_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_allocator_fini(ecs_allocator_t *a)
     * }
     */
    public static FunctionDescriptor flecs_allocator_fini$descriptor() {
        return flecs_allocator_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_allocator_fini(ecs_allocator_t *a)
     * }
     */
    public static MethodHandle flecs_allocator_fini$handle() {
        return flecs_allocator_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_allocator_fini(ecs_allocator_t *a)
     * }
     */
    public static MemorySegment flecs_allocator_fini$address() {
        return flecs_allocator_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_allocator_fini(ecs_allocator_t *a)
     * }
     */
    public static void flecs_allocator_fini(MemorySegment a) {
        var mh$ = flecs_allocator_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_allocator_fini", a);
            }
            mh$.invokeExact(a);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_allocator_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_allocator_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_block_allocator_t *flecs_allocator_get(ecs_allocator_t *a, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor flecs_allocator_get$descriptor() {
        return flecs_allocator_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_block_allocator_t *flecs_allocator_get(ecs_allocator_t *a, ecs_size_t size)
     * }
     */
    public static MethodHandle flecs_allocator_get$handle() {
        return flecs_allocator_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_block_allocator_t *flecs_allocator_get(ecs_allocator_t *a, ecs_size_t size)
     * }
     */
    public static MemorySegment flecs_allocator_get$address() {
        return flecs_allocator_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_block_allocator_t *flecs_allocator_get(ecs_allocator_t *a, ecs_size_t size)
     * }
     */
    public static MemorySegment flecs_allocator_get(MemorySegment a, int size) {
        var mh$ = flecs_allocator_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_allocator_get", a, size);
            }
            return (MemorySegment)mh$.invokeExact(a, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *flecs_strdup(ecs_allocator_t *a, const char *str)
     * }
     */
    public static FunctionDescriptor flecs_strdup$descriptor() {
        return flecs_strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *flecs_strdup(ecs_allocator_t *a, const char *str)
     * }
     */
    public static MethodHandle flecs_strdup$handle() {
        return flecs_strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *flecs_strdup(ecs_allocator_t *a, const char *str)
     * }
     */
    public static MemorySegment flecs_strdup$address() {
        return flecs_strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *flecs_strdup(ecs_allocator_t *a, const char *str)
     * }
     */
    public static MemorySegment flecs_strdup(MemorySegment a, MemorySegment str) {
        var mh$ = flecs_strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_strdup", a, str);
            }
            return (MemorySegment)mh$.invokeExact(a, str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_strfree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_strfree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_strfree(ecs_allocator_t *a, char *str)
     * }
     */
    public static FunctionDescriptor flecs_strfree$descriptor() {
        return flecs_strfree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_strfree(ecs_allocator_t *a, char *str)
     * }
     */
    public static MethodHandle flecs_strfree$handle() {
        return flecs_strfree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_strfree(ecs_allocator_t *a, char *str)
     * }
     */
    public static MemorySegment flecs_strfree$address() {
        return flecs_strfree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_strfree(ecs_allocator_t *a, char *str)
     * }
     */
    public static void flecs_strfree(MemorySegment a, MemorySegment str) {
        var mh$ = flecs_strfree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_strfree", a, str);
            }
            mh$.invokeExact(a, str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_dup(ecs_allocator_t *a, ecs_size_t size, const void *src)
     * }
     */
    public static FunctionDescriptor flecs_dup$descriptor() {
        return flecs_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_dup(ecs_allocator_t *a, ecs_size_t size, const void *src)
     * }
     */
    public static MethodHandle flecs_dup$handle() {
        return flecs_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_dup(ecs_allocator_t *a, ecs_size_t size, const void *src)
     * }
     */
    public static MemorySegment flecs_dup$address() {
        return flecs_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_dup(ecs_allocator_t *a, ecs_size_t size, const void *src)
     * }
     */
    public static MemorySegment flecs_dup(MemorySegment a, int size, MemorySegment src) {
        var mh$ = flecs_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_dup", a, size, src);
            }
            return (MemorySegment)mh$.invokeExact(a, size, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void ecs_strbuf_append(ecs_strbuf_t *buffer, const char *fmt, ...)
     * }
     */
    public static class ecs_strbuf_append {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                flecs_h.C_POINTER,
                flecs_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_append");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private ecs_strbuf_append(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void ecs_strbuf_append(ecs_strbuf_t *buffer, const char *fmt, ...)
         * }
         */
        public static ecs_strbuf_append makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new ecs_strbuf_append(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment buffer, MemorySegment fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("ecs_strbuf_append", buffer, fmt, x2);
                }
                 spreader.invokeExact(buffer, fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class ecs_strbuf_vappend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_vappend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_vappend(ecs_strbuf_t *buffer, const char *fmt, va_list args)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_vappend$descriptor() {
        return ecs_strbuf_vappend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_vappend(ecs_strbuf_t *buffer, const char *fmt, va_list args)
     * }
     */
    public static MethodHandle ecs_strbuf_vappend$handle() {
        return ecs_strbuf_vappend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_vappend(ecs_strbuf_t *buffer, const char *fmt, va_list args)
     * }
     */
    public static MemorySegment ecs_strbuf_vappend$address() {
        return ecs_strbuf_vappend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_vappend(ecs_strbuf_t *buffer, const char *fmt, va_list args)
     * }
     */
    public static void ecs_strbuf_vappend(MemorySegment buffer, MemorySegment fmt, MemorySegment args) {
        var mh$ = ecs_strbuf_vappend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_vappend", buffer, fmt, args);
            }
            mh$.invokeExact(buffer, fmt, args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_appendstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_appendstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendstr(ecs_strbuf_t *buffer, const char *str)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_appendstr$descriptor() {
        return ecs_strbuf_appendstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendstr(ecs_strbuf_t *buffer, const char *str)
     * }
     */
    public static MethodHandle ecs_strbuf_appendstr$handle() {
        return ecs_strbuf_appendstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendstr(ecs_strbuf_t *buffer, const char *str)
     * }
     */
    public static MemorySegment ecs_strbuf_appendstr$address() {
        return ecs_strbuf_appendstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_appendstr(ecs_strbuf_t *buffer, const char *str)
     * }
     */
    public static void ecs_strbuf_appendstr(MemorySegment buffer, MemorySegment str) {
        var mh$ = ecs_strbuf_appendstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_appendstr", buffer, str);
            }
            mh$.invokeExact(buffer, str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_appendch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_appendch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendch(ecs_strbuf_t *buffer, char ch)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_appendch$descriptor() {
        return ecs_strbuf_appendch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendch(ecs_strbuf_t *buffer, char ch)
     * }
     */
    public static MethodHandle ecs_strbuf_appendch$handle() {
        return ecs_strbuf_appendch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendch(ecs_strbuf_t *buffer, char ch)
     * }
     */
    public static MemorySegment ecs_strbuf_appendch$address() {
        return ecs_strbuf_appendch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_appendch(ecs_strbuf_t *buffer, char ch)
     * }
     */
    public static void ecs_strbuf_appendch(MemorySegment buffer, byte ch) {
        var mh$ = ecs_strbuf_appendch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_appendch", buffer, ch);
            }
            mh$.invokeExact(buffer, ch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_appendint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_appendint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendint(ecs_strbuf_t *buffer, int64_t v)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_appendint$descriptor() {
        return ecs_strbuf_appendint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendint(ecs_strbuf_t *buffer, int64_t v)
     * }
     */
    public static MethodHandle ecs_strbuf_appendint$handle() {
        return ecs_strbuf_appendint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendint(ecs_strbuf_t *buffer, int64_t v)
     * }
     */
    public static MemorySegment ecs_strbuf_appendint$address() {
        return ecs_strbuf_appendint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_appendint(ecs_strbuf_t *buffer, int64_t v)
     * }
     */
    public static void ecs_strbuf_appendint(MemorySegment buffer, long v) {
        var mh$ = ecs_strbuf_appendint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_appendint", buffer, v);
            }
            mh$.invokeExact(buffer, v);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_appendflt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_DOUBLE,
            flecs_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_appendflt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendflt(ecs_strbuf_t *buffer, double v, char nan_delim)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_appendflt$descriptor() {
        return ecs_strbuf_appendflt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendflt(ecs_strbuf_t *buffer, double v, char nan_delim)
     * }
     */
    public static MethodHandle ecs_strbuf_appendflt$handle() {
        return ecs_strbuf_appendflt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendflt(ecs_strbuf_t *buffer, double v, char nan_delim)
     * }
     */
    public static MemorySegment ecs_strbuf_appendflt$address() {
        return ecs_strbuf_appendflt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_appendflt(ecs_strbuf_t *buffer, double v, char nan_delim)
     * }
     */
    public static void ecs_strbuf_appendflt(MemorySegment buffer, double v, byte nan_delim) {
        var mh$ = ecs_strbuf_appendflt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_appendflt", buffer, v, nan_delim);
            }
            mh$.invokeExact(buffer, v, nan_delim);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_appendbool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_appendbool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendbool(ecs_strbuf_t *buffer, _Bool v)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_appendbool$descriptor() {
        return ecs_strbuf_appendbool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendbool(ecs_strbuf_t *buffer, _Bool v)
     * }
     */
    public static MethodHandle ecs_strbuf_appendbool$handle() {
        return ecs_strbuf_appendbool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendbool(ecs_strbuf_t *buffer, _Bool v)
     * }
     */
    public static MemorySegment ecs_strbuf_appendbool$address() {
        return ecs_strbuf_appendbool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_appendbool(ecs_strbuf_t *buffer, _Bool v)
     * }
     */
    public static void ecs_strbuf_appendbool(MemorySegment buffer, boolean v) {
        var mh$ = ecs_strbuf_appendbool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_appendbool", buffer, v);
            }
            mh$.invokeExact(buffer, v);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_mergebuff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_mergebuff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_mergebuff(ecs_strbuf_t *dst_buffer, ecs_strbuf_t *src_buffer)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_mergebuff$descriptor() {
        return ecs_strbuf_mergebuff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_mergebuff(ecs_strbuf_t *dst_buffer, ecs_strbuf_t *src_buffer)
     * }
     */
    public static MethodHandle ecs_strbuf_mergebuff$handle() {
        return ecs_strbuf_mergebuff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_mergebuff(ecs_strbuf_t *dst_buffer, ecs_strbuf_t *src_buffer)
     * }
     */
    public static MemorySegment ecs_strbuf_mergebuff$address() {
        return ecs_strbuf_mergebuff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_mergebuff(ecs_strbuf_t *dst_buffer, ecs_strbuf_t *src_buffer)
     * }
     */
    public static void ecs_strbuf_mergebuff(MemorySegment dst_buffer, MemorySegment src_buffer) {
        var mh$ = ecs_strbuf_mergebuff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_mergebuff", dst_buffer, src_buffer);
            }
            mh$.invokeExact(dst_buffer, src_buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_appendstrn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_appendstrn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendstrn(ecs_strbuf_t *buffer, const char *str, int32_t n)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_appendstrn$descriptor() {
        return ecs_strbuf_appendstrn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendstrn(ecs_strbuf_t *buffer, const char *str, int32_t n)
     * }
     */
    public static MethodHandle ecs_strbuf_appendstrn$handle() {
        return ecs_strbuf_appendstrn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendstrn(ecs_strbuf_t *buffer, const char *str, int32_t n)
     * }
     */
    public static MemorySegment ecs_strbuf_appendstrn$address() {
        return ecs_strbuf_appendstrn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_appendstrn(ecs_strbuf_t *buffer, const char *str, int32_t n)
     * }
     */
    public static void ecs_strbuf_appendstrn(MemorySegment buffer, MemorySegment str, int n) {
        var mh$ = ecs_strbuf_appendstrn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_appendstrn", buffer, str, n);
            }
            mh$.invokeExact(buffer, str, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_strbuf_get(ecs_strbuf_t *buffer)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_get$descriptor() {
        return ecs_strbuf_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_strbuf_get(ecs_strbuf_t *buffer)
     * }
     */
    public static MethodHandle ecs_strbuf_get$handle() {
        return ecs_strbuf_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_strbuf_get(ecs_strbuf_t *buffer)
     * }
     */
    public static MemorySegment ecs_strbuf_get$address() {
        return ecs_strbuf_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_strbuf_get(ecs_strbuf_t *buffer)
     * }
     */
    public static MemorySegment ecs_strbuf_get(MemorySegment buffer) {
        var mh$ = ecs_strbuf_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_get", buffer);
            }
            return (MemorySegment)mh$.invokeExact(buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_get_small {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_get_small");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_strbuf_get_small(ecs_strbuf_t *buffer)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_get_small$descriptor() {
        return ecs_strbuf_get_small.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_strbuf_get_small(ecs_strbuf_t *buffer)
     * }
     */
    public static MethodHandle ecs_strbuf_get_small$handle() {
        return ecs_strbuf_get_small.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_strbuf_get_small(ecs_strbuf_t *buffer)
     * }
     */
    public static MemorySegment ecs_strbuf_get_small$address() {
        return ecs_strbuf_get_small.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_strbuf_get_small(ecs_strbuf_t *buffer)
     * }
     */
    public static MemorySegment ecs_strbuf_get_small(MemorySegment buffer) {
        var mh$ = ecs_strbuf_get_small.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_get_small", buffer);
            }
            return (MemorySegment)mh$.invokeExact(buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_reset(ecs_strbuf_t *buffer)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_reset$descriptor() {
        return ecs_strbuf_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_reset(ecs_strbuf_t *buffer)
     * }
     */
    public static MethodHandle ecs_strbuf_reset$handle() {
        return ecs_strbuf_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_reset(ecs_strbuf_t *buffer)
     * }
     */
    public static MemorySegment ecs_strbuf_reset$address() {
        return ecs_strbuf_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_reset(ecs_strbuf_t *buffer)
     * }
     */
    public static void ecs_strbuf_reset(MemorySegment buffer) {
        var mh$ = ecs_strbuf_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_reset", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_list_push {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_list_push");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_push(ecs_strbuf_t *buffer, const char *list_open, const char *separator)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_list_push$descriptor() {
        return ecs_strbuf_list_push.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_push(ecs_strbuf_t *buffer, const char *list_open, const char *separator)
     * }
     */
    public static MethodHandle ecs_strbuf_list_push$handle() {
        return ecs_strbuf_list_push.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_push(ecs_strbuf_t *buffer, const char *list_open, const char *separator)
     * }
     */
    public static MemorySegment ecs_strbuf_list_push$address() {
        return ecs_strbuf_list_push.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_list_push(ecs_strbuf_t *buffer, const char *list_open, const char *separator)
     * }
     */
    public static void ecs_strbuf_list_push(MemorySegment buffer, MemorySegment list_open, MemorySegment separator) {
        var mh$ = ecs_strbuf_list_push.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_list_push", buffer, list_open, separator);
            }
            mh$.invokeExact(buffer, list_open, separator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_list_pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_list_pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_pop(ecs_strbuf_t *buffer, const char *list_close)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_list_pop$descriptor() {
        return ecs_strbuf_list_pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_pop(ecs_strbuf_t *buffer, const char *list_close)
     * }
     */
    public static MethodHandle ecs_strbuf_list_pop$handle() {
        return ecs_strbuf_list_pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_pop(ecs_strbuf_t *buffer, const char *list_close)
     * }
     */
    public static MemorySegment ecs_strbuf_list_pop$address() {
        return ecs_strbuf_list_pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_list_pop(ecs_strbuf_t *buffer, const char *list_close)
     * }
     */
    public static void ecs_strbuf_list_pop(MemorySegment buffer, MemorySegment list_close) {
        var mh$ = ecs_strbuf_list_pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_list_pop", buffer, list_close);
            }
            mh$.invokeExact(buffer, list_close);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_list_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_list_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_next(ecs_strbuf_t *buffer)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_list_next$descriptor() {
        return ecs_strbuf_list_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_next(ecs_strbuf_t *buffer)
     * }
     */
    public static MethodHandle ecs_strbuf_list_next$handle() {
        return ecs_strbuf_list_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_next(ecs_strbuf_t *buffer)
     * }
     */
    public static MemorySegment ecs_strbuf_list_next$address() {
        return ecs_strbuf_list_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_list_next(ecs_strbuf_t *buffer)
     * }
     */
    public static void ecs_strbuf_list_next(MemorySegment buffer) {
        var mh$ = ecs_strbuf_list_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_list_next", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_list_appendch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_list_appendch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendch(ecs_strbuf_t *buffer, char ch)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_list_appendch$descriptor() {
        return ecs_strbuf_list_appendch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendch(ecs_strbuf_t *buffer, char ch)
     * }
     */
    public static MethodHandle ecs_strbuf_list_appendch$handle() {
        return ecs_strbuf_list_appendch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendch(ecs_strbuf_t *buffer, char ch)
     * }
     */
    public static MemorySegment ecs_strbuf_list_appendch$address() {
        return ecs_strbuf_list_appendch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendch(ecs_strbuf_t *buffer, char ch)
     * }
     */
    public static void ecs_strbuf_list_appendch(MemorySegment buffer, byte ch) {
        var mh$ = ecs_strbuf_list_appendch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_list_appendch", buffer, ch);
            }
            mh$.invokeExact(buffer, ch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_append(ecs_strbuf_t *buffer, const char *fmt, ...)
     * }
     */
    public static class ecs_strbuf_list_append {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                flecs_h.C_POINTER,
                flecs_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_list_append");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private ecs_strbuf_list_append(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void ecs_strbuf_list_append(ecs_strbuf_t *buffer, const char *fmt, ...)
         * }
         */
        public static ecs_strbuf_list_append makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new ecs_strbuf_list_append(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment buffer, MemorySegment fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("ecs_strbuf_list_append", buffer, fmt, x2);
                }
                 spreader.invokeExact(buffer, fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class ecs_strbuf_list_appendstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_list_appendstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendstr(ecs_strbuf_t *buffer, const char *str)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_list_appendstr$descriptor() {
        return ecs_strbuf_list_appendstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendstr(ecs_strbuf_t *buffer, const char *str)
     * }
     */
    public static MethodHandle ecs_strbuf_list_appendstr$handle() {
        return ecs_strbuf_list_appendstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendstr(ecs_strbuf_t *buffer, const char *str)
     * }
     */
    public static MemorySegment ecs_strbuf_list_appendstr$address() {
        return ecs_strbuf_list_appendstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendstr(ecs_strbuf_t *buffer, const char *str)
     * }
     */
    public static void ecs_strbuf_list_appendstr(MemorySegment buffer, MemorySegment str) {
        var mh$ = ecs_strbuf_list_appendstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_list_appendstr", buffer, str);
            }
            mh$.invokeExact(buffer, str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_list_appendstrn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_list_appendstrn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendstrn(ecs_strbuf_t *buffer, const char *str, int32_t n)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_list_appendstrn$descriptor() {
        return ecs_strbuf_list_appendstrn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendstrn(ecs_strbuf_t *buffer, const char *str, int32_t n)
     * }
     */
    public static MethodHandle ecs_strbuf_list_appendstrn$handle() {
        return ecs_strbuf_list_appendstrn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendstrn(ecs_strbuf_t *buffer, const char *str, int32_t n)
     * }
     */
    public static MemorySegment ecs_strbuf_list_appendstrn$address() {
        return ecs_strbuf_list_appendstrn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendstrn(ecs_strbuf_t *buffer, const char *str, int32_t n)
     * }
     */
    public static void ecs_strbuf_list_appendstrn(MemorySegment buffer, MemorySegment str, int n) {
        var mh$ = ecs_strbuf_list_appendstrn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_list_appendstrn", buffer, str, n);
            }
            mh$.invokeExact(buffer, str, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_written {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strbuf_written");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_strbuf_written(const ecs_strbuf_t *buffer)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_written$descriptor() {
        return ecs_strbuf_written.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_strbuf_written(const ecs_strbuf_t *buffer)
     * }
     */
    public static MethodHandle ecs_strbuf_written$handle() {
        return ecs_strbuf_written.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_strbuf_written(const ecs_strbuf_t *buffer)
     * }
     */
    public static MemorySegment ecs_strbuf_written$address() {
        return ecs_strbuf_written.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_strbuf_written(const ecs_strbuf_t *buffer)
     * }
     */
    public static int ecs_strbuf_written(MemorySegment buffer) {
        var mh$ = ecs_strbuf_written.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_written", buffer);
            }
            return (int)mh$.invokeExact(buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_api_malloc_count$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("ecs_os_api_malloc_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_malloc_count
     * }
     */
    public static OfLong ecs_os_api_malloc_count$layout() {
        return ecs_os_api_malloc_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_malloc_count
     * }
     */
    public static MemorySegment ecs_os_api_malloc_count$segment() {
        return ecs_os_api_malloc_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_malloc_count
     * }
     */
    public static long ecs_os_api_malloc_count() {
        return ecs_os_api_malloc_count$constants.SEGMENT.get(ecs_os_api_malloc_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_malloc_count
     * }
     */
    public static void ecs_os_api_malloc_count(long varValue) {
        ecs_os_api_malloc_count$constants.SEGMENT.set(ecs_os_api_malloc_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_os_api_realloc_count$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("ecs_os_api_realloc_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_realloc_count
     * }
     */
    public static OfLong ecs_os_api_realloc_count$layout() {
        return ecs_os_api_realloc_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_realloc_count
     * }
     */
    public static MemorySegment ecs_os_api_realloc_count$segment() {
        return ecs_os_api_realloc_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_realloc_count
     * }
     */
    public static long ecs_os_api_realloc_count() {
        return ecs_os_api_realloc_count$constants.SEGMENT.get(ecs_os_api_realloc_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_realloc_count
     * }
     */
    public static void ecs_os_api_realloc_count(long varValue) {
        ecs_os_api_realloc_count$constants.SEGMENT.set(ecs_os_api_realloc_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_os_api_calloc_count$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("ecs_os_api_calloc_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_calloc_count
     * }
     */
    public static OfLong ecs_os_api_calloc_count$layout() {
        return ecs_os_api_calloc_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_calloc_count
     * }
     */
    public static MemorySegment ecs_os_api_calloc_count$segment() {
        return ecs_os_api_calloc_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_calloc_count
     * }
     */
    public static long ecs_os_api_calloc_count() {
        return ecs_os_api_calloc_count$constants.SEGMENT.get(ecs_os_api_calloc_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_calloc_count
     * }
     */
    public static void ecs_os_api_calloc_count(long varValue) {
        ecs_os_api_calloc_count$constants.SEGMENT.set(ecs_os_api_calloc_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_os_api_free_count$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("ecs_os_api_free_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_free_count
     * }
     */
    public static OfLong ecs_os_api_free_count$layout() {
        return ecs_os_api_free_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_free_count
     * }
     */
    public static MemorySegment ecs_os_api_free_count$segment() {
        return ecs_os_api_free_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_free_count
     * }
     */
    public static long ecs_os_api_free_count() {
        return ecs_os_api_free_count$constants.SEGMENT.get(ecs_os_api_free_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_free_count
     * }
     */
    public static void ecs_os_api_free_count(long varValue) {
        ecs_os_api_free_count$constants.SEGMENT.set(ecs_os_api_free_count$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef uintptr_t ecs_os_thread_t
     * }
     */
    public static final OfLong ecs_os_thread_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t ecs_os_cond_t
     * }
     */
    public static final OfLong ecs_os_cond_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t ecs_os_mutex_t
     * }
     */
    public static final OfLong ecs_os_mutex_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t ecs_os_dl_t
     * }
     */
    public static final OfLong ecs_os_dl_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t ecs_os_sock_t
     * }
     */
    public static final OfLong ecs_os_sock_t = flecs_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t ecs_os_thread_id_t
     * }
     */
    public static final OfLong ecs_os_thread_id_t = flecs_h.C_LONG;

    private static class ecs_os_api$constants {
        public static final GroupLayout LAYOUT = ecs_os_api_t.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("ecs_os_api").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_os_api_t ecs_os_api
     * }
     */
    public static GroupLayout ecs_os_api$layout() {
        return ecs_os_api$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_os_api_t ecs_os_api
     * }
     */
    public static MemorySegment ecs_os_api() {
        return ecs_os_api$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_os_api_t ecs_os_api
     * }
     */
    public static void ecs_os_api(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, ecs_os_api$constants.SEGMENT, 0L, ecs_os_api$constants.LAYOUT.byteSize());
    }

    private static class ecs_os_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_init()
     * }
     */
    public static FunctionDescriptor ecs_os_init$descriptor() {
        return ecs_os_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_init()
     * }
     */
    public static MethodHandle ecs_os_init$handle() {
        return ecs_os_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_init()
     * }
     */
    public static MemorySegment ecs_os_init$address() {
        return ecs_os_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_init()
     * }
     */
    public static void ecs_os_init() {
        var mh$ = ecs_os_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_init");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_fini()
     * }
     */
    public static FunctionDescriptor ecs_os_fini$descriptor() {
        return ecs_os_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_fini()
     * }
     */
    public static MethodHandle ecs_os_fini$handle() {
        return ecs_os_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_fini()
     * }
     */
    public static MemorySegment ecs_os_fini$address() {
        return ecs_os_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_fini()
     * }
     */
    public static void ecs_os_fini() {
        var mh$ = ecs_os_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_fini");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_set_api {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_set_api");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_set_api(ecs_os_api_t *os_api)
     * }
     */
    public static FunctionDescriptor ecs_os_set_api$descriptor() {
        return ecs_os_set_api.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_set_api(ecs_os_api_t *os_api)
     * }
     */
    public static MethodHandle ecs_os_set_api$handle() {
        return ecs_os_set_api.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_set_api(ecs_os_api_t *os_api)
     * }
     */
    public static MemorySegment ecs_os_set_api$address() {
        return ecs_os_set_api.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_set_api(ecs_os_api_t *os_api)
     * }
     */
    public static void ecs_os_set_api(MemorySegment os_api) {
        var mh$ = ecs_os_set_api.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_set_api", os_api);
            }
            mh$.invokeExact(os_api);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_get_api {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_os_api_t.layout()    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_get_api");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_os_api_t ecs_os_get_api()
     * }
     */
    public static FunctionDescriptor ecs_os_get_api$descriptor() {
        return ecs_os_get_api.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_os_api_t ecs_os_get_api()
     * }
     */
    public static MethodHandle ecs_os_get_api$handle() {
        return ecs_os_get_api.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_os_api_t ecs_os_get_api()
     * }
     */
    public static MemorySegment ecs_os_get_api$address() {
        return ecs_os_get_api.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_os_api_t ecs_os_get_api()
     * }
     */
    public static MemorySegment ecs_os_get_api(SegmentAllocator allocator) {
        var mh$ = ecs_os_get_api.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_get_api", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_set_api_defaults {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_set_api_defaults");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_set_api_defaults()
     * }
     */
    public static FunctionDescriptor ecs_os_set_api_defaults$descriptor() {
        return ecs_os_set_api_defaults.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_set_api_defaults()
     * }
     */
    public static MethodHandle ecs_os_set_api_defaults$handle() {
        return ecs_os_set_api_defaults.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_set_api_defaults()
     * }
     */
    public static MemorySegment ecs_os_set_api_defaults$address() {
        return ecs_os_set_api_defaults.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_set_api_defaults()
     * }
     */
    public static void ecs_os_set_api_defaults() {
        var mh$ = ecs_os_set_api_defaults.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_set_api_defaults");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_dbg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_dbg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_dbg(const char *file, int32_t line, const char *msg)
     * }
     */
    public static FunctionDescriptor ecs_os_dbg$descriptor() {
        return ecs_os_dbg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_dbg(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MethodHandle ecs_os_dbg$handle() {
        return ecs_os_dbg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_dbg(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MemorySegment ecs_os_dbg$address() {
        return ecs_os_dbg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_dbg(const char *file, int32_t line, const char *msg)
     * }
     */
    public static void ecs_os_dbg(MemorySegment file, int line, MemorySegment msg) {
        var mh$ = ecs_os_dbg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_dbg", file, line, msg);
            }
            mh$.invokeExact(file, line, msg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_trace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_trace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_trace(const char *file, int32_t line, const char *msg)
     * }
     */
    public static FunctionDescriptor ecs_os_trace$descriptor() {
        return ecs_os_trace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_trace(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MethodHandle ecs_os_trace$handle() {
        return ecs_os_trace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_trace(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MemorySegment ecs_os_trace$address() {
        return ecs_os_trace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_trace(const char *file, int32_t line, const char *msg)
     * }
     */
    public static void ecs_os_trace(MemorySegment file, int line, MemorySegment msg) {
        var mh$ = ecs_os_trace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_trace", file, line, msg);
            }
            mh$.invokeExact(file, line, msg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_warn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_warn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_warn(const char *file, int32_t line, const char *msg)
     * }
     */
    public static FunctionDescriptor ecs_os_warn$descriptor() {
        return ecs_os_warn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_warn(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MethodHandle ecs_os_warn$handle() {
        return ecs_os_warn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_warn(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MemorySegment ecs_os_warn$address() {
        return ecs_os_warn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_warn(const char *file, int32_t line, const char *msg)
     * }
     */
    public static void ecs_os_warn(MemorySegment file, int line, MemorySegment msg) {
        var mh$ = ecs_os_warn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_warn", file, line, msg);
            }
            mh$.invokeExact(file, line, msg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_err {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_err");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_err(const char *file, int32_t line, const char *msg)
     * }
     */
    public static FunctionDescriptor ecs_os_err$descriptor() {
        return ecs_os_err.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_err(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MethodHandle ecs_os_err$handle() {
        return ecs_os_err.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_err(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MemorySegment ecs_os_err$address() {
        return ecs_os_err.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_err(const char *file, int32_t line, const char *msg)
     * }
     */
    public static void ecs_os_err(MemorySegment file, int line, MemorySegment msg) {
        var mh$ = ecs_os_err.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_err", file, line, msg);
            }
            mh$.invokeExact(file, line, msg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_fatal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_fatal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_fatal(const char *file, int32_t line, const char *msg)
     * }
     */
    public static FunctionDescriptor ecs_os_fatal$descriptor() {
        return ecs_os_fatal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_fatal(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MethodHandle ecs_os_fatal$handle() {
        return ecs_os_fatal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_fatal(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MemorySegment ecs_os_fatal$address() {
        return ecs_os_fatal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_fatal(const char *file, int32_t line, const char *msg)
     * }
     */
    public static void ecs_os_fatal(MemorySegment file, int line, MemorySegment msg) {
        var mh$ = ecs_os_fatal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_fatal", file, line, msg);
            }
            mh$.invokeExact(file, line, msg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_os_strerror(int err)
     * }
     */
    public static FunctionDescriptor ecs_os_strerror$descriptor() {
        return ecs_os_strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_os_strerror(int err)
     * }
     */
    public static MethodHandle ecs_os_strerror$handle() {
        return ecs_os_strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_os_strerror(int err)
     * }
     */
    public static MemorySegment ecs_os_strerror$address() {
        return ecs_os_strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_os_strerror(int err)
     * }
     */
    public static MemorySegment ecs_os_strerror(int err) {
        var mh$ = ecs_os_strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_strerror", err);
            }
            return (MemorySegment)mh$.invokeExact(err);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_strset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_strset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_strset(char **str, const char *value)
     * }
     */
    public static FunctionDescriptor ecs_os_strset$descriptor() {
        return ecs_os_strset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_strset(char **str, const char *value)
     * }
     */
    public static MethodHandle ecs_os_strset$handle() {
        return ecs_os_strset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_strset(char **str, const char *value)
     * }
     */
    public static MemorySegment ecs_os_strset$address() {
        return ecs_os_strset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_strset(char **str, const char *value)
     * }
     */
    public static void ecs_os_strset(MemorySegment str, MemorySegment value) {
        var mh$ = ecs_os_strset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_strset", str, value);
            }
            mh$.invokeExact(str, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_perf_trace_push_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_perf_trace_push_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_perf_trace_push_(const char *file, size_t line, const char *name)
     * }
     */
    public static FunctionDescriptor ecs_os_perf_trace_push_$descriptor() {
        return ecs_os_perf_trace_push_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_perf_trace_push_(const char *file, size_t line, const char *name)
     * }
     */
    public static MethodHandle ecs_os_perf_trace_push_$handle() {
        return ecs_os_perf_trace_push_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_perf_trace_push_(const char *file, size_t line, const char *name)
     * }
     */
    public static MemorySegment ecs_os_perf_trace_push_$address() {
        return ecs_os_perf_trace_push_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_perf_trace_push_(const char *file, size_t line, const char *name)
     * }
     */
    public static void ecs_os_perf_trace_push_(MemorySegment file, long line, MemorySegment name) {
        var mh$ = ecs_os_perf_trace_push_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_perf_trace_push_", file, line, name);
            }
            mh$.invokeExact(file, line, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_perf_trace_pop_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_perf_trace_pop_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_perf_trace_pop_(const char *file, size_t line, const char *name)
     * }
     */
    public static FunctionDescriptor ecs_os_perf_trace_pop_$descriptor() {
        return ecs_os_perf_trace_pop_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_perf_trace_pop_(const char *file, size_t line, const char *name)
     * }
     */
    public static MethodHandle ecs_os_perf_trace_pop_$handle() {
        return ecs_os_perf_trace_pop_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_perf_trace_pop_(const char *file, size_t line, const char *name)
     * }
     */
    public static MemorySegment ecs_os_perf_trace_pop_$address() {
        return ecs_os_perf_trace_pop_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_perf_trace_pop_(const char *file, size_t line, const char *name)
     * }
     */
    public static void ecs_os_perf_trace_pop_(MemorySegment file, long line, MemorySegment name) {
        var mh$ = ecs_os_perf_trace_pop_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_perf_trace_pop_", file, line, name);
            }
            mh$.invokeExact(file, line, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_sleepf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_sleepf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_sleepf(double t)
     * }
     */
    public static FunctionDescriptor ecs_sleepf$descriptor() {
        return ecs_sleepf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_sleepf(double t)
     * }
     */
    public static MethodHandle ecs_sleepf$handle() {
        return ecs_sleepf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_sleepf(double t)
     * }
     */
    public static MemorySegment ecs_sleepf$address() {
        return ecs_sleepf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_sleepf(double t)
     * }
     */
    public static void ecs_sleepf(double t) {
        var mh$ = ecs_sleepf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_sleepf", t);
            }
            mh$.invokeExact(t);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_time_measure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_DOUBLE,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_time_measure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double ecs_time_measure(ecs_time_t *start)
     * }
     */
    public static FunctionDescriptor ecs_time_measure$descriptor() {
        return ecs_time_measure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double ecs_time_measure(ecs_time_t *start)
     * }
     */
    public static MethodHandle ecs_time_measure$handle() {
        return ecs_time_measure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double ecs_time_measure(ecs_time_t *start)
     * }
     */
    public static MemorySegment ecs_time_measure$address() {
        return ecs_time_measure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double ecs_time_measure(ecs_time_t *start)
     * }
     */
    public static double ecs_time_measure(MemorySegment start) {
        var mh$ = ecs_time_measure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_time_measure", start);
            }
            return (double)mh$.invokeExact(start);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_time_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_time_t.layout(),
            ecs_time_t.layout(),
            ecs_time_t.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_time_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_time_t ecs_time_sub(ecs_time_t t1, ecs_time_t t2)
     * }
     */
    public static FunctionDescriptor ecs_time_sub$descriptor() {
        return ecs_time_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_time_t ecs_time_sub(ecs_time_t t1, ecs_time_t t2)
     * }
     */
    public static MethodHandle ecs_time_sub$handle() {
        return ecs_time_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_time_t ecs_time_sub(ecs_time_t t1, ecs_time_t t2)
     * }
     */
    public static MemorySegment ecs_time_sub$address() {
        return ecs_time_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_time_t ecs_time_sub(ecs_time_t t1, ecs_time_t t2)
     * }
     */
    public static MemorySegment ecs_time_sub(SegmentAllocator allocator, MemorySegment t1, MemorySegment t2) {
        var mh$ = ecs_time_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_time_sub", allocator, t1, t2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, t1, t2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_time_to_double {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_DOUBLE,
            ecs_time_t.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_time_to_double");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double ecs_time_to_double(ecs_time_t t)
     * }
     */
    public static FunctionDescriptor ecs_time_to_double$descriptor() {
        return ecs_time_to_double.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double ecs_time_to_double(ecs_time_t t)
     * }
     */
    public static MethodHandle ecs_time_to_double$handle() {
        return ecs_time_to_double.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double ecs_time_to_double(ecs_time_t t)
     * }
     */
    public static MemorySegment ecs_time_to_double$address() {
        return ecs_time_to_double.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double ecs_time_to_double(ecs_time_t t)
     * }
     */
    public static double ecs_time_to_double(MemorySegment t) {
        var mh$ = ecs_time_to_double.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_time_to_double", t);
            }
            return (double)mh$.invokeExact(t);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_memdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_memdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_os_memdup(const void *src, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_os_memdup$descriptor() {
        return ecs_os_memdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_os_memdup(const void *src, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_os_memdup$handle() {
        return ecs_os_memdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_os_memdup(const void *src, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_os_memdup$address() {
        return ecs_os_memdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_os_memdup(const void *src, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_os_memdup(MemorySegment src, int size) {
        var mh$ = ecs_os_memdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_memdup", src, size);
            }
            return (MemorySegment)mh$.invokeExact(src, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_has_heap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_has_heap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_heap()
     * }
     */
    public static FunctionDescriptor ecs_os_has_heap$descriptor() {
        return ecs_os_has_heap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_heap()
     * }
     */
    public static MethodHandle ecs_os_has_heap$handle() {
        return ecs_os_has_heap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_heap()
     * }
     */
    public static MemorySegment ecs_os_has_heap$address() {
        return ecs_os_has_heap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_os_has_heap()
     * }
     */
    public static boolean ecs_os_has_heap() {
        var mh$ = ecs_os_has_heap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_has_heap");
            }
            return (boolean)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_has_threading {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_has_threading");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_threading()
     * }
     */
    public static FunctionDescriptor ecs_os_has_threading$descriptor() {
        return ecs_os_has_threading.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_threading()
     * }
     */
    public static MethodHandle ecs_os_has_threading$handle() {
        return ecs_os_has_threading.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_threading()
     * }
     */
    public static MemorySegment ecs_os_has_threading$address() {
        return ecs_os_has_threading.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_os_has_threading()
     * }
     */
    public static boolean ecs_os_has_threading() {
        var mh$ = ecs_os_has_threading.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_has_threading");
            }
            return (boolean)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_has_task_support {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_has_task_support");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_task_support()
     * }
     */
    public static FunctionDescriptor ecs_os_has_task_support$descriptor() {
        return ecs_os_has_task_support.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_task_support()
     * }
     */
    public static MethodHandle ecs_os_has_task_support$handle() {
        return ecs_os_has_task_support.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_task_support()
     * }
     */
    public static MemorySegment ecs_os_has_task_support$address() {
        return ecs_os_has_task_support.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_os_has_task_support()
     * }
     */
    public static boolean ecs_os_has_task_support() {
        var mh$ = ecs_os_has_task_support.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_has_task_support");
            }
            return (boolean)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_has_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_has_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_time()
     * }
     */
    public static FunctionDescriptor ecs_os_has_time$descriptor() {
        return ecs_os_has_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_time()
     * }
     */
    public static MethodHandle ecs_os_has_time$handle() {
        return ecs_os_has_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_time()
     * }
     */
    public static MemorySegment ecs_os_has_time$address() {
        return ecs_os_has_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_os_has_time()
     * }
     */
    public static boolean ecs_os_has_time() {
        var mh$ = ecs_os_has_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_has_time");
            }
            return (boolean)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_has_logging {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_has_logging");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_logging()
     * }
     */
    public static FunctionDescriptor ecs_os_has_logging$descriptor() {
        return ecs_os_has_logging.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_logging()
     * }
     */
    public static MethodHandle ecs_os_has_logging$handle() {
        return ecs_os_has_logging.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_logging()
     * }
     */
    public static MemorySegment ecs_os_has_logging$address() {
        return ecs_os_has_logging.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_os_has_logging()
     * }
     */
    public static boolean ecs_os_has_logging() {
        var mh$ = ecs_os_has_logging.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_has_logging");
            }
            return (boolean)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_has_dl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_has_dl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_dl()
     * }
     */
    public static FunctionDescriptor ecs_os_has_dl$descriptor() {
        return ecs_os_has_dl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_dl()
     * }
     */
    public static MethodHandle ecs_os_has_dl$handle() {
        return ecs_os_has_dl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_dl()
     * }
     */
    public static MemorySegment ecs_os_has_dl$address() {
        return ecs_os_has_dl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_os_has_dl()
     * }
     */
    public static boolean ecs_os_has_dl() {
        var mh$ = ecs_os_has_dl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_has_dl");
            }
            return (boolean)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_has_modules {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_os_has_modules");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_modules()
     * }
     */
    public static FunctionDescriptor ecs_os_has_modules$descriptor() {
        return ecs_os_has_modules.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_modules()
     * }
     */
    public static MethodHandle ecs_os_has_modules$handle() {
        return ecs_os_has_modules.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_os_has_modules()
     * }
     */
    public static MemorySegment ecs_os_has_modules$address() {
        return ecs_os_has_modules.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_os_has_modules()
     * }
     */
    public static boolean ecs_os_has_modules() {
        var mh$ = ecs_os_has_modules.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_has_modules");
            }
            return (boolean)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int EcsInOutDefault = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ecs_inout_kind_t.EcsInOutDefault = 0
     * }
     */
    public static int EcsInOutDefault() {
        return EcsInOutDefault;
    }
    private static final int EcsInOutNone = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ecs_inout_kind_t.EcsInOutNone = 1
     * }
     */
    public static int EcsInOutNone() {
        return EcsInOutNone;
    }
    private static final int EcsInOutFilter = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ecs_inout_kind_t.EcsInOutFilter = 2
     * }
     */
    public static int EcsInOutFilter() {
        return EcsInOutFilter;
    }
    private static final int EcsInOut = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ecs_inout_kind_t.EcsInOut = 3
     * }
     */
    public static int EcsInOut() {
        return EcsInOut;
    }
    private static final int EcsIn = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ecs_inout_kind_t.EcsIn = 4
     * }
     */
    public static int EcsIn() {
        return EcsIn;
    }
    private static final int EcsOut = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ecs_inout_kind_t.EcsOut = 5
     * }
     */
    public static int EcsOut() {
        return EcsOut;
    }
    private static final int EcsAnd = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ecs_oper_kind_t.EcsAnd = 0
     * }
     */
    public static int EcsAnd() {
        return EcsAnd;
    }
    private static final int EcsOr = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ecs_oper_kind_t.EcsOr = 1
     * }
     */
    public static int EcsOr() {
        return EcsOr;
    }
    private static final int EcsNot = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ecs_oper_kind_t.EcsNot = 2
     * }
     */
    public static int EcsNot() {
        return EcsNot;
    }
    private static final int EcsOptional = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ecs_oper_kind_t.EcsOptional = 3
     * }
     */
    public static int EcsOptional() {
        return EcsOptional;
    }
    private static final int EcsAndFrom = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ecs_oper_kind_t.EcsAndFrom = 4
     * }
     */
    public static int EcsAndFrom() {
        return EcsAndFrom;
    }
    private static final int EcsOrFrom = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ecs_oper_kind_t.EcsOrFrom = 5
     * }
     */
    public static int EcsOrFrom() {
        return EcsOrFrom;
    }
    private static final int EcsNotFrom = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ecs_oper_kind_t.EcsNotFrom = 6
     * }
     */
    public static int EcsNotFrom() {
        return EcsNotFrom;
    }
    private static final int EcsQueryCacheDefault = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ecs_query_cache_kind_t.EcsQueryCacheDefault = 0
     * }
     */
    public static int EcsQueryCacheDefault() {
        return EcsQueryCacheDefault;
    }
    private static final int EcsQueryCacheAuto = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ecs_query_cache_kind_t.EcsQueryCacheAuto = 1
     * }
     */
    public static int EcsQueryCacheAuto() {
        return EcsQueryCacheAuto;
    }
    private static final int EcsQueryCacheAll = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ecs_query_cache_kind_t.EcsQueryCacheAll = 2
     * }
     */
    public static int EcsQueryCacheAll() {
        return EcsQueryCacheAll;
    }
    private static final int EcsQueryCacheNone = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ecs_query_cache_kind_t.EcsQueryCacheNone = 3
     * }
     */
    public static int EcsQueryCacheNone() {
        return EcsQueryCacheNone;
    }

    private static class flecs_module_path_from_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_module_path_from_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *flecs_module_path_from_c(const char *c_name)
     * }
     */
    public static FunctionDescriptor flecs_module_path_from_c$descriptor() {
        return flecs_module_path_from_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *flecs_module_path_from_c(const char *c_name)
     * }
     */
    public static MethodHandle flecs_module_path_from_c$handle() {
        return flecs_module_path_from_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *flecs_module_path_from_c(const char *c_name)
     * }
     */
    public static MemorySegment flecs_module_path_from_c$address() {
        return flecs_module_path_from_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *flecs_module_path_from_c(const char *c_name)
     * }
     */
    public static MemorySegment flecs_module_path_from_c(MemorySegment c_name) {
        var mh$ = flecs_module_path_from_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_module_path_from_c", c_name);
            }
            return (MemorySegment)mh$.invokeExact(c_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_default_ctor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_default_ctor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_default_ctor(void *ptr, int32_t count, const ecs_type_info_t *type_info)
     * }
     */
    public static FunctionDescriptor flecs_default_ctor$descriptor() {
        return flecs_default_ctor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_default_ctor(void *ptr, int32_t count, const ecs_type_info_t *type_info)
     * }
     */
    public static MethodHandle flecs_default_ctor$handle() {
        return flecs_default_ctor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_default_ctor(void *ptr, int32_t count, const ecs_type_info_t *type_info)
     * }
     */
    public static MemorySegment flecs_default_ctor$address() {
        return flecs_default_ctor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_default_ctor(void *ptr, int32_t count, const ecs_type_info_t *type_info)
     * }
     */
    public static void flecs_default_ctor(MemorySegment ptr, int count, MemorySegment type_info) {
        var mh$ = flecs_default_ctor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_default_ctor", ptr, count, type_info);
            }
            mh$.invokeExact(ptr, count, type_info);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_vasprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_vasprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *flecs_vasprintf(const char *fmt, va_list args)
     * }
     */
    public static FunctionDescriptor flecs_vasprintf$descriptor() {
        return flecs_vasprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *flecs_vasprintf(const char *fmt, va_list args)
     * }
     */
    public static MethodHandle flecs_vasprintf$handle() {
        return flecs_vasprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *flecs_vasprintf(const char *fmt, va_list args)
     * }
     */
    public static MemorySegment flecs_vasprintf$address() {
        return flecs_vasprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *flecs_vasprintf(const char *fmt, va_list args)
     * }
     */
    public static MemorySegment flecs_vasprintf(MemorySegment fmt, MemorySegment args) {
        var mh$ = flecs_vasprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_vasprintf", fmt, args);
            }
            return (MemorySegment)mh$.invokeExact(fmt, args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * char *flecs_asprintf(const char *fmt, ...)
     * }
     */
    public static class flecs_asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                flecs_h.C_POINTER,
                flecs_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private flecs_asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * char *flecs_asprintf(const char *fmt, ...)
         * }
         */
        public static flecs_asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new flecs_asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment fmt, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("flecs_asprintf", fmt, x1);
                }
                return (MemorySegment) spreader.invokeExact(fmt, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class flecs_chresc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_CHAR,
            flecs_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_chresc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *flecs_chresc(char *out, char in, char delimiter)
     * }
     */
    public static FunctionDescriptor flecs_chresc$descriptor() {
        return flecs_chresc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *flecs_chresc(char *out, char in, char delimiter)
     * }
     */
    public static MethodHandle flecs_chresc$handle() {
        return flecs_chresc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *flecs_chresc(char *out, char in, char delimiter)
     * }
     */
    public static MemorySegment flecs_chresc$address() {
        return flecs_chresc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *flecs_chresc(char *out, char in, char delimiter)
     * }
     */
    public static MemorySegment flecs_chresc(MemorySegment out, byte in, byte delimiter) {
        var mh$ = flecs_chresc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_chresc", out, in, delimiter);
            }
            return (MemorySegment)mh$.invokeExact(out, in, delimiter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_chrparse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_chrparse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *flecs_chrparse(const char *in, char *out)
     * }
     */
    public static FunctionDescriptor flecs_chrparse$descriptor() {
        return flecs_chrparse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *flecs_chrparse(const char *in, char *out)
     * }
     */
    public static MethodHandle flecs_chrparse$handle() {
        return flecs_chrparse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *flecs_chrparse(const char *in, char *out)
     * }
     */
    public static MemorySegment flecs_chrparse$address() {
        return flecs_chrparse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *flecs_chrparse(const char *in, char *out)
     * }
     */
    public static MemorySegment flecs_chrparse(MemorySegment in, MemorySegment out) {
        var mh$ = flecs_chrparse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_chrparse", in, out);
            }
            return (MemorySegment)mh$.invokeExact(in, out);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stresc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_CHAR,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_stresc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_size_t flecs_stresc(char *out, ecs_size_t size, char delimiter, const char *in)
     * }
     */
    public static FunctionDescriptor flecs_stresc$descriptor() {
        return flecs_stresc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_size_t flecs_stresc(char *out, ecs_size_t size, char delimiter, const char *in)
     * }
     */
    public static MethodHandle flecs_stresc$handle() {
        return flecs_stresc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_size_t flecs_stresc(char *out, ecs_size_t size, char delimiter, const char *in)
     * }
     */
    public static MemorySegment flecs_stresc$address() {
        return flecs_stresc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_size_t flecs_stresc(char *out, ecs_size_t size, char delimiter, const char *in)
     * }
     */
    public static int flecs_stresc(MemorySegment out, int size, byte delimiter, MemorySegment in) {
        var mh$ = flecs_stresc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stresc", out, size, delimiter, in);
            }
            return (int)mh$.invokeExact(out, size, delimiter, in);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_astresc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_CHAR,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_astresc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *flecs_astresc(char delimiter, const char *in)
     * }
     */
    public static FunctionDescriptor flecs_astresc$descriptor() {
        return flecs_astresc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *flecs_astresc(char delimiter, const char *in)
     * }
     */
    public static MethodHandle flecs_astresc$handle() {
        return flecs_astresc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *flecs_astresc(char delimiter, const char *in)
     * }
     */
    public static MemorySegment flecs_astresc$address() {
        return flecs_astresc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *flecs_astresc(char delimiter, const char *in)
     * }
     */
    public static MemorySegment flecs_astresc(byte delimiter, MemorySegment in) {
        var mh$ = flecs_astresc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_astresc", delimiter, in);
            }
            return (MemorySegment)mh$.invokeExact(delimiter, in);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_parse_ws_eol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_parse_ws_eol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *flecs_parse_ws_eol(const char *ptr)
     * }
     */
    public static FunctionDescriptor flecs_parse_ws_eol$descriptor() {
        return flecs_parse_ws_eol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *flecs_parse_ws_eol(const char *ptr)
     * }
     */
    public static MethodHandle flecs_parse_ws_eol$handle() {
        return flecs_parse_ws_eol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *flecs_parse_ws_eol(const char *ptr)
     * }
     */
    public static MemorySegment flecs_parse_ws_eol$address() {
        return flecs_parse_ws_eol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *flecs_parse_ws_eol(const char *ptr)
     * }
     */
    public static MemorySegment flecs_parse_ws_eol(MemorySegment ptr) {
        var mh$ = flecs_parse_ws_eol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_parse_ws_eol", ptr);
            }
            return (MemorySegment)mh$.invokeExact(ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_parse_digit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_parse_digit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *flecs_parse_digit(const char *ptr, char *token)
     * }
     */
    public static FunctionDescriptor flecs_parse_digit$descriptor() {
        return flecs_parse_digit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *flecs_parse_digit(const char *ptr, char *token)
     * }
     */
    public static MethodHandle flecs_parse_digit$handle() {
        return flecs_parse_digit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *flecs_parse_digit(const char *ptr, char *token)
     * }
     */
    public static MemorySegment flecs_parse_digit$address() {
        return flecs_parse_digit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *flecs_parse_digit(const char *ptr, char *token)
     * }
     */
    public static MemorySegment flecs_parse_digit(MemorySegment ptr, MemorySegment token) {
        var mh$ = flecs_parse_digit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_parse_digit", ptr, token);
            }
            return (MemorySegment)mh$.invokeExact(ptr, token);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_to_snake_case {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_to_snake_case");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *flecs_to_snake_case(const char *str)
     * }
     */
    public static FunctionDescriptor flecs_to_snake_case$descriptor() {
        return flecs_to_snake_case.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *flecs_to_snake_case(const char *str)
     * }
     */
    public static MethodHandle flecs_to_snake_case$handle() {
        return flecs_to_snake_case.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *flecs_to_snake_case(const char *str)
     * }
     */
    public static MemorySegment flecs_to_snake_case$address() {
        return flecs_to_snake_case.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *flecs_to_snake_case(const char *str)
     * }
     */
    public static MemorySegment flecs_to_snake_case(MemorySegment str) {
        var mh$ = flecs_to_snake_case.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_to_snake_case", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_suspend_readonly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_suspend_readonly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_world_t *flecs_suspend_readonly(const ecs_world_t *world, ecs_suspend_readonly_state_t *state)
     * }
     */
    public static FunctionDescriptor flecs_suspend_readonly$descriptor() {
        return flecs_suspend_readonly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_world_t *flecs_suspend_readonly(const ecs_world_t *world, ecs_suspend_readonly_state_t *state)
     * }
     */
    public static MethodHandle flecs_suspend_readonly$handle() {
        return flecs_suspend_readonly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_world_t *flecs_suspend_readonly(const ecs_world_t *world, ecs_suspend_readonly_state_t *state)
     * }
     */
    public static MemorySegment flecs_suspend_readonly$address() {
        return flecs_suspend_readonly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_world_t *flecs_suspend_readonly(const ecs_world_t *world, ecs_suspend_readonly_state_t *state)
     * }
     */
    public static MemorySegment flecs_suspend_readonly(MemorySegment world, MemorySegment state) {
        var mh$ = flecs_suspend_readonly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_suspend_readonly", world, state);
            }
            return (MemorySegment)mh$.invokeExact(world, state);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_resume_readonly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_resume_readonly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_resume_readonly(ecs_world_t *world, ecs_suspend_readonly_state_t *state)
     * }
     */
    public static FunctionDescriptor flecs_resume_readonly$descriptor() {
        return flecs_resume_readonly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_resume_readonly(ecs_world_t *world, ecs_suspend_readonly_state_t *state)
     * }
     */
    public static MethodHandle flecs_resume_readonly$handle() {
        return flecs_resume_readonly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_resume_readonly(ecs_world_t *world, ecs_suspend_readonly_state_t *state)
     * }
     */
    public static MemorySegment flecs_resume_readonly$address() {
        return flecs_resume_readonly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_resume_readonly(ecs_world_t *world, ecs_suspend_readonly_state_t *state)
     * }
     */
    public static void flecs_resume_readonly(MemorySegment world, MemorySegment state) {
        var mh$ = flecs_resume_readonly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_resume_readonly", world, state);
            }
            mh$.invokeExact(world, state);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_table_observed_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_table_observed_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t flecs_table_observed_count(const ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor flecs_table_observed_count$descriptor() {
        return flecs_table_observed_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t flecs_table_observed_count(const ecs_table_t *table)
     * }
     */
    public static MethodHandle flecs_table_observed_count$handle() {
        return flecs_table_observed_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t flecs_table_observed_count(const ecs_table_t *table)
     * }
     */
    public static MemorySegment flecs_table_observed_count$address() {
        return flecs_table_observed_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t flecs_table_observed_count(const ecs_table_t *table)
     * }
     */
    public static int flecs_table_observed_count(MemorySegment table) {
        var mh$ = flecs_table_observed_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_table_observed_count", table);
            }
            return (int)mh$.invokeExact(table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_dump_backtrace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_dump_backtrace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_dump_backtrace(void *stream)
     * }
     */
    public static FunctionDescriptor flecs_dump_backtrace$descriptor() {
        return flecs_dump_backtrace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_dump_backtrace(void *stream)
     * }
     */
    public static MethodHandle flecs_dump_backtrace$handle() {
        return flecs_dump_backtrace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_dump_backtrace(void *stream)
     * }
     */
    public static MemorySegment flecs_dump_backtrace$address() {
        return flecs_dump_backtrace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_dump_backtrace(void *stream)
     * }
     */
    public static void flecs_dump_backtrace(MemorySegment stream) {
        var mh$ = flecs_dump_backtrace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_dump_backtrace", stream);
            }
            mh$.invokeExact(stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_poly_claim_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_poly_claim_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t flecs_poly_claim_(ecs_poly_t *poly)
     * }
     */
    public static FunctionDescriptor flecs_poly_claim_$descriptor() {
        return flecs_poly_claim_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t flecs_poly_claim_(ecs_poly_t *poly)
     * }
     */
    public static MethodHandle flecs_poly_claim_$handle() {
        return flecs_poly_claim_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t flecs_poly_claim_(ecs_poly_t *poly)
     * }
     */
    public static MemorySegment flecs_poly_claim_$address() {
        return flecs_poly_claim_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t flecs_poly_claim_(ecs_poly_t *poly)
     * }
     */
    public static int flecs_poly_claim_(MemorySegment poly) {
        var mh$ = flecs_poly_claim_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_poly_claim_", poly);
            }
            return (int)mh$.invokeExact(poly);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_poly_release_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_poly_release_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t flecs_poly_release_(ecs_poly_t *poly)
     * }
     */
    public static FunctionDescriptor flecs_poly_release_$descriptor() {
        return flecs_poly_release_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t flecs_poly_release_(ecs_poly_t *poly)
     * }
     */
    public static MethodHandle flecs_poly_release_$handle() {
        return flecs_poly_release_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t flecs_poly_release_(ecs_poly_t *poly)
     * }
     */
    public static MemorySegment flecs_poly_release_$address() {
        return flecs_poly_release_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t flecs_poly_release_(ecs_poly_t *poly)
     * }
     */
    public static int flecs_poly_release_(MemorySegment poly) {
        var mh$ = flecs_poly_release_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_poly_release_", poly);
            }
            return (int)mh$.invokeExact(poly);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_poly_refcount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_poly_refcount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t flecs_poly_refcount(ecs_poly_t *poly)
     * }
     */
    public static FunctionDescriptor flecs_poly_refcount$descriptor() {
        return flecs_poly_refcount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t flecs_poly_refcount(ecs_poly_t *poly)
     * }
     */
    public static MethodHandle flecs_poly_refcount$handle() {
        return flecs_poly_refcount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t flecs_poly_refcount(ecs_poly_t *poly)
     * }
     */
    public static MemorySegment flecs_poly_refcount$address() {
        return flecs_poly_refcount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t flecs_poly_refcount(ecs_poly_t *poly)
     * }
     */
    public static int flecs_poly_refcount(MemorySegment poly) {
        var mh$ = flecs_poly_refcount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_poly_refcount", poly);
            }
            return (int)mh$.invokeExact(poly);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_component_ids_index_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_component_ids_index_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t flecs_component_ids_index_get()
     * }
     */
    public static FunctionDescriptor flecs_component_ids_index_get$descriptor() {
        return flecs_component_ids_index_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t flecs_component_ids_index_get()
     * }
     */
    public static MethodHandle flecs_component_ids_index_get$handle() {
        return flecs_component_ids_index_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t flecs_component_ids_index_get()
     * }
     */
    public static MemorySegment flecs_component_ids_index_get$address() {
        return flecs_component_ids_index_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t flecs_component_ids_index_get()
     * }
     */
    public static int flecs_component_ids_index_get() {
        var mh$ = flecs_component_ids_index_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_component_ids_index_get");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_component_ids_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_component_ids_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t flecs_component_ids_get(const ecs_world_t *world, int32_t index)
     * }
     */
    public static FunctionDescriptor flecs_component_ids_get$descriptor() {
        return flecs_component_ids_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t flecs_component_ids_get(const ecs_world_t *world, int32_t index)
     * }
     */
    public static MethodHandle flecs_component_ids_get$handle() {
        return flecs_component_ids_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t flecs_component_ids_get(const ecs_world_t *world, int32_t index)
     * }
     */
    public static MemorySegment flecs_component_ids_get$address() {
        return flecs_component_ids_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t flecs_component_ids_get(const ecs_world_t *world, int32_t index)
     * }
     */
    public static long flecs_component_ids_get(MemorySegment world, int index) {
        var mh$ = flecs_component_ids_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_component_ids_get", world, index);
            }
            return (long)mh$.invokeExact(world, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_component_ids_get_alive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_component_ids_get_alive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t flecs_component_ids_get_alive(const ecs_world_t *world, int32_t index)
     * }
     */
    public static FunctionDescriptor flecs_component_ids_get_alive$descriptor() {
        return flecs_component_ids_get_alive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t flecs_component_ids_get_alive(const ecs_world_t *world, int32_t index)
     * }
     */
    public static MethodHandle flecs_component_ids_get_alive$handle() {
        return flecs_component_ids_get_alive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t flecs_component_ids_get_alive(const ecs_world_t *world, int32_t index)
     * }
     */
    public static MemorySegment flecs_component_ids_get_alive$address() {
        return flecs_component_ids_get_alive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t flecs_component_ids_get_alive(const ecs_world_t *world, int32_t index)
     * }
     */
    public static long flecs_component_ids_get_alive(MemorySegment world, int index) {
        var mh$ = flecs_component_ids_get_alive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_component_ids_get_alive", world, index);
            }
            return (long)mh$.invokeExact(world, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_component_ids_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_component_ids_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_component_ids_set(ecs_world_t *world, int32_t index, ecs_entity_t id)
     * }
     */
    public static FunctionDescriptor flecs_component_ids_set$descriptor() {
        return flecs_component_ids_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_component_ids_set(ecs_world_t *world, int32_t index, ecs_entity_t id)
     * }
     */
    public static MethodHandle flecs_component_ids_set$handle() {
        return flecs_component_ids_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_component_ids_set(ecs_world_t *world, int32_t index, ecs_entity_t id)
     * }
     */
    public static MemorySegment flecs_component_ids_set$address() {
        return flecs_component_ids_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_component_ids_set(ecs_world_t *world, int32_t index, ecs_entity_t id)
     * }
     */
    public static void flecs_component_ids_set(MemorySegment world, int index, long id) {
        var mh$ = flecs_component_ids_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_component_ids_set", world, index, id);
            }
            mh$.invokeExact(world, index, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_query_trivial_cached_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_query_trivial_cached_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool flecs_query_trivial_cached_next(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor flecs_query_trivial_cached_next$descriptor() {
        return flecs_query_trivial_cached_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool flecs_query_trivial_cached_next(ecs_iter_t *it)
     * }
     */
    public static MethodHandle flecs_query_trivial_cached_next$handle() {
        return flecs_query_trivial_cached_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool flecs_query_trivial_cached_next(ecs_iter_t *it)
     * }
     */
    public static MemorySegment flecs_query_trivial_cached_next$address() {
        return flecs_query_trivial_cached_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool flecs_query_trivial_cached_next(ecs_iter_t *it)
     * }
     */
    public static boolean flecs_query_trivial_cached_next(MemorySegment it) {
        var mh$ = flecs_query_trivial_cached_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_query_trivial_cached_next", it);
            }
            return (boolean)mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_check_exclusive_world_access_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_check_exclusive_world_access_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_check_exclusive_world_access_write(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor flecs_check_exclusive_world_access_write$descriptor() {
        return flecs_check_exclusive_world_access_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_check_exclusive_world_access_write(const ecs_world_t *world)
     * }
     */
    public static MethodHandle flecs_check_exclusive_world_access_write$handle() {
        return flecs_check_exclusive_world_access_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_check_exclusive_world_access_write(const ecs_world_t *world)
     * }
     */
    public static MemorySegment flecs_check_exclusive_world_access_write$address() {
        return flecs_check_exclusive_world_access_write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_check_exclusive_world_access_write(const ecs_world_t *world)
     * }
     */
    public static void flecs_check_exclusive_world_access_write(MemorySegment world) {
        var mh$ = flecs_check_exclusive_world_access_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_check_exclusive_world_access_write", world);
            }
            mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_check_exclusive_world_access_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_check_exclusive_world_access_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_check_exclusive_world_access_read(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor flecs_check_exclusive_world_access_read$descriptor() {
        return flecs_check_exclusive_world_access_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_check_exclusive_world_access_read(const ecs_world_t *world)
     * }
     */
    public static MethodHandle flecs_check_exclusive_world_access_read$handle() {
        return flecs_check_exclusive_world_access_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_check_exclusive_world_access_read(const ecs_world_t *world)
     * }
     */
    public static MemorySegment flecs_check_exclusive_world_access_read$address() {
        return flecs_check_exclusive_world_access_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_check_exclusive_world_access_read(const ecs_world_t *world)
     * }
     */
    public static void flecs_check_exclusive_world_access_read(MemorySegment world) {
        var mh$ = flecs_check_exclusive_world_access_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_check_exclusive_world_access_read", world);
            }
            mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_init_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_hashmap_init_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_hashmap_init_(ecs_hashmap_t *hm, ecs_size_t key_size, ecs_size_t value_size, ecs_hash_value_action_t hash, ecs_compare_action_t compare, ecs_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_init_$descriptor() {
        return flecs_hashmap_init_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_hashmap_init_(ecs_hashmap_t *hm, ecs_size_t key_size, ecs_size_t value_size, ecs_hash_value_action_t hash, ecs_compare_action_t compare, ecs_allocator_t *allocator)
     * }
     */
    public static MethodHandle flecs_hashmap_init_$handle() {
        return flecs_hashmap_init_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_hashmap_init_(ecs_hashmap_t *hm, ecs_size_t key_size, ecs_size_t value_size, ecs_hash_value_action_t hash, ecs_compare_action_t compare, ecs_allocator_t *allocator)
     * }
     */
    public static MemorySegment flecs_hashmap_init_$address() {
        return flecs_hashmap_init_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_hashmap_init_(ecs_hashmap_t *hm, ecs_size_t key_size, ecs_size_t value_size, ecs_hash_value_action_t hash, ecs_compare_action_t compare, ecs_allocator_t *allocator)
     * }
     */
    public static void flecs_hashmap_init_(MemorySegment hm, int key_size, int value_size, MemorySegment hash, MemorySegment compare, MemorySegment allocator) {
        var mh$ = flecs_hashmap_init_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_init_", hm, key_size, value_size, hash, compare, allocator);
            }
            mh$.invokeExact(hm, key_size, value_size, hash, compare, allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_hashmap_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_hashmap_fini(ecs_hashmap_t *map)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_fini$descriptor() {
        return flecs_hashmap_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_hashmap_fini(ecs_hashmap_t *map)
     * }
     */
    public static MethodHandle flecs_hashmap_fini$handle() {
        return flecs_hashmap_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_hashmap_fini(ecs_hashmap_t *map)
     * }
     */
    public static MemorySegment flecs_hashmap_fini$address() {
        return flecs_hashmap_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_hashmap_fini(ecs_hashmap_t *map)
     * }
     */
    public static void flecs_hashmap_fini(MemorySegment map) {
        var mh$ = flecs_hashmap_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_fini", map);
            }
            mh$.invokeExact(map);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_get_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_hashmap_get_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_hashmap_get_(const ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_get_$descriptor() {
        return flecs_hashmap_get_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_hashmap_get_(const ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static MethodHandle flecs_hashmap_get_$handle() {
        return flecs_hashmap_get_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_hashmap_get_(const ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static MemorySegment flecs_hashmap_get_$address() {
        return flecs_hashmap_get_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_hashmap_get_(const ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static MemorySegment flecs_hashmap_get_(MemorySegment map, int key_size, MemorySegment key, int value_size) {
        var mh$ = flecs_hashmap_get_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_get_", map, key_size, key, value_size);
            }
            return (MemorySegment)mh$.invokeExact(map, key_size, key, value_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_ensure_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_hashmap_result_t.layout(),
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_hashmap_ensure_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * flecs_hashmap_result_t flecs_hashmap_ensure_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_ensure_$descriptor() {
        return flecs_hashmap_ensure_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * flecs_hashmap_result_t flecs_hashmap_ensure_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static MethodHandle flecs_hashmap_ensure_$handle() {
        return flecs_hashmap_ensure_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * flecs_hashmap_result_t flecs_hashmap_ensure_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static MemorySegment flecs_hashmap_ensure_$address() {
        return flecs_hashmap_ensure_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * flecs_hashmap_result_t flecs_hashmap_ensure_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static MemorySegment flecs_hashmap_ensure_(SegmentAllocator allocator, MemorySegment map, int key_size, MemorySegment key, int value_size) {
        var mh$ = flecs_hashmap_ensure_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_ensure_", allocator, map, key_size, key, value_size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, map, key_size, key, value_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_set_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_hashmap_set_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_hashmap_set_(ecs_hashmap_t *map, ecs_size_t key_size, void *key, ecs_size_t value_size, const void *value)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_set_$descriptor() {
        return flecs_hashmap_set_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_hashmap_set_(ecs_hashmap_t *map, ecs_size_t key_size, void *key, ecs_size_t value_size, const void *value)
     * }
     */
    public static MethodHandle flecs_hashmap_set_$handle() {
        return flecs_hashmap_set_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_hashmap_set_(ecs_hashmap_t *map, ecs_size_t key_size, void *key, ecs_size_t value_size, const void *value)
     * }
     */
    public static MemorySegment flecs_hashmap_set_$address() {
        return flecs_hashmap_set_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_hashmap_set_(ecs_hashmap_t *map, ecs_size_t key_size, void *key, ecs_size_t value_size, const void *value)
     * }
     */
    public static void flecs_hashmap_set_(MemorySegment map, int key_size, MemorySegment key, int value_size, MemorySegment value) {
        var mh$ = flecs_hashmap_set_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_set_", map, key_size, key, value_size, value);
            }
            mh$.invokeExact(map, key_size, key, value_size, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_remove_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_hashmap_remove_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_hashmap_remove_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_remove_$descriptor() {
        return flecs_hashmap_remove_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_hashmap_remove_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static MethodHandle flecs_hashmap_remove_$handle() {
        return flecs_hashmap_remove_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_hashmap_remove_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static MemorySegment flecs_hashmap_remove_$address() {
        return flecs_hashmap_remove_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_hashmap_remove_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static void flecs_hashmap_remove_(MemorySegment map, int key_size, MemorySegment key, int value_size) {
        var mh$ = flecs_hashmap_remove_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_remove_", map, key_size, key, value_size);
            }
            mh$.invokeExact(map, key_size, key, value_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_remove_w_hash_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_hashmap_remove_w_hash_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_hashmap_remove_w_hash_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size, uint64_t hash)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_remove_w_hash_$descriptor() {
        return flecs_hashmap_remove_w_hash_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_hashmap_remove_w_hash_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size, uint64_t hash)
     * }
     */
    public static MethodHandle flecs_hashmap_remove_w_hash_$handle() {
        return flecs_hashmap_remove_w_hash_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_hashmap_remove_w_hash_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size, uint64_t hash)
     * }
     */
    public static MemorySegment flecs_hashmap_remove_w_hash_$address() {
        return flecs_hashmap_remove_w_hash_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_hashmap_remove_w_hash_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size, uint64_t hash)
     * }
     */
    public static void flecs_hashmap_remove_w_hash_(MemorySegment map, int key_size, MemorySegment key, int value_size, long hash) {
        var mh$ = flecs_hashmap_remove_w_hash_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_remove_w_hash_", map, key_size, key, value_size, hash);
            }
            mh$.invokeExact(map, key_size, key, value_size, hash);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_get_bucket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_hashmap_get_bucket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_hm_bucket_t *flecs_hashmap_get_bucket(const ecs_hashmap_t *map, uint64_t hash)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_get_bucket$descriptor() {
        return flecs_hashmap_get_bucket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_hm_bucket_t *flecs_hashmap_get_bucket(const ecs_hashmap_t *map, uint64_t hash)
     * }
     */
    public static MethodHandle flecs_hashmap_get_bucket$handle() {
        return flecs_hashmap_get_bucket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_hm_bucket_t *flecs_hashmap_get_bucket(const ecs_hashmap_t *map, uint64_t hash)
     * }
     */
    public static MemorySegment flecs_hashmap_get_bucket$address() {
        return flecs_hashmap_get_bucket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_hm_bucket_t *flecs_hashmap_get_bucket(const ecs_hashmap_t *map, uint64_t hash)
     * }
     */
    public static MemorySegment flecs_hashmap_get_bucket(MemorySegment map, long hash) {
        var mh$ = flecs_hashmap_get_bucket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_get_bucket", map, hash);
            }
            return (MemorySegment)mh$.invokeExact(map, hash);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hm_bucket_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_hm_bucket_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_hm_bucket_remove(ecs_hashmap_t *map, ecs_hm_bucket_t *bucket, uint64_t hash, int32_t index)
     * }
     */
    public static FunctionDescriptor flecs_hm_bucket_remove$descriptor() {
        return flecs_hm_bucket_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_hm_bucket_remove(ecs_hashmap_t *map, ecs_hm_bucket_t *bucket, uint64_t hash, int32_t index)
     * }
     */
    public static MethodHandle flecs_hm_bucket_remove$handle() {
        return flecs_hm_bucket_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_hm_bucket_remove(ecs_hashmap_t *map, ecs_hm_bucket_t *bucket, uint64_t hash, int32_t index)
     * }
     */
    public static MemorySegment flecs_hm_bucket_remove$address() {
        return flecs_hm_bucket_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_hm_bucket_remove(ecs_hashmap_t *map, ecs_hm_bucket_t *bucket, uint64_t hash, int32_t index)
     * }
     */
    public static void flecs_hm_bucket_remove(MemorySegment map, MemorySegment bucket, long hash, int index) {
        var mh$ = flecs_hm_bucket_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hm_bucket_remove", map, bucket, hash, index);
            }
            mh$.invokeExact(map, bucket, hash, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_hashmap_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_hashmap_copy(ecs_hashmap_t *dst, const ecs_hashmap_t *src)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_copy$descriptor() {
        return flecs_hashmap_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_hashmap_copy(ecs_hashmap_t *dst, const ecs_hashmap_t *src)
     * }
     */
    public static MethodHandle flecs_hashmap_copy$handle() {
        return flecs_hashmap_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_hashmap_copy(ecs_hashmap_t *dst, const ecs_hashmap_t *src)
     * }
     */
    public static MemorySegment flecs_hashmap_copy$address() {
        return flecs_hashmap_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_hashmap_copy(ecs_hashmap_t *dst, const ecs_hashmap_t *src)
     * }
     */
    public static void flecs_hashmap_copy(MemorySegment dst, MemorySegment src) {
        var mh$ = flecs_hashmap_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_copy", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_hashmap_iter_t.layout(),
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_hashmap_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * flecs_hashmap_iter_t flecs_hashmap_iter(ecs_hashmap_t *map)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_iter$descriptor() {
        return flecs_hashmap_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * flecs_hashmap_iter_t flecs_hashmap_iter(ecs_hashmap_t *map)
     * }
     */
    public static MethodHandle flecs_hashmap_iter$handle() {
        return flecs_hashmap_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * flecs_hashmap_iter_t flecs_hashmap_iter(ecs_hashmap_t *map)
     * }
     */
    public static MemorySegment flecs_hashmap_iter$address() {
        return flecs_hashmap_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * flecs_hashmap_iter_t flecs_hashmap_iter(ecs_hashmap_t *map)
     * }
     */
    public static MemorySegment flecs_hashmap_iter(SegmentAllocator allocator, MemorySegment map) {
        var mh$ = flecs_hashmap_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_iter", allocator, map);
            }
            return (MemorySegment)mh$.invokeExact(allocator, map);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_next_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_hashmap_next_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_hashmap_next_(flecs_hashmap_iter_t *it, ecs_size_t key_size, void *key_out, ecs_size_t value_size)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_next_$descriptor() {
        return flecs_hashmap_next_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_hashmap_next_(flecs_hashmap_iter_t *it, ecs_size_t key_size, void *key_out, ecs_size_t value_size)
     * }
     */
    public static MethodHandle flecs_hashmap_next_$handle() {
        return flecs_hashmap_next_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_hashmap_next_(flecs_hashmap_iter_t *it, ecs_size_t key_size, void *key_out, ecs_size_t value_size)
     * }
     */
    public static MemorySegment flecs_hashmap_next_$address() {
        return flecs_hashmap_next_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_hashmap_next_(flecs_hashmap_iter_t *it, ecs_size_t key_size, void *key_out, ecs_size_t value_size)
     * }
     */
    public static MemorySegment flecs_hashmap_next_(MemorySegment it, int key_size, MemorySegment key_out, int value_size) {
        var mh$ = flecs_hashmap_next_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_next_", it, key_size, key_out, value_size);
            }
            return (MemorySegment)mh$.invokeExact(it, key_size, key_out, value_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_record_find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_record_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_record_t *ecs_record_find(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_record_find$descriptor() {
        return ecs_record_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_record_t *ecs_record_find(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_record_find$handle() {
        return ecs_record_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_record_t *ecs_record_find(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_record_find$address() {
        return ecs_record_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_record_t *ecs_record_find(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_record_find(MemorySegment world, long entity) {
        var mh$ = ecs_record_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_record_find", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_record_get_entity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_record_get_entity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_record_get_entity(const ecs_record_t *record)
     * }
     */
    public static FunctionDescriptor ecs_record_get_entity$descriptor() {
        return ecs_record_get_entity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_record_get_entity(const ecs_record_t *record)
     * }
     */
    public static MethodHandle ecs_record_get_entity$handle() {
        return ecs_record_get_entity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_record_get_entity(const ecs_record_t *record)
     * }
     */
    public static MemorySegment ecs_record_get_entity$address() {
        return ecs_record_get_entity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_record_get_entity(const ecs_record_t *record)
     * }
     */
    public static long ecs_record_get_entity(MemorySegment record_) {
        var mh$ = ecs_record_get_entity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_record_get_entity", record_);
            }
            return (long)mh$.invokeExact(record_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_write_begin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_write_begin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_record_t *ecs_write_begin(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_write_begin$descriptor() {
        return ecs_write_begin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_record_t *ecs_write_begin(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_write_begin$handle() {
        return ecs_write_begin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_record_t *ecs_write_begin(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_write_begin$address() {
        return ecs_write_begin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_record_t *ecs_write_begin(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_write_begin(MemorySegment world, long entity) {
        var mh$ = ecs_write_begin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_write_begin", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_write_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_write_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_write_end(ecs_record_t *record)
     * }
     */
    public static FunctionDescriptor ecs_write_end$descriptor() {
        return ecs_write_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_write_end(ecs_record_t *record)
     * }
     */
    public static MethodHandle ecs_write_end$handle() {
        return ecs_write_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_write_end(ecs_record_t *record)
     * }
     */
    public static MemorySegment ecs_write_end$address() {
        return ecs_write_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_write_end(ecs_record_t *record)
     * }
     */
    public static void ecs_write_end(MemorySegment record_) {
        var mh$ = ecs_write_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_write_end", record_);
            }
            mh$.invokeExact(record_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_read_begin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_read_begin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_record_t *ecs_read_begin(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_read_begin$descriptor() {
        return ecs_read_begin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_record_t *ecs_read_begin(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_read_begin$handle() {
        return ecs_read_begin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_record_t *ecs_read_begin(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_read_begin$address() {
        return ecs_read_begin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_record_t *ecs_read_begin(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_read_begin(MemorySegment world, long entity) {
        var mh$ = ecs_read_begin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_read_begin", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_read_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_read_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_read_end(const ecs_record_t *record)
     * }
     */
    public static FunctionDescriptor ecs_read_end$descriptor() {
        return ecs_read_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_read_end(const ecs_record_t *record)
     * }
     */
    public static MethodHandle ecs_read_end$handle() {
        return ecs_read_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_read_end(const ecs_record_t *record)
     * }
     */
    public static MemorySegment ecs_read_end$address() {
        return ecs_read_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_read_end(const ecs_record_t *record)
     * }
     */
    public static void ecs_read_end(MemorySegment record_) {
        var mh$ = ecs_read_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_read_end", record_);
            }
            mh$.invokeExact(record_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_record_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_record_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const void *ecs_record_get_id(const ecs_world_t *world, const ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_record_get_id$descriptor() {
        return ecs_record_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const void *ecs_record_get_id(const ecs_world_t *world, const ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_record_get_id$handle() {
        return ecs_record_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const void *ecs_record_get_id(const ecs_world_t *world, const ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_record_get_id$address() {
        return ecs_record_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const void *ecs_record_get_id(const ecs_world_t *world, const ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_record_get_id(MemorySegment world, MemorySegment record_, long id) {
        var mh$ = ecs_record_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_record_get_id", world, record_, id);
            }
            return (MemorySegment)mh$.invokeExact(world, record_, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_record_ensure_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_record_ensure_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_record_ensure_id(ecs_world_t *world, ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_record_ensure_id$descriptor() {
        return ecs_record_ensure_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_record_ensure_id(ecs_world_t *world, ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_record_ensure_id$handle() {
        return ecs_record_ensure_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_record_ensure_id(ecs_world_t *world, ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_record_ensure_id$address() {
        return ecs_record_ensure_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_record_ensure_id(ecs_world_t *world, ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_record_ensure_id(MemorySegment world, MemorySegment record_, long id) {
        var mh$ = ecs_record_ensure_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_record_ensure_id", world, record_, id);
            }
            return (MemorySegment)mh$.invokeExact(world, record_, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_record_has_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_record_has_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_record_has_id(ecs_world_t *world, const ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_record_has_id$descriptor() {
        return ecs_record_has_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_record_has_id(ecs_world_t *world, const ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_record_has_id$handle() {
        return ecs_record_has_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_record_has_id(ecs_world_t *world, const ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_record_has_id$address() {
        return ecs_record_has_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_record_has_id(ecs_world_t *world, const ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static boolean ecs_record_has_id(MemorySegment world, MemorySegment record_, long id) {
        var mh$ = ecs_record_has_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_record_has_id", world, record_, id);
            }
            return (boolean)mh$.invokeExact(world, record_, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_record_get_by_column {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_record_get_by_column");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_record_get_by_column(const ecs_record_t *record, int32_t column, size_t size)
     * }
     */
    public static FunctionDescriptor ecs_record_get_by_column$descriptor() {
        return ecs_record_get_by_column.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_record_get_by_column(const ecs_record_t *record, int32_t column, size_t size)
     * }
     */
    public static MethodHandle ecs_record_get_by_column$handle() {
        return ecs_record_get_by_column.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_record_get_by_column(const ecs_record_t *record, int32_t column, size_t size)
     * }
     */
    public static MemorySegment ecs_record_get_by_column$address() {
        return ecs_record_get_by_column.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_record_get_by_column(const ecs_record_t *record, int32_t column, size_t size)
     * }
     */
    public static MemorySegment ecs_record_get_by_column(MemorySegment record_, int column, long size) {
        var mh$ = ecs_record_get_by_column.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_record_get_by_column", record_, column, size);
            }
            return (MemorySegment)mh$.invokeExact(record_, column, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_components_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_components_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_component_record_t *flecs_components_get(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor flecs_components_get$descriptor() {
        return flecs_components_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_component_record_t *flecs_components_get(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MethodHandle flecs_components_get$handle() {
        return flecs_components_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_component_record_t *flecs_components_get(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment flecs_components_get$address() {
        return flecs_components_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_component_record_t *flecs_components_get(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment flecs_components_get(MemorySegment world, long id) {
        var mh$ = flecs_components_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_components_get", world, id);
            }
            return (MemorySegment)mh$.invokeExact(world, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_component_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_component_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_id_t flecs_component_get_id(const ecs_component_record_t *cr)
     * }
     */
    public static FunctionDescriptor flecs_component_get_id$descriptor() {
        return flecs_component_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_id_t flecs_component_get_id(const ecs_component_record_t *cr)
     * }
     */
    public static MethodHandle flecs_component_get_id$handle() {
        return flecs_component_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_id_t flecs_component_get_id(const ecs_component_record_t *cr)
     * }
     */
    public static MemorySegment flecs_component_get_id$address() {
        return flecs_component_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_id_t flecs_component_get_id(const ecs_component_record_t *cr)
     * }
     */
    public static long flecs_component_get_id(MemorySegment cr) {
        var mh$ = flecs_component_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_component_get_id", cr);
            }
            return (long)mh$.invokeExact(cr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_component_get_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_component_get_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_flags32_t flecs_component_get_flags(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor flecs_component_get_flags$descriptor() {
        return flecs_component_get_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_flags32_t flecs_component_get_flags(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MethodHandle flecs_component_get_flags$handle() {
        return flecs_component_get_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_flags32_t flecs_component_get_flags(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment flecs_component_get_flags$address() {
        return flecs_component_get_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_flags32_t flecs_component_get_flags(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static int flecs_component_get_flags(MemorySegment world, long id) {
        var mh$ = flecs_component_get_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_component_get_flags", world, id);
            }
            return (int)mh$.invokeExact(world, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_component_get_table {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_component_get_table");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_table_record_t *flecs_component_get_table(const ecs_component_record_t *cr, const ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor flecs_component_get_table$descriptor() {
        return flecs_component_get_table.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_table_record_t *flecs_component_get_table(const ecs_component_record_t *cr, const ecs_table_t *table)
     * }
     */
    public static MethodHandle flecs_component_get_table$handle() {
        return flecs_component_get_table.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_table_record_t *flecs_component_get_table(const ecs_component_record_t *cr, const ecs_table_t *table)
     * }
     */
    public static MemorySegment flecs_component_get_table$address() {
        return flecs_component_get_table.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_table_record_t *flecs_component_get_table(const ecs_component_record_t *cr, const ecs_table_t *table)
     * }
     */
    public static MemorySegment flecs_component_get_table(MemorySegment cr, MemorySegment table) {
        var mh$ = flecs_component_get_table.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_component_get_table", cr, table);
            }
            return (MemorySegment)mh$.invokeExact(cr, table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_component_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_component_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool flecs_component_iter(const ecs_component_record_t *cr, ecs_table_cache_iter_t *iter_out)
     * }
     */
    public static FunctionDescriptor flecs_component_iter$descriptor() {
        return flecs_component_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool flecs_component_iter(const ecs_component_record_t *cr, ecs_table_cache_iter_t *iter_out)
     * }
     */
    public static MethodHandle flecs_component_iter$handle() {
        return flecs_component_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool flecs_component_iter(const ecs_component_record_t *cr, ecs_table_cache_iter_t *iter_out)
     * }
     */
    public static MemorySegment flecs_component_iter$address() {
        return flecs_component_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool flecs_component_iter(const ecs_component_record_t *cr, ecs_table_cache_iter_t *iter_out)
     * }
     */
    public static boolean flecs_component_iter(MemorySegment cr, MemorySegment iter_out) {
        var mh$ = flecs_component_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_component_iter", cr, iter_out);
            }
            return (boolean)mh$.invokeExact(cr, iter_out);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_component_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_component_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_table_record_t *flecs_component_next(ecs_table_cache_iter_t *iter)
     * }
     */
    public static FunctionDescriptor flecs_component_next$descriptor() {
        return flecs_component_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_table_record_t *flecs_component_next(ecs_table_cache_iter_t *iter)
     * }
     */
    public static MethodHandle flecs_component_next$handle() {
        return flecs_component_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_table_record_t *flecs_component_next(ecs_table_cache_iter_t *iter)
     * }
     */
    public static MemorySegment flecs_component_next$address() {
        return flecs_component_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_table_record_t *flecs_component_next(ecs_table_cache_iter_t *iter)
     * }
     */
    public static MemorySegment flecs_component_next(MemorySegment iter) {
        var mh$ = flecs_component_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_component_next", iter);
            }
            return (MemorySegment)mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_table_records {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_table_records_t.layout(),
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_table_records");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_table_records_t flecs_table_records(ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor flecs_table_records$descriptor() {
        return flecs_table_records.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_table_records_t flecs_table_records(ecs_table_t *table)
     * }
     */
    public static MethodHandle flecs_table_records$handle() {
        return flecs_table_records.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_table_records_t flecs_table_records(ecs_table_t *table)
     * }
     */
    public static MemorySegment flecs_table_records$address() {
        return flecs_table_records.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_table_records_t flecs_table_records(ecs_table_t *table)
     * }
     */
    public static MemorySegment flecs_table_records(SegmentAllocator allocator, MemorySegment table) {
        var mh$ = flecs_table_records.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_table_records", allocator, table);
            }
            return (MemorySegment)mh$.invokeExact(allocator, table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_table_record_get_component {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_table_record_get_component");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_component_record_t *flecs_table_record_get_component(const ecs_table_record_t *tr)
     * }
     */
    public static FunctionDescriptor flecs_table_record_get_component$descriptor() {
        return flecs_table_record_get_component.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_component_record_t *flecs_table_record_get_component(const ecs_table_record_t *tr)
     * }
     */
    public static MethodHandle flecs_table_record_get_component$handle() {
        return flecs_table_record_get_component.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_component_record_t *flecs_table_record_get_component(const ecs_table_record_t *tr)
     * }
     */
    public static MemorySegment flecs_table_record_get_component$address() {
        return flecs_table_record_get_component.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_component_record_t *flecs_table_record_get_component(const ecs_table_record_t *tr)
     * }
     */
    public static MemorySegment flecs_table_record_get_component(MemorySegment tr) {
        var mh$ = flecs_table_record_get_component.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_table_record_get_component", tr);
            }
            return (MemorySegment)mh$.invokeExact(tr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_table_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_table_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t flecs_table_id(ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor flecs_table_id$descriptor() {
        return flecs_table_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t flecs_table_id(ecs_table_t *table)
     * }
     */
    public static MethodHandle flecs_table_id$handle() {
        return flecs_table_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t flecs_table_id(ecs_table_t *table)
     * }
     */
    public static MemorySegment flecs_table_id$address() {
        return flecs_table_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t flecs_table_id(ecs_table_t *table)
     * }
     */
    public static long flecs_table_id(MemorySegment table) {
        var mh$ = flecs_table_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_table_id", table);
            }
            return (long)mh$.invokeExact(table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_table_traverse_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_table_traverse_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_table_t *flecs_table_traverse_add(ecs_world_t *world, ecs_table_t *table, ecs_id_t *id_ptr, ecs_table_diff_t *diff)
     * }
     */
    public static FunctionDescriptor flecs_table_traverse_add$descriptor() {
        return flecs_table_traverse_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_table_t *flecs_table_traverse_add(ecs_world_t *world, ecs_table_t *table, ecs_id_t *id_ptr, ecs_table_diff_t *diff)
     * }
     */
    public static MethodHandle flecs_table_traverse_add$handle() {
        return flecs_table_traverse_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_table_t *flecs_table_traverse_add(ecs_world_t *world, ecs_table_t *table, ecs_id_t *id_ptr, ecs_table_diff_t *diff)
     * }
     */
    public static MemorySegment flecs_table_traverse_add$address() {
        return flecs_table_traverse_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_table_t *flecs_table_traverse_add(ecs_world_t *world, ecs_table_t *table, ecs_id_t *id_ptr, ecs_table_diff_t *diff)
     * }
     */
    public static MemorySegment flecs_table_traverse_add(MemorySegment world, MemorySegment table, MemorySegment id_ptr, MemorySegment diff) {
        var mh$ = flecs_table_traverse_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_table_traverse_add", world, table, id_ptr, diff);
            }
            return (MemorySegment)mh$.invokeExact(world, table, id_ptr, diff);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ECS_PAIR$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("ECS_PAIR").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_PAIR
     * }
     */
    public static OfLong ECS_PAIR$layout() {
        return ECS_PAIR$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_PAIR
     * }
     */
    public static MemorySegment ECS_PAIR$segment() {
        return ECS_PAIR$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_PAIR
     * }
     */
    public static long ECS_PAIR() {
        return ECS_PAIR$constants.SEGMENT.get(ECS_PAIR$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_PAIR
     * }
     */
    public static void ECS_PAIR(long varValue) {
        ECS_PAIR$constants.SEGMENT.set(ECS_PAIR$constants.LAYOUT, 0L, varValue);
    }

    private static class ECS_AUTO_OVERRIDE$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("ECS_AUTO_OVERRIDE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_AUTO_OVERRIDE
     * }
     */
    public static OfLong ECS_AUTO_OVERRIDE$layout() {
        return ECS_AUTO_OVERRIDE$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_AUTO_OVERRIDE
     * }
     */
    public static MemorySegment ECS_AUTO_OVERRIDE$segment() {
        return ECS_AUTO_OVERRIDE$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_AUTO_OVERRIDE
     * }
     */
    public static long ECS_AUTO_OVERRIDE() {
        return ECS_AUTO_OVERRIDE$constants.SEGMENT.get(ECS_AUTO_OVERRIDE$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_AUTO_OVERRIDE
     * }
     */
    public static void ECS_AUTO_OVERRIDE(long varValue) {
        ECS_AUTO_OVERRIDE$constants.SEGMENT.set(ECS_AUTO_OVERRIDE$constants.LAYOUT, 0L, varValue);
    }

    private static class ECS_TOGGLE$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("ECS_TOGGLE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_TOGGLE
     * }
     */
    public static OfLong ECS_TOGGLE$layout() {
        return ECS_TOGGLE$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_TOGGLE
     * }
     */
    public static MemorySegment ECS_TOGGLE$segment() {
        return ECS_TOGGLE$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_TOGGLE
     * }
     */
    public static long ECS_TOGGLE() {
        return ECS_TOGGLE$constants.SEGMENT.get(ECS_TOGGLE$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_TOGGLE
     * }
     */
    public static void ECS_TOGGLE(long varValue) {
        ECS_TOGGLE$constants.SEGMENT.set(ECS_TOGGLE$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsComponentID_$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("FLECS_IDEcsComponentID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsComponentID_
     * }
     */
    public static OfLong FLECS_IDEcsComponentID_$layout() {
        return FLECS_IDEcsComponentID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsComponentID_
     * }
     */
    public static MemorySegment FLECS_IDEcsComponentID_$segment() {
        return FLECS_IDEcsComponentID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsComponentID_
     * }
     */
    public static long FLECS_IDEcsComponentID_() {
        return FLECS_IDEcsComponentID_$constants.SEGMENT.get(FLECS_IDEcsComponentID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsComponentID_
     * }
     */
    public static void FLECS_IDEcsComponentID_(long varValue) {
        FLECS_IDEcsComponentID_$constants.SEGMENT.set(FLECS_IDEcsComponentID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsIdentifierID_$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("FLECS_IDEcsIdentifierID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsIdentifierID_
     * }
     */
    public static OfLong FLECS_IDEcsIdentifierID_$layout() {
        return FLECS_IDEcsIdentifierID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsIdentifierID_
     * }
     */
    public static MemorySegment FLECS_IDEcsIdentifierID_$segment() {
        return FLECS_IDEcsIdentifierID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsIdentifierID_
     * }
     */
    public static long FLECS_IDEcsIdentifierID_() {
        return FLECS_IDEcsIdentifierID_$constants.SEGMENT.get(FLECS_IDEcsIdentifierID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsIdentifierID_
     * }
     */
    public static void FLECS_IDEcsIdentifierID_(long varValue) {
        FLECS_IDEcsIdentifierID_$constants.SEGMENT.set(FLECS_IDEcsIdentifierID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsPolyID_$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("FLECS_IDEcsPolyID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPolyID_
     * }
     */
    public static OfLong FLECS_IDEcsPolyID_$layout() {
        return FLECS_IDEcsPolyID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPolyID_
     * }
     */
    public static MemorySegment FLECS_IDEcsPolyID_$segment() {
        return FLECS_IDEcsPolyID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPolyID_
     * }
     */
    public static long FLECS_IDEcsPolyID_() {
        return FLECS_IDEcsPolyID_$constants.SEGMENT.get(FLECS_IDEcsPolyID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPolyID_
     * }
     */
    public static void FLECS_IDEcsPolyID_(long varValue) {
        FLECS_IDEcsPolyID_$constants.SEGMENT.set(FLECS_IDEcsPolyID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsDefaultChildComponentID_$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("FLECS_IDEcsDefaultChildComponentID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsDefaultChildComponentID_
     * }
     */
    public static OfLong FLECS_IDEcsDefaultChildComponentID_$layout() {
        return FLECS_IDEcsDefaultChildComponentID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsDefaultChildComponentID_
     * }
     */
    public static MemorySegment FLECS_IDEcsDefaultChildComponentID_$segment() {
        return FLECS_IDEcsDefaultChildComponentID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsDefaultChildComponentID_
     * }
     */
    public static long FLECS_IDEcsDefaultChildComponentID_() {
        return FLECS_IDEcsDefaultChildComponentID_$constants.SEGMENT.get(FLECS_IDEcsDefaultChildComponentID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsDefaultChildComponentID_
     * }
     */
    public static void FLECS_IDEcsDefaultChildComponentID_(long varValue) {
        FLECS_IDEcsDefaultChildComponentID_$constants.SEGMENT.set(FLECS_IDEcsDefaultChildComponentID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsQuery$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsQuery").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsQuery
     * }
     */
    public static OfLong EcsQuery$layout() {
        return EcsQuery$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsQuery
     * }
     */
    public static MemorySegment EcsQuery$segment() {
        return EcsQuery$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsQuery
     * }
     */
    public static long EcsQuery() {
        return EcsQuery$constants.SEGMENT.get(EcsQuery$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsQuery
     * }
     */
    public static void EcsQuery(long varValue) {
        EcsQuery$constants.SEGMENT.set(EcsQuery$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsObserver$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsObserver").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsObserver
     * }
     */
    public static OfLong EcsObserver$layout() {
        return EcsObserver$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsObserver
     * }
     */
    public static MemorySegment EcsObserver$segment() {
        return EcsObserver$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsObserver
     * }
     */
    public static long EcsObserver() {
        return EcsObserver$constants.SEGMENT.get(EcsObserver$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsObserver
     * }
     */
    public static void EcsObserver(long varValue) {
        EcsObserver$constants.SEGMENT.set(EcsObserver$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsSystem$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsSystem").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSystem
     * }
     */
    public static OfLong EcsSystem$layout() {
        return EcsSystem$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSystem
     * }
     */
    public static MemorySegment EcsSystem$segment() {
        return EcsSystem$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSystem
     * }
     */
    public static long EcsSystem() {
        return EcsSystem$constants.SEGMENT.get(EcsSystem$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSystem
     * }
     */
    public static void EcsSystem(long varValue) {
        EcsSystem$constants.SEGMENT.set(EcsSystem$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsTickSourceID_$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("FLECS_IDEcsTickSourceID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTickSourceID_
     * }
     */
    public static OfLong FLECS_IDEcsTickSourceID_$layout() {
        return FLECS_IDEcsTickSourceID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTickSourceID_
     * }
     */
    public static MemorySegment FLECS_IDEcsTickSourceID_$segment() {
        return FLECS_IDEcsTickSourceID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTickSourceID_
     * }
     */
    public static long FLECS_IDEcsTickSourceID_() {
        return FLECS_IDEcsTickSourceID_$constants.SEGMENT.get(FLECS_IDEcsTickSourceID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTickSourceID_
     * }
     */
    public static void FLECS_IDEcsTickSourceID_(long varValue) {
        FLECS_IDEcsTickSourceID_$constants.SEGMENT.set(FLECS_IDEcsTickSourceID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsPipelineQueryID_$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("FLECS_IDEcsPipelineQueryID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPipelineQueryID_
     * }
     */
    public static OfLong FLECS_IDEcsPipelineQueryID_$layout() {
        return FLECS_IDEcsPipelineQueryID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPipelineQueryID_
     * }
     */
    public static MemorySegment FLECS_IDEcsPipelineQueryID_$segment() {
        return FLECS_IDEcsPipelineQueryID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPipelineQueryID_
     * }
     */
    public static long FLECS_IDEcsPipelineQueryID_() {
        return FLECS_IDEcsPipelineQueryID_$constants.SEGMENT.get(FLECS_IDEcsPipelineQueryID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPipelineQueryID_
     * }
     */
    public static void FLECS_IDEcsPipelineQueryID_(long varValue) {
        FLECS_IDEcsPipelineQueryID_$constants.SEGMENT.set(FLECS_IDEcsPipelineQueryID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsTimerID_$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("FLECS_IDEcsTimerID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTimerID_
     * }
     */
    public static OfLong FLECS_IDEcsTimerID_$layout() {
        return FLECS_IDEcsTimerID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTimerID_
     * }
     */
    public static MemorySegment FLECS_IDEcsTimerID_$segment() {
        return FLECS_IDEcsTimerID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTimerID_
     * }
     */
    public static long FLECS_IDEcsTimerID_() {
        return FLECS_IDEcsTimerID_$constants.SEGMENT.get(FLECS_IDEcsTimerID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTimerID_
     * }
     */
    public static void FLECS_IDEcsTimerID_(long varValue) {
        FLECS_IDEcsTimerID_$constants.SEGMENT.set(FLECS_IDEcsTimerID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsRateFilterID_$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("FLECS_IDEcsRateFilterID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsRateFilterID_
     * }
     */
    public static OfLong FLECS_IDEcsRateFilterID_$layout() {
        return FLECS_IDEcsRateFilterID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsRateFilterID_
     * }
     */
    public static MemorySegment FLECS_IDEcsRateFilterID_$segment() {
        return FLECS_IDEcsRateFilterID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsRateFilterID_
     * }
     */
    public static long FLECS_IDEcsRateFilterID_() {
        return FLECS_IDEcsRateFilterID_$constants.SEGMENT.get(FLECS_IDEcsRateFilterID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsRateFilterID_
     * }
     */
    public static void FLECS_IDEcsRateFilterID_(long varValue) {
        FLECS_IDEcsRateFilterID_$constants.SEGMENT.set(FLECS_IDEcsRateFilterID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsFlecs$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsFlecs").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFlecs
     * }
     */
    public static OfLong EcsFlecs$layout() {
        return EcsFlecs$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFlecs
     * }
     */
    public static MemorySegment EcsFlecs$segment() {
        return EcsFlecs$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFlecs
     * }
     */
    public static long EcsFlecs() {
        return EcsFlecs$constants.SEGMENT.get(EcsFlecs$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFlecs
     * }
     */
    public static void EcsFlecs(long varValue) {
        EcsFlecs$constants.SEGMENT.set(EcsFlecs$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsFlecsCore$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsFlecsCore").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFlecsCore
     * }
     */
    public static OfLong EcsFlecsCore$layout() {
        return EcsFlecsCore$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFlecsCore
     * }
     */
    public static MemorySegment EcsFlecsCore$segment() {
        return EcsFlecsCore$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFlecsCore
     * }
     */
    public static long EcsFlecsCore() {
        return EcsFlecsCore$constants.SEGMENT.get(EcsFlecsCore$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFlecsCore
     * }
     */
    public static void EcsFlecsCore(long varValue) {
        EcsFlecsCore$constants.SEGMENT.set(EcsFlecsCore$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsWorld$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsWorld").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWorld
     * }
     */
    public static OfLong EcsWorld$layout() {
        return EcsWorld$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWorld
     * }
     */
    public static MemorySegment EcsWorld$segment() {
        return EcsWorld$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWorld
     * }
     */
    public static long EcsWorld() {
        return EcsWorld$constants.SEGMENT.get(EcsWorld$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWorld
     * }
     */
    public static void EcsWorld(long varValue) {
        EcsWorld$constants.SEGMENT.set(EcsWorld$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsWildcard$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsWildcard").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWildcard
     * }
     */
    public static OfLong EcsWildcard$layout() {
        return EcsWildcard$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWildcard
     * }
     */
    public static MemorySegment EcsWildcard$segment() {
        return EcsWildcard$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWildcard
     * }
     */
    public static long EcsWildcard() {
        return EcsWildcard$constants.SEGMENT.get(EcsWildcard$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWildcard
     * }
     */
    public static void EcsWildcard(long varValue) {
        EcsWildcard$constants.SEGMENT.set(EcsWildcard$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsAny$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsAny").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAny
     * }
     */
    public static OfLong EcsAny$layout() {
        return EcsAny$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAny
     * }
     */
    public static MemorySegment EcsAny$segment() {
        return EcsAny$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAny
     * }
     */
    public static long EcsAny() {
        return EcsAny$constants.SEGMENT.get(EcsAny$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAny
     * }
     */
    public static void EcsAny(long varValue) {
        EcsAny$constants.SEGMENT.set(EcsAny$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsThis$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsThis").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsThis
     * }
     */
    public static OfLong EcsThis$layout() {
        return EcsThis$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsThis
     * }
     */
    public static MemorySegment EcsThis$segment() {
        return EcsThis$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsThis
     * }
     */
    public static long EcsThis() {
        return EcsThis$constants.SEGMENT.get(EcsThis$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsThis
     * }
     */
    public static void EcsThis(long varValue) {
        EcsThis$constants.SEGMENT.set(EcsThis$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsVariable$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsVariable").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsVariable
     * }
     */
    public static OfLong EcsVariable$layout() {
        return EcsVariable$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsVariable
     * }
     */
    public static MemorySegment EcsVariable$segment() {
        return EcsVariable$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsVariable
     * }
     */
    public static long EcsVariable() {
        return EcsVariable$constants.SEGMENT.get(EcsVariable$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsVariable
     * }
     */
    public static void EcsVariable(long varValue) {
        EcsVariable$constants.SEGMENT.set(EcsVariable$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsTransitive$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsTransitive").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTransitive
     * }
     */
    public static OfLong EcsTransitive$layout() {
        return EcsTransitive$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTransitive
     * }
     */
    public static MemorySegment EcsTransitive$segment() {
        return EcsTransitive$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTransitive
     * }
     */
    public static long EcsTransitive() {
        return EcsTransitive$constants.SEGMENT.get(EcsTransitive$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTransitive
     * }
     */
    public static void EcsTransitive(long varValue) {
        EcsTransitive$constants.SEGMENT.set(EcsTransitive$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsReflexive$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsReflexive").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsReflexive
     * }
     */
    public static OfLong EcsReflexive$layout() {
        return EcsReflexive$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsReflexive
     * }
     */
    public static MemorySegment EcsReflexive$segment() {
        return EcsReflexive$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsReflexive
     * }
     */
    public static long EcsReflexive() {
        return EcsReflexive$constants.SEGMENT.get(EcsReflexive$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsReflexive
     * }
     */
    public static void EcsReflexive(long varValue) {
        EcsReflexive$constants.SEGMENT.set(EcsReflexive$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsFinal$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsFinal").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFinal
     * }
     */
    public static OfLong EcsFinal$layout() {
        return EcsFinal$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFinal
     * }
     */
    public static MemorySegment EcsFinal$segment() {
        return EcsFinal$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFinal
     * }
     */
    public static long EcsFinal() {
        return EcsFinal$constants.SEGMENT.get(EcsFinal$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFinal
     * }
     */
    public static void EcsFinal(long varValue) {
        EcsFinal$constants.SEGMENT.set(EcsFinal$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsInheritable$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsInheritable").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsInheritable
     * }
     */
    public static OfLong EcsInheritable$layout() {
        return EcsInheritable$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsInheritable
     * }
     */
    public static MemorySegment EcsInheritable$segment() {
        return EcsInheritable$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsInheritable
     * }
     */
    public static long EcsInheritable() {
        return EcsInheritable$constants.SEGMENT.get(EcsInheritable$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsInheritable
     * }
     */
    public static void EcsInheritable(long varValue) {
        EcsInheritable$constants.SEGMENT.set(EcsInheritable$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnInstantiate$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsOnInstantiate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnInstantiate
     * }
     */
    public static OfLong EcsOnInstantiate$layout() {
        return EcsOnInstantiate$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnInstantiate
     * }
     */
    public static MemorySegment EcsOnInstantiate$segment() {
        return EcsOnInstantiate$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnInstantiate
     * }
     */
    public static long EcsOnInstantiate() {
        return EcsOnInstantiate$constants.SEGMENT.get(EcsOnInstantiate$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnInstantiate
     * }
     */
    public static void EcsOnInstantiate(long varValue) {
        EcsOnInstantiate$constants.SEGMENT.set(EcsOnInstantiate$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOverride$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsOverride").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOverride
     * }
     */
    public static OfLong EcsOverride$layout() {
        return EcsOverride$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOverride
     * }
     */
    public static MemorySegment EcsOverride$segment() {
        return EcsOverride$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOverride
     * }
     */
    public static long EcsOverride() {
        return EcsOverride$constants.SEGMENT.get(EcsOverride$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOverride
     * }
     */
    public static void EcsOverride(long varValue) {
        EcsOverride$constants.SEGMENT.set(EcsOverride$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsInherit$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsInherit").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsInherit
     * }
     */
    public static OfLong EcsInherit$layout() {
        return EcsInherit$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsInherit
     * }
     */
    public static MemorySegment EcsInherit$segment() {
        return EcsInherit$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsInherit
     * }
     */
    public static long EcsInherit() {
        return EcsInherit$constants.SEGMENT.get(EcsInherit$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsInherit
     * }
     */
    public static void EcsInherit(long varValue) {
        EcsInherit$constants.SEGMENT.set(EcsInherit$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDontInherit$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsDontInherit").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDontInherit
     * }
     */
    public static OfLong EcsDontInherit$layout() {
        return EcsDontInherit$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDontInherit
     * }
     */
    public static MemorySegment EcsDontInherit$segment() {
        return EcsDontInherit$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDontInherit
     * }
     */
    public static long EcsDontInherit() {
        return EcsDontInherit$constants.SEGMENT.get(EcsDontInherit$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDontInherit
     * }
     */
    public static void EcsDontInherit(long varValue) {
        EcsDontInherit$constants.SEGMENT.set(EcsDontInherit$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsSymmetric$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsSymmetric").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSymmetric
     * }
     */
    public static OfLong EcsSymmetric$layout() {
        return EcsSymmetric$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSymmetric
     * }
     */
    public static MemorySegment EcsSymmetric$segment() {
        return EcsSymmetric$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSymmetric
     * }
     */
    public static long EcsSymmetric() {
        return EcsSymmetric$constants.SEGMENT.get(EcsSymmetric$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSymmetric
     * }
     */
    public static void EcsSymmetric(long varValue) {
        EcsSymmetric$constants.SEGMENT.set(EcsSymmetric$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsExclusive$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsExclusive").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsExclusive
     * }
     */
    public static OfLong EcsExclusive$layout() {
        return EcsExclusive$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsExclusive
     * }
     */
    public static MemorySegment EcsExclusive$segment() {
        return EcsExclusive$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsExclusive
     * }
     */
    public static long EcsExclusive() {
        return EcsExclusive$constants.SEGMENT.get(EcsExclusive$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsExclusive
     * }
     */
    public static void EcsExclusive(long varValue) {
        EcsExclusive$constants.SEGMENT.set(EcsExclusive$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsAcyclic$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsAcyclic").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAcyclic
     * }
     */
    public static OfLong EcsAcyclic$layout() {
        return EcsAcyclic$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAcyclic
     * }
     */
    public static MemorySegment EcsAcyclic$segment() {
        return EcsAcyclic$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAcyclic
     * }
     */
    public static long EcsAcyclic() {
        return EcsAcyclic$constants.SEGMENT.get(EcsAcyclic$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAcyclic
     * }
     */
    public static void EcsAcyclic(long varValue) {
        EcsAcyclic$constants.SEGMENT.set(EcsAcyclic$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsTraversable$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsTraversable").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTraversable
     * }
     */
    public static OfLong EcsTraversable$layout() {
        return EcsTraversable$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTraversable
     * }
     */
    public static MemorySegment EcsTraversable$segment() {
        return EcsTraversable$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTraversable
     * }
     */
    public static long EcsTraversable() {
        return EcsTraversable$constants.SEGMENT.get(EcsTraversable$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTraversable
     * }
     */
    public static void EcsTraversable(long varValue) {
        EcsTraversable$constants.SEGMENT.set(EcsTraversable$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsWith$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsWith").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWith
     * }
     */
    public static OfLong EcsWith$layout() {
        return EcsWith$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWith
     * }
     */
    public static MemorySegment EcsWith$segment() {
        return EcsWith$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWith
     * }
     */
    public static long EcsWith() {
        return EcsWith$constants.SEGMENT.get(EcsWith$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWith
     * }
     */
    public static void EcsWith(long varValue) {
        EcsWith$constants.SEGMENT.set(EcsWith$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOneOf$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsOneOf").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOneOf
     * }
     */
    public static OfLong EcsOneOf$layout() {
        return EcsOneOf$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOneOf
     * }
     */
    public static MemorySegment EcsOneOf$segment() {
        return EcsOneOf$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOneOf
     * }
     */
    public static long EcsOneOf() {
        return EcsOneOf$constants.SEGMENT.get(EcsOneOf$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOneOf
     * }
     */
    public static void EcsOneOf(long varValue) {
        EcsOneOf$constants.SEGMENT.set(EcsOneOf$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsCanToggle$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsCanToggle").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsCanToggle
     * }
     */
    public static OfLong EcsCanToggle$layout() {
        return EcsCanToggle$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsCanToggle
     * }
     */
    public static MemorySegment EcsCanToggle$segment() {
        return EcsCanToggle$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsCanToggle
     * }
     */
    public static long EcsCanToggle() {
        return EcsCanToggle$constants.SEGMENT.get(EcsCanToggle$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsCanToggle
     * }
     */
    public static void EcsCanToggle(long varValue) {
        EcsCanToggle$constants.SEGMENT.set(EcsCanToggle$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsTrait$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsTrait").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTrait
     * }
     */
    public static OfLong EcsTrait$layout() {
        return EcsTrait$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTrait
     * }
     */
    public static MemorySegment EcsTrait$segment() {
        return EcsTrait$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTrait
     * }
     */
    public static long EcsTrait() {
        return EcsTrait$constants.SEGMENT.get(EcsTrait$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTrait
     * }
     */
    public static void EcsTrait(long varValue) {
        EcsTrait$constants.SEGMENT.set(EcsTrait$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsRelationship$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsRelationship").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsRelationship
     * }
     */
    public static OfLong EcsRelationship$layout() {
        return EcsRelationship$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsRelationship
     * }
     */
    public static MemorySegment EcsRelationship$segment() {
        return EcsRelationship$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsRelationship
     * }
     */
    public static long EcsRelationship() {
        return EcsRelationship$constants.SEGMENT.get(EcsRelationship$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsRelationship
     * }
     */
    public static void EcsRelationship(long varValue) {
        EcsRelationship$constants.SEGMENT.set(EcsRelationship$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsTarget$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsTarget").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTarget
     * }
     */
    public static OfLong EcsTarget$layout() {
        return EcsTarget$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTarget
     * }
     */
    public static MemorySegment EcsTarget$segment() {
        return EcsTarget$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTarget
     * }
     */
    public static long EcsTarget() {
        return EcsTarget$constants.SEGMENT.get(EcsTarget$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTarget
     * }
     */
    public static void EcsTarget(long varValue) {
        EcsTarget$constants.SEGMENT.set(EcsTarget$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPairIsTag$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsPairIsTag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPairIsTag
     * }
     */
    public static OfLong EcsPairIsTag$layout() {
        return EcsPairIsTag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPairIsTag
     * }
     */
    public static MemorySegment EcsPairIsTag$segment() {
        return EcsPairIsTag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPairIsTag
     * }
     */
    public static long EcsPairIsTag() {
        return EcsPairIsTag$constants.SEGMENT.get(EcsPairIsTag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPairIsTag
     * }
     */
    public static void EcsPairIsTag(long varValue) {
        EcsPairIsTag$constants.SEGMENT.set(EcsPairIsTag$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsName$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsName").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsName
     * }
     */
    public static OfLong EcsName$layout() {
        return EcsName$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsName
     * }
     */
    public static MemorySegment EcsName$segment() {
        return EcsName$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsName
     * }
     */
    public static long EcsName() {
        return EcsName$constants.SEGMENT.get(EcsName$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsName
     * }
     */
    public static void EcsName(long varValue) {
        EcsName$constants.SEGMENT.set(EcsName$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsSymbol$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsSymbol").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSymbol
     * }
     */
    public static OfLong EcsSymbol$layout() {
        return EcsSymbol$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSymbol
     * }
     */
    public static MemorySegment EcsSymbol$segment() {
        return EcsSymbol$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSymbol
     * }
     */
    public static long EcsSymbol() {
        return EcsSymbol$constants.SEGMENT.get(EcsSymbol$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSymbol
     * }
     */
    public static void EcsSymbol(long varValue) {
        EcsSymbol$constants.SEGMENT.set(EcsSymbol$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsAlias$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsAlias").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAlias
     * }
     */
    public static OfLong EcsAlias$layout() {
        return EcsAlias$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAlias
     * }
     */
    public static MemorySegment EcsAlias$segment() {
        return EcsAlias$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAlias
     * }
     */
    public static long EcsAlias() {
        return EcsAlias$constants.SEGMENT.get(EcsAlias$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAlias
     * }
     */
    public static void EcsAlias(long varValue) {
        EcsAlias$constants.SEGMENT.set(EcsAlias$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsChildOf$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsChildOf").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsChildOf
     * }
     */
    public static OfLong EcsChildOf$layout() {
        return EcsChildOf$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsChildOf
     * }
     */
    public static MemorySegment EcsChildOf$segment() {
        return EcsChildOf$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsChildOf
     * }
     */
    public static long EcsChildOf() {
        return EcsChildOf$constants.SEGMENT.get(EcsChildOf$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsChildOf
     * }
     */
    public static void EcsChildOf(long varValue) {
        EcsChildOf$constants.SEGMENT.set(EcsChildOf$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsIsA$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsIsA").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsIsA
     * }
     */
    public static OfLong EcsIsA$layout() {
        return EcsIsA$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsIsA
     * }
     */
    public static MemorySegment EcsIsA$segment() {
        return EcsIsA$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsIsA
     * }
     */
    public static long EcsIsA() {
        return EcsIsA$constants.SEGMENT.get(EcsIsA$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsIsA
     * }
     */
    public static void EcsIsA(long varValue) {
        EcsIsA$constants.SEGMENT.set(EcsIsA$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDependsOn$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsDependsOn").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDependsOn
     * }
     */
    public static OfLong EcsDependsOn$layout() {
        return EcsDependsOn$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDependsOn
     * }
     */
    public static MemorySegment EcsDependsOn$segment() {
        return EcsDependsOn$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDependsOn
     * }
     */
    public static long EcsDependsOn() {
        return EcsDependsOn$constants.SEGMENT.get(EcsDependsOn$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDependsOn
     * }
     */
    public static void EcsDependsOn(long varValue) {
        EcsDependsOn$constants.SEGMENT.set(EcsDependsOn$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsSlotOf$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsSlotOf").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSlotOf
     * }
     */
    public static OfLong EcsSlotOf$layout() {
        return EcsSlotOf$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSlotOf
     * }
     */
    public static MemorySegment EcsSlotOf$segment() {
        return EcsSlotOf$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSlotOf
     * }
     */
    public static long EcsSlotOf() {
        return EcsSlotOf$constants.SEGMENT.get(EcsSlotOf$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSlotOf
     * }
     */
    public static void EcsSlotOf(long varValue) {
        EcsSlotOf$constants.SEGMENT.set(EcsSlotOf$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOrderedChildren$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsOrderedChildren").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOrderedChildren
     * }
     */
    public static OfLong EcsOrderedChildren$layout() {
        return EcsOrderedChildren$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOrderedChildren
     * }
     */
    public static MemorySegment EcsOrderedChildren$segment() {
        return EcsOrderedChildren$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOrderedChildren
     * }
     */
    public static long EcsOrderedChildren() {
        return EcsOrderedChildren$constants.SEGMENT.get(EcsOrderedChildren$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOrderedChildren
     * }
     */
    public static void EcsOrderedChildren(long varValue) {
        EcsOrderedChildren$constants.SEGMENT.set(EcsOrderedChildren$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsModule$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsModule").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsModule
     * }
     */
    public static OfLong EcsModule$layout() {
        return EcsModule$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsModule
     * }
     */
    public static MemorySegment EcsModule$segment() {
        return EcsModule$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsModule
     * }
     */
    public static long EcsModule() {
        return EcsModule$constants.SEGMENT.get(EcsModule$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsModule
     * }
     */
    public static void EcsModule(long varValue) {
        EcsModule$constants.SEGMENT.set(EcsModule$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPrivate$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsPrivate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPrivate
     * }
     */
    public static OfLong EcsPrivate$layout() {
        return EcsPrivate$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPrivate
     * }
     */
    public static MemorySegment EcsPrivate$segment() {
        return EcsPrivate$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPrivate
     * }
     */
    public static long EcsPrivate() {
        return EcsPrivate$constants.SEGMENT.get(EcsPrivate$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPrivate
     * }
     */
    public static void EcsPrivate(long varValue) {
        EcsPrivate$constants.SEGMENT.set(EcsPrivate$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPrefab$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsPrefab").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPrefab
     * }
     */
    public static OfLong EcsPrefab$layout() {
        return EcsPrefab$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPrefab
     * }
     */
    public static MemorySegment EcsPrefab$segment() {
        return EcsPrefab$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPrefab
     * }
     */
    public static long EcsPrefab() {
        return EcsPrefab$constants.SEGMENT.get(EcsPrefab$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPrefab
     * }
     */
    public static void EcsPrefab(long varValue) {
        EcsPrefab$constants.SEGMENT.set(EcsPrefab$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDisabled$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsDisabled").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDisabled
     * }
     */
    public static OfLong EcsDisabled$layout() {
        return EcsDisabled$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDisabled
     * }
     */
    public static MemorySegment EcsDisabled$segment() {
        return EcsDisabled$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDisabled
     * }
     */
    public static long EcsDisabled() {
        return EcsDisabled$constants.SEGMENT.get(EcsDisabled$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDisabled
     * }
     */
    public static void EcsDisabled(long varValue) {
        EcsDisabled$constants.SEGMENT.set(EcsDisabled$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsNotQueryable$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsNotQueryable").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsNotQueryable
     * }
     */
    public static OfLong EcsNotQueryable$layout() {
        return EcsNotQueryable$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsNotQueryable
     * }
     */
    public static MemorySegment EcsNotQueryable$segment() {
        return EcsNotQueryable$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsNotQueryable
     * }
     */
    public static long EcsNotQueryable() {
        return EcsNotQueryable$constants.SEGMENT.get(EcsNotQueryable$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsNotQueryable
     * }
     */
    public static void EcsNotQueryable(long varValue) {
        EcsNotQueryable$constants.SEGMENT.set(EcsNotQueryable$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnAdd$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsOnAdd").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnAdd
     * }
     */
    public static OfLong EcsOnAdd$layout() {
        return EcsOnAdd$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnAdd
     * }
     */
    public static MemorySegment EcsOnAdd$segment() {
        return EcsOnAdd$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnAdd
     * }
     */
    public static long EcsOnAdd() {
        return EcsOnAdd$constants.SEGMENT.get(EcsOnAdd$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnAdd
     * }
     */
    public static void EcsOnAdd(long varValue) {
        EcsOnAdd$constants.SEGMENT.set(EcsOnAdd$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnRemove$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsOnRemove").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnRemove
     * }
     */
    public static OfLong EcsOnRemove$layout() {
        return EcsOnRemove$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnRemove
     * }
     */
    public static MemorySegment EcsOnRemove$segment() {
        return EcsOnRemove$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnRemove
     * }
     */
    public static long EcsOnRemove() {
        return EcsOnRemove$constants.SEGMENT.get(EcsOnRemove$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnRemove
     * }
     */
    public static void EcsOnRemove(long varValue) {
        EcsOnRemove$constants.SEGMENT.set(EcsOnRemove$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnSet$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsOnSet").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnSet
     * }
     */
    public static OfLong EcsOnSet$layout() {
        return EcsOnSet$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnSet
     * }
     */
    public static MemorySegment EcsOnSet$segment() {
        return EcsOnSet$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnSet
     * }
     */
    public static long EcsOnSet() {
        return EcsOnSet$constants.SEGMENT.get(EcsOnSet$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnSet
     * }
     */
    public static void EcsOnSet(long varValue) {
        EcsOnSet$constants.SEGMENT.set(EcsOnSet$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMonitor$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsMonitor").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsMonitor
     * }
     */
    public static OfLong EcsMonitor$layout() {
        return EcsMonitor$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsMonitor
     * }
     */
    public static MemorySegment EcsMonitor$segment() {
        return EcsMonitor$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsMonitor
     * }
     */
    public static long EcsMonitor() {
        return EcsMonitor$constants.SEGMENT.get(EcsMonitor$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsMonitor
     * }
     */
    public static void EcsMonitor(long varValue) {
        EcsMonitor$constants.SEGMENT.set(EcsMonitor$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnTableCreate$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsOnTableCreate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableCreate
     * }
     */
    public static OfLong EcsOnTableCreate$layout() {
        return EcsOnTableCreate$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableCreate
     * }
     */
    public static MemorySegment EcsOnTableCreate$segment() {
        return EcsOnTableCreate$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableCreate
     * }
     */
    public static long EcsOnTableCreate() {
        return EcsOnTableCreate$constants.SEGMENT.get(EcsOnTableCreate$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableCreate
     * }
     */
    public static void EcsOnTableCreate(long varValue) {
        EcsOnTableCreate$constants.SEGMENT.set(EcsOnTableCreate$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnTableDelete$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsOnTableDelete").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableDelete
     * }
     */
    public static OfLong EcsOnTableDelete$layout() {
        return EcsOnTableDelete$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableDelete
     * }
     */
    public static MemorySegment EcsOnTableDelete$segment() {
        return EcsOnTableDelete$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableDelete
     * }
     */
    public static long EcsOnTableDelete() {
        return EcsOnTableDelete$constants.SEGMENT.get(EcsOnTableDelete$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableDelete
     * }
     */
    public static void EcsOnTableDelete(long varValue) {
        EcsOnTableDelete$constants.SEGMENT.set(EcsOnTableDelete$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnDelete$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsOnDelete").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnDelete
     * }
     */
    public static OfLong EcsOnDelete$layout() {
        return EcsOnDelete$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnDelete
     * }
     */
    public static MemorySegment EcsOnDelete$segment() {
        return EcsOnDelete$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnDelete
     * }
     */
    public static long EcsOnDelete() {
        return EcsOnDelete$constants.SEGMENT.get(EcsOnDelete$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnDelete
     * }
     */
    public static void EcsOnDelete(long varValue) {
        EcsOnDelete$constants.SEGMENT.set(EcsOnDelete$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnDeleteTarget$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsOnDeleteTarget").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnDeleteTarget
     * }
     */
    public static OfLong EcsOnDeleteTarget$layout() {
        return EcsOnDeleteTarget$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnDeleteTarget
     * }
     */
    public static MemorySegment EcsOnDeleteTarget$segment() {
        return EcsOnDeleteTarget$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnDeleteTarget
     * }
     */
    public static long EcsOnDeleteTarget() {
        return EcsOnDeleteTarget$constants.SEGMENT.get(EcsOnDeleteTarget$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnDeleteTarget
     * }
     */
    public static void EcsOnDeleteTarget(long varValue) {
        EcsOnDeleteTarget$constants.SEGMENT.set(EcsOnDeleteTarget$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsRemove$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsRemove").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsRemove
     * }
     */
    public static OfLong EcsRemove$layout() {
        return EcsRemove$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsRemove
     * }
     */
    public static MemorySegment EcsRemove$segment() {
        return EcsRemove$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsRemove
     * }
     */
    public static long EcsRemove() {
        return EcsRemove$constants.SEGMENT.get(EcsRemove$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsRemove
     * }
     */
    public static void EcsRemove(long varValue) {
        EcsRemove$constants.SEGMENT.set(EcsRemove$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDelete$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsDelete").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDelete
     * }
     */
    public static OfLong EcsDelete$layout() {
        return EcsDelete$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDelete
     * }
     */
    public static MemorySegment EcsDelete$segment() {
        return EcsDelete$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDelete
     * }
     */
    public static long EcsDelete() {
        return EcsDelete$constants.SEGMENT.get(EcsDelete$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDelete
     * }
     */
    public static void EcsDelete(long varValue) {
        EcsDelete$constants.SEGMENT.set(EcsDelete$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPanic$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsPanic").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPanic
     * }
     */
    public static OfLong EcsPanic$layout() {
        return EcsPanic$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPanic
     * }
     */
    public static MemorySegment EcsPanic$segment() {
        return EcsPanic$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPanic
     * }
     */
    public static long EcsPanic() {
        return EcsPanic$constants.SEGMENT.get(EcsPanic$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPanic
     * }
     */
    public static void EcsPanic(long varValue) {
        EcsPanic$constants.SEGMENT.set(EcsPanic$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsSingleton$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsSingleton").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSingleton
     * }
     */
    public static OfLong EcsSingleton$layout() {
        return EcsSingleton$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSingleton
     * }
     */
    public static MemorySegment EcsSingleton$segment() {
        return EcsSingleton$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSingleton
     * }
     */
    public static long EcsSingleton() {
        return EcsSingleton$constants.SEGMENT.get(EcsSingleton$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSingleton
     * }
     */
    public static void EcsSingleton(long varValue) {
        EcsSingleton$constants.SEGMENT.set(EcsSingleton$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsSparse$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsSparse").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSparse
     * }
     */
    public static OfLong EcsSparse$layout() {
        return EcsSparse$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSparse
     * }
     */
    public static MemorySegment EcsSparse$segment() {
        return EcsSparse$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSparse
     * }
     */
    public static long EcsSparse() {
        return EcsSparse$constants.SEGMENT.get(EcsSparse$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSparse
     * }
     */
    public static void EcsSparse(long varValue) {
        EcsSparse$constants.SEGMENT.set(EcsSparse$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDontFragment$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsDontFragment").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDontFragment
     * }
     */
    public static OfLong EcsDontFragment$layout() {
        return EcsDontFragment$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDontFragment
     * }
     */
    public static MemorySegment EcsDontFragment$segment() {
        return EcsDontFragment$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDontFragment
     * }
     */
    public static long EcsDontFragment() {
        return EcsDontFragment$constants.SEGMENT.get(EcsDontFragment$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDontFragment
     * }
     */
    public static void EcsDontFragment(long varValue) {
        EcsDontFragment$constants.SEGMENT.set(EcsDontFragment$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPredEq$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsPredEq").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredEq
     * }
     */
    public static OfLong EcsPredEq$layout() {
        return EcsPredEq$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredEq
     * }
     */
    public static MemorySegment EcsPredEq$segment() {
        return EcsPredEq$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredEq
     * }
     */
    public static long EcsPredEq() {
        return EcsPredEq$constants.SEGMENT.get(EcsPredEq$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredEq
     * }
     */
    public static void EcsPredEq(long varValue) {
        EcsPredEq$constants.SEGMENT.set(EcsPredEq$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPredMatch$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsPredMatch").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredMatch
     * }
     */
    public static OfLong EcsPredMatch$layout() {
        return EcsPredMatch$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredMatch
     * }
     */
    public static MemorySegment EcsPredMatch$segment() {
        return EcsPredMatch$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredMatch
     * }
     */
    public static long EcsPredMatch() {
        return EcsPredMatch$constants.SEGMENT.get(EcsPredMatch$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredMatch
     * }
     */
    public static void EcsPredMatch(long varValue) {
        EcsPredMatch$constants.SEGMENT.set(EcsPredMatch$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPredLookup$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsPredLookup").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredLookup
     * }
     */
    public static OfLong EcsPredLookup$layout() {
        return EcsPredLookup$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredLookup
     * }
     */
    public static MemorySegment EcsPredLookup$segment() {
        return EcsPredLookup$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredLookup
     * }
     */
    public static long EcsPredLookup() {
        return EcsPredLookup$constants.SEGMENT.get(EcsPredLookup$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredLookup
     * }
     */
    public static void EcsPredLookup(long varValue) {
        EcsPredLookup$constants.SEGMENT.set(EcsPredLookup$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsScopeOpen$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsScopeOpen").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsScopeOpen
     * }
     */
    public static OfLong EcsScopeOpen$layout() {
        return EcsScopeOpen$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsScopeOpen
     * }
     */
    public static MemorySegment EcsScopeOpen$segment() {
        return EcsScopeOpen$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsScopeOpen
     * }
     */
    public static long EcsScopeOpen() {
        return EcsScopeOpen$constants.SEGMENT.get(EcsScopeOpen$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsScopeOpen
     * }
     */
    public static void EcsScopeOpen(long varValue) {
        EcsScopeOpen$constants.SEGMENT.set(EcsScopeOpen$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsScopeClose$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsScopeClose").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsScopeClose
     * }
     */
    public static OfLong EcsScopeClose$layout() {
        return EcsScopeClose$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsScopeClose
     * }
     */
    public static MemorySegment EcsScopeClose$segment() {
        return EcsScopeClose$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsScopeClose
     * }
     */
    public static long EcsScopeClose() {
        return EcsScopeClose$constants.SEGMENT.get(EcsScopeClose$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsScopeClose
     * }
     */
    public static void EcsScopeClose(long varValue) {
        EcsScopeClose$constants.SEGMENT.set(EcsScopeClose$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsEmpty$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsEmpty").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsEmpty
     * }
     */
    public static OfLong EcsEmpty$layout() {
        return EcsEmpty$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsEmpty
     * }
     */
    public static MemorySegment EcsEmpty$segment() {
        return EcsEmpty$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsEmpty
     * }
     */
    public static long EcsEmpty() {
        return EcsEmpty$constants.SEGMENT.get(EcsEmpty$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsEmpty
     * }
     */
    public static void EcsEmpty(long varValue) {
        EcsEmpty$constants.SEGMENT.set(EcsEmpty$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsPipelineID_$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("FLECS_IDEcsPipelineID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPipelineID_
     * }
     */
    public static OfLong FLECS_IDEcsPipelineID_$layout() {
        return FLECS_IDEcsPipelineID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPipelineID_
     * }
     */
    public static MemorySegment FLECS_IDEcsPipelineID_$segment() {
        return FLECS_IDEcsPipelineID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPipelineID_
     * }
     */
    public static long FLECS_IDEcsPipelineID_() {
        return FLECS_IDEcsPipelineID_$constants.SEGMENT.get(FLECS_IDEcsPipelineID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPipelineID_
     * }
     */
    public static void FLECS_IDEcsPipelineID_(long varValue) {
        FLECS_IDEcsPipelineID_$constants.SEGMENT.set(FLECS_IDEcsPipelineID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnStart$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsOnStart").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnStart
     * }
     */
    public static OfLong EcsOnStart$layout() {
        return EcsOnStart$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnStart
     * }
     */
    public static MemorySegment EcsOnStart$segment() {
        return EcsOnStart$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnStart
     * }
     */
    public static long EcsOnStart() {
        return EcsOnStart$constants.SEGMENT.get(EcsOnStart$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnStart
     * }
     */
    public static void EcsOnStart(long varValue) {
        EcsOnStart$constants.SEGMENT.set(EcsOnStart$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPreFrame$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsPreFrame").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreFrame
     * }
     */
    public static OfLong EcsPreFrame$layout() {
        return EcsPreFrame$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreFrame
     * }
     */
    public static MemorySegment EcsPreFrame$segment() {
        return EcsPreFrame$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreFrame
     * }
     */
    public static long EcsPreFrame() {
        return EcsPreFrame$constants.SEGMENT.get(EcsPreFrame$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreFrame
     * }
     */
    public static void EcsPreFrame(long varValue) {
        EcsPreFrame$constants.SEGMENT.set(EcsPreFrame$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnLoad$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsOnLoad").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnLoad
     * }
     */
    public static OfLong EcsOnLoad$layout() {
        return EcsOnLoad$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnLoad
     * }
     */
    public static MemorySegment EcsOnLoad$segment() {
        return EcsOnLoad$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnLoad
     * }
     */
    public static long EcsOnLoad() {
        return EcsOnLoad$constants.SEGMENT.get(EcsOnLoad$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnLoad
     * }
     */
    public static void EcsOnLoad(long varValue) {
        EcsOnLoad$constants.SEGMENT.set(EcsOnLoad$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPostLoad$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsPostLoad").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostLoad
     * }
     */
    public static OfLong EcsPostLoad$layout() {
        return EcsPostLoad$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostLoad
     * }
     */
    public static MemorySegment EcsPostLoad$segment() {
        return EcsPostLoad$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostLoad
     * }
     */
    public static long EcsPostLoad() {
        return EcsPostLoad$constants.SEGMENT.get(EcsPostLoad$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostLoad
     * }
     */
    public static void EcsPostLoad(long varValue) {
        EcsPostLoad$constants.SEGMENT.set(EcsPostLoad$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPreUpdate$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsPreUpdate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreUpdate
     * }
     */
    public static OfLong EcsPreUpdate$layout() {
        return EcsPreUpdate$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreUpdate
     * }
     */
    public static MemorySegment EcsPreUpdate$segment() {
        return EcsPreUpdate$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreUpdate
     * }
     */
    public static long EcsPreUpdate() {
        return EcsPreUpdate$constants.SEGMENT.get(EcsPreUpdate$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreUpdate
     * }
     */
    public static void EcsPreUpdate(long varValue) {
        EcsPreUpdate$constants.SEGMENT.set(EcsPreUpdate$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnUpdate$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsOnUpdate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnUpdate
     * }
     */
    public static OfLong EcsOnUpdate$layout() {
        return EcsOnUpdate$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnUpdate
     * }
     */
    public static MemorySegment EcsOnUpdate$segment() {
        return EcsOnUpdate$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnUpdate
     * }
     */
    public static long EcsOnUpdate() {
        return EcsOnUpdate$constants.SEGMENT.get(EcsOnUpdate$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnUpdate
     * }
     */
    public static void EcsOnUpdate(long varValue) {
        EcsOnUpdate$constants.SEGMENT.set(EcsOnUpdate$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnValidate$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsOnValidate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnValidate
     * }
     */
    public static OfLong EcsOnValidate$layout() {
        return EcsOnValidate$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnValidate
     * }
     */
    public static MemorySegment EcsOnValidate$segment() {
        return EcsOnValidate$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnValidate
     * }
     */
    public static long EcsOnValidate() {
        return EcsOnValidate$constants.SEGMENT.get(EcsOnValidate$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnValidate
     * }
     */
    public static void EcsOnValidate(long varValue) {
        EcsOnValidate$constants.SEGMENT.set(EcsOnValidate$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPostUpdate$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsPostUpdate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostUpdate
     * }
     */
    public static OfLong EcsPostUpdate$layout() {
        return EcsPostUpdate$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostUpdate
     * }
     */
    public static MemorySegment EcsPostUpdate$segment() {
        return EcsPostUpdate$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostUpdate
     * }
     */
    public static long EcsPostUpdate() {
        return EcsPostUpdate$constants.SEGMENT.get(EcsPostUpdate$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostUpdate
     * }
     */
    public static void EcsPostUpdate(long varValue) {
        EcsPostUpdate$constants.SEGMENT.set(EcsPostUpdate$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPreStore$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsPreStore").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreStore
     * }
     */
    public static OfLong EcsPreStore$layout() {
        return EcsPreStore$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreStore
     * }
     */
    public static MemorySegment EcsPreStore$segment() {
        return EcsPreStore$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreStore
     * }
     */
    public static long EcsPreStore() {
        return EcsPreStore$constants.SEGMENT.get(EcsPreStore$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreStore
     * }
     */
    public static void EcsPreStore(long varValue) {
        EcsPreStore$constants.SEGMENT.set(EcsPreStore$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnStore$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsOnStore").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnStore
     * }
     */
    public static OfLong EcsOnStore$layout() {
        return EcsOnStore$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnStore
     * }
     */
    public static MemorySegment EcsOnStore$segment() {
        return EcsOnStore$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnStore
     * }
     */
    public static long EcsOnStore() {
        return EcsOnStore$constants.SEGMENT.get(EcsOnStore$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnStore
     * }
     */
    public static void EcsOnStore(long varValue) {
        EcsOnStore$constants.SEGMENT.set(EcsOnStore$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPostFrame$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsPostFrame").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostFrame
     * }
     */
    public static OfLong EcsPostFrame$layout() {
        return EcsPostFrame$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostFrame
     * }
     */
    public static MemorySegment EcsPostFrame$segment() {
        return EcsPostFrame$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostFrame
     * }
     */
    public static long EcsPostFrame() {
        return EcsPostFrame$constants.SEGMENT.get(EcsPostFrame$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostFrame
     * }
     */
    public static void EcsPostFrame(long varValue) {
        EcsPostFrame$constants.SEGMENT.set(EcsPostFrame$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPhase$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsPhase").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPhase
     * }
     */
    public static OfLong EcsPhase$layout() {
        return EcsPhase$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPhase
     * }
     */
    public static MemorySegment EcsPhase$segment() {
        return EcsPhase$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPhase
     * }
     */
    public static long EcsPhase() {
        return EcsPhase$constants.SEGMENT.get(EcsPhase$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPhase
     * }
     */
    public static void EcsPhase(long varValue) {
        EcsPhase$constants.SEGMENT.set(EcsPhase$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsConstant$constants {
        public static final OfLong LAYOUT = flecs_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("EcsConstant").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsConstant
     * }
     */
    public static OfLong EcsConstant$layout() {
        return EcsConstant$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsConstant
     * }
     */
    public static MemorySegment EcsConstant$segment() {
        return EcsConstant$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsConstant
     * }
     */
    public static long EcsConstant() {
        return EcsConstant$constants.SEGMENT.get(EcsConstant$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsConstant
     * }
     */
    public static void EcsConstant(long varValue) {
        EcsConstant$constants.SEGMENT.set(EcsConstant$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_init()
     * }
     */
    public static FunctionDescriptor ecs_init$descriptor() {
        return ecs_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_init()
     * }
     */
    public static MethodHandle ecs_init$handle() {
        return ecs_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_init()
     * }
     */
    public static MemorySegment ecs_init$address() {
        return ecs_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_world_t *ecs_init()
     * }
     */
    public static MemorySegment ecs_init() {
        var mh$ = ecs_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_init");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_mini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_mini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_mini()
     * }
     */
    public static FunctionDescriptor ecs_mini$descriptor() {
        return ecs_mini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_mini()
     * }
     */
    public static MethodHandle ecs_mini$handle() {
        return ecs_mini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_mini()
     * }
     */
    public static MemorySegment ecs_mini$address() {
        return ecs_mini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_world_t *ecs_mini()
     * }
     */
    public static MemorySegment ecs_mini() {
        var mh$ = ecs_mini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_mini");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_init_w_args {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_init_w_args");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_init_w_args(int argc, char *argv[])
     * }
     */
    public static FunctionDescriptor ecs_init_w_args$descriptor() {
        return ecs_init_w_args.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_init_w_args(int argc, char *argv[])
     * }
     */
    public static MethodHandle ecs_init_w_args$handle() {
        return ecs_init_w_args.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_init_w_args(int argc, char *argv[])
     * }
     */
    public static MemorySegment ecs_init_w_args$address() {
        return ecs_init_w_args.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_world_t *ecs_init_w_args(int argc, char *argv[])
     * }
     */
    public static MemorySegment ecs_init_w_args(int argc, MemorySegment argv) {
        var mh$ = ecs_init_w_args.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_init_w_args", argc, argv);
            }
            return (MemorySegment)mh$.invokeExact(argc, argv);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_fini(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_fini$descriptor() {
        return ecs_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_fini(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_fini$handle() {
        return ecs_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_fini(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_fini$address() {
        return ecs_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_fini(ecs_world_t *world)
     * }
     */
    public static int ecs_fini(MemorySegment world) {
        var mh$ = ecs_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_fini", world);
            }
            return (int)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_is_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_is_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_is_fini(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_is_fini$descriptor() {
        return ecs_is_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_is_fini(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_is_fini$handle() {
        return ecs_is_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_is_fini(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_is_fini$address() {
        return ecs_is_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_is_fini(const ecs_world_t *world)
     * }
     */
    public static boolean ecs_is_fini(MemorySegment world) {
        var mh$ = ecs_is_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_is_fini", world);
            }
            return (boolean)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_atfini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_atfini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_atfini(ecs_world_t *world, ecs_fini_action_t action, void *ctx)
     * }
     */
    public static FunctionDescriptor ecs_atfini$descriptor() {
        return ecs_atfini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_atfini(ecs_world_t *world, ecs_fini_action_t action, void *ctx)
     * }
     */
    public static MethodHandle ecs_atfini$handle() {
        return ecs_atfini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_atfini(ecs_world_t *world, ecs_fini_action_t action, void *ctx)
     * }
     */
    public static MemorySegment ecs_atfini$address() {
        return ecs_atfini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_atfini(ecs_world_t *world, ecs_fini_action_t action, void *ctx)
     * }
     */
    public static void ecs_atfini(MemorySegment world, MemorySegment action, MemorySegment ctx) {
        var mh$ = ecs_atfini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_atfini", world, action, ctx);
            }
            mh$.invokeExact(world, action, ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_entities {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_entities_t.layout(),
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_entities");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entities_t ecs_get_entities(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_entities$descriptor() {
        return ecs_get_entities.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entities_t ecs_get_entities(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_entities$handle() {
        return ecs_get_entities.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entities_t ecs_get_entities(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_entities$address() {
        return ecs_get_entities.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entities_t ecs_get_entities(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_entities(SegmentAllocator allocator, MemorySegment world) {
        var mh$ = ecs_get_entities.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_entities", allocator, world);
            }
            return (MemorySegment)mh$.invokeExact(allocator, world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_world_get_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_world_get_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_flags32_t ecs_world_get_flags(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_world_get_flags$descriptor() {
        return ecs_world_get_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_flags32_t ecs_world_get_flags(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_world_get_flags$handle() {
        return ecs_world_get_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_flags32_t ecs_world_get_flags(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_world_get_flags$address() {
        return ecs_world_get_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_flags32_t ecs_world_get_flags(const ecs_world_t *world)
     * }
     */
    public static int ecs_world_get_flags(MemorySegment world) {
        var mh$ = ecs_world_get_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_world_get_flags", world);
            }
            return (int)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_frame_begin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_FLOAT,
            flecs_h.C_POINTER,
            flecs_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_frame_begin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float ecs_frame_begin(ecs_world_t *world, float delta_time)
     * }
     */
    public static FunctionDescriptor ecs_frame_begin$descriptor() {
        return ecs_frame_begin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float ecs_frame_begin(ecs_world_t *world, float delta_time)
     * }
     */
    public static MethodHandle ecs_frame_begin$handle() {
        return ecs_frame_begin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float ecs_frame_begin(ecs_world_t *world, float delta_time)
     * }
     */
    public static MemorySegment ecs_frame_begin$address() {
        return ecs_frame_begin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float ecs_frame_begin(ecs_world_t *world, float delta_time)
     * }
     */
    public static float ecs_frame_begin(MemorySegment world, float delta_time) {
        var mh$ = ecs_frame_begin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_frame_begin", world, delta_time);
            }
            return (float)mh$.invokeExact(world, delta_time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_frame_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_frame_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_frame_end(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_frame_end$descriptor() {
        return ecs_frame_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_frame_end(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_frame_end$handle() {
        return ecs_frame_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_frame_end(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_frame_end$address() {
        return ecs_frame_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_frame_end(ecs_world_t *world)
     * }
     */
    public static void ecs_frame_end(MemorySegment world) {
        var mh$ = ecs_frame_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_frame_end", world);
            }
            mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_run_post_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_run_post_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_run_post_frame(ecs_world_t *world, ecs_fini_action_t action, void *ctx)
     * }
     */
    public static FunctionDescriptor ecs_run_post_frame$descriptor() {
        return ecs_run_post_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_run_post_frame(ecs_world_t *world, ecs_fini_action_t action, void *ctx)
     * }
     */
    public static MethodHandle ecs_run_post_frame$handle() {
        return ecs_run_post_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_run_post_frame(ecs_world_t *world, ecs_fini_action_t action, void *ctx)
     * }
     */
    public static MemorySegment ecs_run_post_frame$address() {
        return ecs_run_post_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_run_post_frame(ecs_world_t *world, ecs_fini_action_t action, void *ctx)
     * }
     */
    public static void ecs_run_post_frame(MemorySegment world, MemorySegment action, MemorySegment ctx) {
        var mh$ = ecs_run_post_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_run_post_frame", world, action, ctx);
            }
            mh$.invokeExact(world, action, ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_quit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_quit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_quit(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_quit$descriptor() {
        return ecs_quit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_quit(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_quit$handle() {
        return ecs_quit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_quit(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_quit$address() {
        return ecs_quit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_quit(ecs_world_t *world)
     * }
     */
    public static void ecs_quit(MemorySegment world) {
        var mh$ = ecs_quit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_quit", world);
            }
            mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_should_quit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_should_quit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_should_quit(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_should_quit$descriptor() {
        return ecs_should_quit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_should_quit(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_should_quit$handle() {
        return ecs_should_quit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_should_quit(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_should_quit$address() {
        return ecs_should_quit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_should_quit(const ecs_world_t *world)
     * }
     */
    public static boolean ecs_should_quit(MemorySegment world) {
        var mh$ = ecs_should_quit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_should_quit", world);
            }
            return (boolean)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_measure_frame_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_measure_frame_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_measure_frame_time(ecs_world_t *world, _Bool enable)
     * }
     */
    public static FunctionDescriptor ecs_measure_frame_time$descriptor() {
        return ecs_measure_frame_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_measure_frame_time(ecs_world_t *world, _Bool enable)
     * }
     */
    public static MethodHandle ecs_measure_frame_time$handle() {
        return ecs_measure_frame_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_measure_frame_time(ecs_world_t *world, _Bool enable)
     * }
     */
    public static MemorySegment ecs_measure_frame_time$address() {
        return ecs_measure_frame_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_measure_frame_time(ecs_world_t *world, _Bool enable)
     * }
     */
    public static void ecs_measure_frame_time(MemorySegment world, boolean enable) {
        var mh$ = ecs_measure_frame_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_measure_frame_time", world, enable);
            }
            mh$.invokeExact(world, enable);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_measure_system_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_measure_system_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_measure_system_time(ecs_world_t *world, _Bool enable)
     * }
     */
    public static FunctionDescriptor ecs_measure_system_time$descriptor() {
        return ecs_measure_system_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_measure_system_time(ecs_world_t *world, _Bool enable)
     * }
     */
    public static MethodHandle ecs_measure_system_time$handle() {
        return ecs_measure_system_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_measure_system_time(ecs_world_t *world, _Bool enable)
     * }
     */
    public static MemorySegment ecs_measure_system_time$address() {
        return ecs_measure_system_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_measure_system_time(ecs_world_t *world, _Bool enable)
     * }
     */
    public static void ecs_measure_system_time(MemorySegment world, boolean enable) {
        var mh$ = ecs_measure_system_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_measure_system_time", world, enable);
            }
            mh$.invokeExact(world, enable);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_target_fps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_set_target_fps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_target_fps(ecs_world_t *world, float fps)
     * }
     */
    public static FunctionDescriptor ecs_set_target_fps$descriptor() {
        return ecs_set_target_fps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_target_fps(ecs_world_t *world, float fps)
     * }
     */
    public static MethodHandle ecs_set_target_fps$handle() {
        return ecs_set_target_fps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_target_fps(ecs_world_t *world, float fps)
     * }
     */
    public static MemorySegment ecs_set_target_fps$address() {
        return ecs_set_target_fps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_target_fps(ecs_world_t *world, float fps)
     * }
     */
    public static void ecs_set_target_fps(MemorySegment world, float fps) {
        var mh$ = ecs_set_target_fps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_target_fps", world, fps);
            }
            mh$.invokeExact(world, fps);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_default_query_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_set_default_query_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_default_query_flags(ecs_world_t *world, ecs_flags32_t flags)
     * }
     */
    public static FunctionDescriptor ecs_set_default_query_flags$descriptor() {
        return ecs_set_default_query_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_default_query_flags(ecs_world_t *world, ecs_flags32_t flags)
     * }
     */
    public static MethodHandle ecs_set_default_query_flags$handle() {
        return ecs_set_default_query_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_default_query_flags(ecs_world_t *world, ecs_flags32_t flags)
     * }
     */
    public static MemorySegment ecs_set_default_query_flags$address() {
        return ecs_set_default_query_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_default_query_flags(ecs_world_t *world, ecs_flags32_t flags)
     * }
     */
    public static void ecs_set_default_query_flags(MemorySegment world, int flags) {
        var mh$ = ecs_set_default_query_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_default_query_flags", world, flags);
            }
            mh$.invokeExact(world, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_readonly_begin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_readonly_begin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_readonly_begin(ecs_world_t *world, _Bool multi_threaded)
     * }
     */
    public static FunctionDescriptor ecs_readonly_begin$descriptor() {
        return ecs_readonly_begin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_readonly_begin(ecs_world_t *world, _Bool multi_threaded)
     * }
     */
    public static MethodHandle ecs_readonly_begin$handle() {
        return ecs_readonly_begin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_readonly_begin(ecs_world_t *world, _Bool multi_threaded)
     * }
     */
    public static MemorySegment ecs_readonly_begin$address() {
        return ecs_readonly_begin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_readonly_begin(ecs_world_t *world, _Bool multi_threaded)
     * }
     */
    public static boolean ecs_readonly_begin(MemorySegment world, boolean multi_threaded) {
        var mh$ = ecs_readonly_begin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_readonly_begin", world, multi_threaded);
            }
            return (boolean)mh$.invokeExact(world, multi_threaded);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_readonly_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_readonly_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_readonly_end(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_readonly_end$descriptor() {
        return ecs_readonly_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_readonly_end(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_readonly_end$handle() {
        return ecs_readonly_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_readonly_end(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_readonly_end$address() {
        return ecs_readonly_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_readonly_end(ecs_world_t *world)
     * }
     */
    public static void ecs_readonly_end(MemorySegment world) {
        var mh$ = ecs_readonly_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_readonly_end", world);
            }
            mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_merge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_merge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_merge(ecs_world_t *stage)
     * }
     */
    public static FunctionDescriptor ecs_merge$descriptor() {
        return ecs_merge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_merge(ecs_world_t *stage)
     * }
     */
    public static MethodHandle ecs_merge$handle() {
        return ecs_merge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_merge(ecs_world_t *stage)
     * }
     */
    public static MemorySegment ecs_merge$address() {
        return ecs_merge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_merge(ecs_world_t *stage)
     * }
     */
    public static void ecs_merge(MemorySegment stage) {
        var mh$ = ecs_merge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_merge", stage);
            }
            mh$.invokeExact(stage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_defer_begin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_defer_begin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_defer_begin(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_defer_begin$descriptor() {
        return ecs_defer_begin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_defer_begin(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_defer_begin$handle() {
        return ecs_defer_begin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_defer_begin(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_defer_begin$address() {
        return ecs_defer_begin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_defer_begin(ecs_world_t *world)
     * }
     */
    public static boolean ecs_defer_begin(MemorySegment world) {
        var mh$ = ecs_defer_begin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_defer_begin", world);
            }
            return (boolean)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_defer_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_defer_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_defer_end(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_defer_end$descriptor() {
        return ecs_defer_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_defer_end(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_defer_end$handle() {
        return ecs_defer_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_defer_end(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_defer_end$address() {
        return ecs_defer_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_defer_end(ecs_world_t *world)
     * }
     */
    public static boolean ecs_defer_end(MemorySegment world) {
        var mh$ = ecs_defer_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_defer_end", world);
            }
            return (boolean)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_defer_suspend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_defer_suspend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_defer_suspend(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_defer_suspend$descriptor() {
        return ecs_defer_suspend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_defer_suspend(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_defer_suspend$handle() {
        return ecs_defer_suspend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_defer_suspend(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_defer_suspend$address() {
        return ecs_defer_suspend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_defer_suspend(ecs_world_t *world)
     * }
     */
    public static void ecs_defer_suspend(MemorySegment world) {
        var mh$ = ecs_defer_suspend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_defer_suspend", world);
            }
            mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_defer_resume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_defer_resume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_defer_resume(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_defer_resume$descriptor() {
        return ecs_defer_resume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_defer_resume(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_defer_resume$handle() {
        return ecs_defer_resume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_defer_resume(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_defer_resume$address() {
        return ecs_defer_resume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_defer_resume(ecs_world_t *world)
     * }
     */
    public static void ecs_defer_resume(MemorySegment world) {
        var mh$ = ecs_defer_resume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_defer_resume", world);
            }
            mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_is_deferred {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_is_deferred");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_is_deferred(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_is_deferred$descriptor() {
        return ecs_is_deferred.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_is_deferred(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_is_deferred$handle() {
        return ecs_is_deferred.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_is_deferred(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_is_deferred$address() {
        return ecs_is_deferred.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_is_deferred(const ecs_world_t *world)
     * }
     */
    public static boolean ecs_is_deferred(MemorySegment world) {
        var mh$ = ecs_is_deferred.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_is_deferred", world);
            }
            return (boolean)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_is_defer_suspended {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_is_defer_suspended");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_is_defer_suspended(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_is_defer_suspended$descriptor() {
        return ecs_is_defer_suspended.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_is_defer_suspended(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_is_defer_suspended$handle() {
        return ecs_is_defer_suspended.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_is_defer_suspended(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_is_defer_suspended$address() {
        return ecs_is_defer_suspended.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_is_defer_suspended(const ecs_world_t *world)
     * }
     */
    public static boolean ecs_is_defer_suspended(MemorySegment world) {
        var mh$ = ecs_is_defer_suspended.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_is_defer_suspended", world);
            }
            return (boolean)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_stage_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_set_stage_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_stage_count(ecs_world_t *world, int32_t stages)
     * }
     */
    public static FunctionDescriptor ecs_set_stage_count$descriptor() {
        return ecs_set_stage_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_stage_count(ecs_world_t *world, int32_t stages)
     * }
     */
    public static MethodHandle ecs_set_stage_count$handle() {
        return ecs_set_stage_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_stage_count(ecs_world_t *world, int32_t stages)
     * }
     */
    public static MemorySegment ecs_set_stage_count$address() {
        return ecs_set_stage_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_stage_count(ecs_world_t *world, int32_t stages)
     * }
     */
    public static void ecs_set_stage_count(MemorySegment world, int stages) {
        var mh$ = ecs_set_stage_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_stage_count", world, stages);
            }
            mh$.invokeExact(world, stages);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_stage_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_stage_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_get_stage_count(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_stage_count$descriptor() {
        return ecs_get_stage_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_get_stage_count(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_stage_count$handle() {
        return ecs_get_stage_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_get_stage_count(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_stage_count$address() {
        return ecs_get_stage_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_get_stage_count(const ecs_world_t *world)
     * }
     */
    public static int ecs_get_stage_count(MemorySegment world) {
        var mh$ = ecs_get_stage_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_stage_count", world);
            }
            return (int)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_get_stage(const ecs_world_t *world, int32_t stage_id)
     * }
     */
    public static FunctionDescriptor ecs_get_stage$descriptor() {
        return ecs_get_stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_get_stage(const ecs_world_t *world, int32_t stage_id)
     * }
     */
    public static MethodHandle ecs_get_stage$handle() {
        return ecs_get_stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_get_stage(const ecs_world_t *world, int32_t stage_id)
     * }
     */
    public static MemorySegment ecs_get_stage$address() {
        return ecs_get_stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_world_t *ecs_get_stage(const ecs_world_t *world, int32_t stage_id)
     * }
     */
    public static MemorySegment ecs_get_stage(MemorySegment world, int stage_id) {
        var mh$ = ecs_get_stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_stage", world, stage_id);
            }
            return (MemorySegment)mh$.invokeExact(world, stage_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_stage_is_readonly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_stage_is_readonly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_stage_is_readonly(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_stage_is_readonly$descriptor() {
        return ecs_stage_is_readonly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_stage_is_readonly(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_stage_is_readonly$handle() {
        return ecs_stage_is_readonly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_stage_is_readonly(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_stage_is_readonly$address() {
        return ecs_stage_is_readonly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_stage_is_readonly(const ecs_world_t *world)
     * }
     */
    public static boolean ecs_stage_is_readonly(MemorySegment world) {
        var mh$ = ecs_stage_is_readonly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_stage_is_readonly", world);
            }
            return (boolean)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_stage_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_stage_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_stage_new(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_stage_new$descriptor() {
        return ecs_stage_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_stage_new(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_stage_new$handle() {
        return ecs_stage_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_stage_new(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_stage_new$address() {
        return ecs_stage_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_world_t *ecs_stage_new(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_stage_new(MemorySegment world) {
        var mh$ = ecs_stage_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_stage_new", world);
            }
            return (MemorySegment)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_stage_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_stage_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_stage_free(ecs_world_t *stage)
     * }
     */
    public static FunctionDescriptor ecs_stage_free$descriptor() {
        return ecs_stage_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_stage_free(ecs_world_t *stage)
     * }
     */
    public static MethodHandle ecs_stage_free$handle() {
        return ecs_stage_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_stage_free(ecs_world_t *stage)
     * }
     */
    public static MemorySegment ecs_stage_free$address() {
        return ecs_stage_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_stage_free(ecs_world_t *stage)
     * }
     */
    public static void ecs_stage_free(MemorySegment stage) {
        var mh$ = ecs_stage_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_stage_free", stage);
            }
            mh$.invokeExact(stage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_stage_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_stage_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(false));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_stage_get_id(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_stage_get_id$descriptor() {
        return ecs_stage_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_stage_get_id(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_stage_get_id$handle() {
        return ecs_stage_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_stage_get_id(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_stage_get_id$address() {
        return ecs_stage_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_stage_get_id(const ecs_world_t *world)
     * }
     */
    public static int ecs_stage_get_id(MemorySegment world) {
        var mh$ = ecs_stage_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_stage_get_id", world);
            }
            return (int)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_set_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_ctx(ecs_world_t *world, void *ctx, ecs_ctx_free_t ctx_free)
     * }
     */
    public static FunctionDescriptor ecs_set_ctx$descriptor() {
        return ecs_set_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_ctx(ecs_world_t *world, void *ctx, ecs_ctx_free_t ctx_free)
     * }
     */
    public static MethodHandle ecs_set_ctx$handle() {
        return ecs_set_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_ctx(ecs_world_t *world, void *ctx, ecs_ctx_free_t ctx_free)
     * }
     */
    public static MemorySegment ecs_set_ctx$address() {
        return ecs_set_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_ctx(ecs_world_t *world, void *ctx, ecs_ctx_free_t ctx_free)
     * }
     */
    public static void ecs_set_ctx(MemorySegment world, MemorySegment ctx, MemorySegment ctx_free) {
        var mh$ = ecs_set_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_ctx", world, ctx, ctx_free);
            }
            mh$.invokeExact(world, ctx, ctx_free);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_binding_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_set_binding_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_binding_ctx(ecs_world_t *world, void *ctx, ecs_ctx_free_t ctx_free)
     * }
     */
    public static FunctionDescriptor ecs_set_binding_ctx$descriptor() {
        return ecs_set_binding_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_binding_ctx(ecs_world_t *world, void *ctx, ecs_ctx_free_t ctx_free)
     * }
     */
    public static MethodHandle ecs_set_binding_ctx$handle() {
        return ecs_set_binding_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_binding_ctx(ecs_world_t *world, void *ctx, ecs_ctx_free_t ctx_free)
     * }
     */
    public static MemorySegment ecs_set_binding_ctx$address() {
        return ecs_set_binding_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_binding_ctx(ecs_world_t *world, void *ctx, ecs_ctx_free_t ctx_free)
     * }
     */
    public static void ecs_set_binding_ctx(MemorySegment world, MemorySegment ctx, MemorySegment ctx_free) {
        var mh$ = ecs_set_binding_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_binding_ctx", world, ctx, ctx_free);
            }
            mh$.invokeExact(world, ctx, ctx_free);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_get_ctx(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_ctx$descriptor() {
        return ecs_get_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_get_ctx(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_ctx$handle() {
        return ecs_get_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_get_ctx(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_ctx$address() {
        return ecs_get_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_get_ctx(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_ctx(MemorySegment world) {
        var mh$ = ecs_get_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_ctx", world);
            }
            return (MemorySegment)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_binding_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_binding_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_get_binding_ctx(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_binding_ctx$descriptor() {
        return ecs_get_binding_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_get_binding_ctx(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_binding_ctx$handle() {
        return ecs_get_binding_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_get_binding_ctx(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_binding_ctx$address() {
        return ecs_get_binding_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_get_binding_ctx(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_binding_ctx(MemorySegment world) {
        var mh$ = ecs_get_binding_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_binding_ctx", world);
            }
            return (MemorySegment)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_build_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_build_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_build_info_t *ecs_get_build_info()
     * }
     */
    public static FunctionDescriptor ecs_get_build_info$descriptor() {
        return ecs_get_build_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_build_info_t *ecs_get_build_info()
     * }
     */
    public static MethodHandle ecs_get_build_info$handle() {
        return ecs_get_build_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_build_info_t *ecs_get_build_info()
     * }
     */
    public static MemorySegment ecs_get_build_info$address() {
        return ecs_get_build_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_build_info_t *ecs_get_build_info()
     * }
     */
    public static MemorySegment ecs_get_build_info() {
        var mh$ = ecs_get_build_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_build_info");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_world_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_world_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_world_info_t *ecs_get_world_info(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_world_info$descriptor() {
        return ecs_get_world_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_world_info_t *ecs_get_world_info(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_world_info$handle() {
        return ecs_get_world_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_world_info_t *ecs_get_world_info(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_world_info$address() {
        return ecs_get_world_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_world_info_t *ecs_get_world_info(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_world_info(MemorySegment world) {
        var mh$ = ecs_get_world_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_world_info", world);
            }
            return (MemorySegment)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_dim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_dim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_dim(ecs_world_t *world, int32_t entity_count)
     * }
     */
    public static FunctionDescriptor ecs_dim$descriptor() {
        return ecs_dim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_dim(ecs_world_t *world, int32_t entity_count)
     * }
     */
    public static MethodHandle ecs_dim$handle() {
        return ecs_dim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_dim(ecs_world_t *world, int32_t entity_count)
     * }
     */
    public static MemorySegment ecs_dim$address() {
        return ecs_dim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_dim(ecs_world_t *world, int32_t entity_count)
     * }
     */
    public static void ecs_dim(MemorySegment world, int entity_count) {
        var mh$ = ecs_dim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_dim", world, entity_count);
            }
            mh$.invokeExact(world, entity_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_shrink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_shrink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_shrink(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_shrink$descriptor() {
        return ecs_shrink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_shrink(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_shrink$handle() {
        return ecs_shrink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_shrink(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_shrink$address() {
        return ecs_shrink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_shrink(ecs_world_t *world)
     * }
     */
    public static void ecs_shrink(MemorySegment world) {
        var mh$ = ecs_shrink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_shrink", world);
            }
            mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_entity_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_set_entity_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_entity_range(ecs_world_t *world, ecs_entity_t id_start, ecs_entity_t id_end)
     * }
     */
    public static FunctionDescriptor ecs_set_entity_range$descriptor() {
        return ecs_set_entity_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_entity_range(ecs_world_t *world, ecs_entity_t id_start, ecs_entity_t id_end)
     * }
     */
    public static MethodHandle ecs_set_entity_range$handle() {
        return ecs_set_entity_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_entity_range(ecs_world_t *world, ecs_entity_t id_start, ecs_entity_t id_end)
     * }
     */
    public static MemorySegment ecs_set_entity_range$address() {
        return ecs_set_entity_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_entity_range(ecs_world_t *world, ecs_entity_t id_start, ecs_entity_t id_end)
     * }
     */
    public static void ecs_set_entity_range(MemorySegment world, long id_start, long id_end) {
        var mh$ = ecs_set_entity_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_entity_range", world, id_start, id_end);
            }
            mh$.invokeExact(world, id_start, id_end);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_enable_range_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_enable_range_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_enable_range_check(ecs_world_t *world, _Bool enable)
     * }
     */
    public static FunctionDescriptor ecs_enable_range_check$descriptor() {
        return ecs_enable_range_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_enable_range_check(ecs_world_t *world, _Bool enable)
     * }
     */
    public static MethodHandle ecs_enable_range_check$handle() {
        return ecs_enable_range_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_enable_range_check(ecs_world_t *world, _Bool enable)
     * }
     */
    public static MemorySegment ecs_enable_range_check$address() {
        return ecs_enable_range_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_enable_range_check(ecs_world_t *world, _Bool enable)
     * }
     */
    public static boolean ecs_enable_range_check(MemorySegment world, boolean enable) {
        var mh$ = ecs_enable_range_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_enable_range_check", world, enable);
            }
            return (boolean)mh$.invokeExact(world, enable);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_max_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_max_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_max_id(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_max_id$descriptor() {
        return ecs_get_max_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_max_id(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_max_id$handle() {
        return ecs_get_max_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_max_id(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_max_id$address() {
        return ecs_get_max_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_max_id(const ecs_world_t *world)
     * }
     */
    public static long ecs_get_max_id(MemorySegment world) {
        var mh$ = ecs_get_max_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_max_id", world);
            }
            return (long)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_run_aperiodic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_run_aperiodic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_run_aperiodic(ecs_world_t *world, ecs_flags32_t flags)
     * }
     */
    public static FunctionDescriptor ecs_run_aperiodic$descriptor() {
        return ecs_run_aperiodic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_run_aperiodic(ecs_world_t *world, ecs_flags32_t flags)
     * }
     */
    public static MethodHandle ecs_run_aperiodic$handle() {
        return ecs_run_aperiodic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_run_aperiodic(ecs_world_t *world, ecs_flags32_t flags)
     * }
     */
    public static MemorySegment ecs_run_aperiodic$address() {
        return ecs_run_aperiodic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_run_aperiodic(ecs_world_t *world, ecs_flags32_t flags)
     * }
     */
    public static void ecs_run_aperiodic(MemorySegment world, int flags) {
        var mh$ = ecs_run_aperiodic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_run_aperiodic", world, flags);
            }
            mh$.invokeExact(world, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_delete_empty_tables {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_delete_empty_tables");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_delete_empty_tables(ecs_world_t *world, const ecs_delete_empty_tables_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_delete_empty_tables$descriptor() {
        return ecs_delete_empty_tables.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_delete_empty_tables(ecs_world_t *world, const ecs_delete_empty_tables_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_delete_empty_tables$handle() {
        return ecs_delete_empty_tables.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_delete_empty_tables(ecs_world_t *world, const ecs_delete_empty_tables_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_delete_empty_tables$address() {
        return ecs_delete_empty_tables.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_delete_empty_tables(ecs_world_t *world, const ecs_delete_empty_tables_desc_t *desc)
     * }
     */
    public static int ecs_delete_empty_tables(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_delete_empty_tables.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_delete_empty_tables", world, desc);
            }
            return (int)mh$.invokeExact(world, desc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_world {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_world");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_world_t *ecs_get_world(const ecs_poly_t *poly)
     * }
     */
    public static FunctionDescriptor ecs_get_world$descriptor() {
        return ecs_get_world.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_world_t *ecs_get_world(const ecs_poly_t *poly)
     * }
     */
    public static MethodHandle ecs_get_world$handle() {
        return ecs_get_world.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_world_t *ecs_get_world(const ecs_poly_t *poly)
     * }
     */
    public static MemorySegment ecs_get_world$address() {
        return ecs_get_world.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_world_t *ecs_get_world(const ecs_poly_t *poly)
     * }
     */
    public static MemorySegment ecs_get_world(MemorySegment poly) {
        var mh$ = ecs_get_world.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_world", poly);
            }
            return (MemorySegment)mh$.invokeExact(poly);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_entity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_entity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_entity(const ecs_poly_t *poly)
     * }
     */
    public static FunctionDescriptor ecs_get_entity$descriptor() {
        return ecs_get_entity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_entity(const ecs_poly_t *poly)
     * }
     */
    public static MethodHandle ecs_get_entity$handle() {
        return ecs_get_entity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_entity(const ecs_poly_t *poly)
     * }
     */
    public static MemorySegment ecs_get_entity$address() {
        return ecs_get_entity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_entity(const ecs_poly_t *poly)
     * }
     */
    public static long ecs_get_entity(MemorySegment poly) {
        var mh$ = ecs_get_entity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_entity", poly);
            }
            return (long)mh$.invokeExact(poly);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_poly_is_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flecs_poly_is_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool flecs_poly_is_(const ecs_poly_t *object, int32_t type)
     * }
     */
    public static FunctionDescriptor flecs_poly_is_$descriptor() {
        return flecs_poly_is_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool flecs_poly_is_(const ecs_poly_t *object, int32_t type)
     * }
     */
    public static MethodHandle flecs_poly_is_$handle() {
        return flecs_poly_is_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool flecs_poly_is_(const ecs_poly_t *object, int32_t type)
     * }
     */
    public static MemorySegment flecs_poly_is_$address() {
        return flecs_poly_is_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool flecs_poly_is_(const ecs_poly_t *object, int32_t type)
     * }
     */
    public static boolean flecs_poly_is_(MemorySegment object, int type) {
        var mh$ = flecs_poly_is_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_poly_is_", object, type);
            }
            return (boolean)mh$.invokeExact(object, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_make_pair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_make_pair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(false));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_id_t ecs_make_pair(ecs_entity_t first, ecs_entity_t second)
     * }
     */
    public static FunctionDescriptor ecs_make_pair$descriptor() {
        return ecs_make_pair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_id_t ecs_make_pair(ecs_entity_t first, ecs_entity_t second)
     * }
     */
    public static MethodHandle ecs_make_pair$handle() {
        return ecs_make_pair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_id_t ecs_make_pair(ecs_entity_t first, ecs_entity_t second)
     * }
     */
    public static MemorySegment ecs_make_pair$address() {
        return ecs_make_pair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_id_t ecs_make_pair(ecs_entity_t first, ecs_entity_t second)
     * }
     */
    public static long ecs_make_pair(long first, long second) {
        var mh$ = ecs_make_pair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_make_pair", first, second);
            }
            return (long)mh$.invokeExact(first, second);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_exclusive_access_begin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_exclusive_access_begin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_exclusive_access_begin(ecs_world_t *world, const char *thread_name)
     * }
     */
    public static FunctionDescriptor ecs_exclusive_access_begin$descriptor() {
        return ecs_exclusive_access_begin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_exclusive_access_begin(ecs_world_t *world, const char *thread_name)
     * }
     */
    public static MethodHandle ecs_exclusive_access_begin$handle() {
        return ecs_exclusive_access_begin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_exclusive_access_begin(ecs_world_t *world, const char *thread_name)
     * }
     */
    public static MemorySegment ecs_exclusive_access_begin$address() {
        return ecs_exclusive_access_begin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_exclusive_access_begin(ecs_world_t *world, const char *thread_name)
     * }
     */
    public static void ecs_exclusive_access_begin(MemorySegment world, MemorySegment thread_name) {
        var mh$ = ecs_exclusive_access_begin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_exclusive_access_begin", world, thread_name);
            }
            mh$.invokeExact(world, thread_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_exclusive_access_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_exclusive_access_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_exclusive_access_end(ecs_world_t *world, _Bool lock_world)
     * }
     */
    public static FunctionDescriptor ecs_exclusive_access_end$descriptor() {
        return ecs_exclusive_access_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_exclusive_access_end(ecs_world_t *world, _Bool lock_world)
     * }
     */
    public static MethodHandle ecs_exclusive_access_end$handle() {
        return ecs_exclusive_access_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_exclusive_access_end(ecs_world_t *world, _Bool lock_world)
     * }
     */
    public static MemorySegment ecs_exclusive_access_end$address() {
        return ecs_exclusive_access_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_exclusive_access_end(ecs_world_t *world, _Bool lock_world)
     * }
     */
    public static void ecs_exclusive_access_end(MemorySegment world, boolean lock_world) {
        var mh$ = ecs_exclusive_access_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_exclusive_access_end", world, lock_world);
            }
            mh$.invokeExact(world, lock_world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(false));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_new$descriptor() {
        return ecs_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_new$handle() {
        return ecs_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_new$address() {
        return ecs_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_new(ecs_world_t *world)
     * }
     */
    public static long ecs_new(MemorySegment world) {
        var mh$ = ecs_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_new", world);
            }
            return (long)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_new_low_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_new_low_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_low_id(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_new_low_id$descriptor() {
        return ecs_new_low_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_low_id(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_new_low_id$handle() {
        return ecs_new_low_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_low_id(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_new_low_id$address() {
        return ecs_new_low_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_low_id(ecs_world_t *world)
     * }
     */
    public static long ecs_new_low_id(MemorySegment world) {
        var mh$ = ecs_new_low_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_new_low_id", world);
            }
            return (long)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_new_w_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_new_w_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(false));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_w_id(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_new_w_id$descriptor() {
        return ecs_new_w_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_w_id(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_new_w_id$handle() {
        return ecs_new_w_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_w_id(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_new_w_id$address() {
        return ecs_new_w_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_w_id(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static long ecs_new_w_id(MemorySegment world, long component) {
        var mh$ = ecs_new_w_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_new_w_id", world, component);
            }
            return (long)mh$.invokeExact(world, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_new_w_table {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_new_w_table");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_w_table(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_new_w_table$descriptor() {
        return ecs_new_w_table.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_w_table(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_new_w_table$handle() {
        return ecs_new_w_table.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_w_table(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_new_w_table$address() {
        return ecs_new_w_table.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_w_table(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static long ecs_new_w_table(MemorySegment world, MemorySegment table) {
        var mh$ = ecs_new_w_table.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_new_w_table", world, table);
            }
            return (long)mh$.invokeExact(world, table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_entity_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_entity_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_entity_init(ecs_world_t *world, const ecs_entity_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_entity_init$descriptor() {
        return ecs_entity_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_entity_init(ecs_world_t *world, const ecs_entity_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_entity_init$handle() {
        return ecs_entity_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_entity_init(ecs_world_t *world, const ecs_entity_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_entity_init$address() {
        return ecs_entity_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_entity_init(ecs_world_t *world, const ecs_entity_desc_t *desc)
     * }
     */
    public static long ecs_entity_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_entity_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_entity_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_bulk_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_bulk_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_bulk_init(ecs_world_t *world, const ecs_bulk_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_bulk_init$descriptor() {
        return ecs_bulk_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_bulk_init(ecs_world_t *world, const ecs_bulk_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_bulk_init$handle() {
        return ecs_bulk_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_bulk_init(ecs_world_t *world, const ecs_bulk_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_bulk_init$address() {
        return ecs_bulk_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_bulk_init(ecs_world_t *world, const ecs_bulk_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_bulk_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_bulk_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_bulk_init", world, desc);
            }
            return (MemorySegment)mh$.invokeExact(world, desc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_bulk_new_w_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_bulk_new_w_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_bulk_new_w_id(ecs_world_t *world, ecs_id_t component, int32_t count)
     * }
     */
    public static FunctionDescriptor ecs_bulk_new_w_id$descriptor() {
        return ecs_bulk_new_w_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_bulk_new_w_id(ecs_world_t *world, ecs_id_t component, int32_t count)
     * }
     */
    public static MethodHandle ecs_bulk_new_w_id$handle() {
        return ecs_bulk_new_w_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_bulk_new_w_id(ecs_world_t *world, ecs_id_t component, int32_t count)
     * }
     */
    public static MemorySegment ecs_bulk_new_w_id$address() {
        return ecs_bulk_new_w_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_bulk_new_w_id(ecs_world_t *world, ecs_id_t component, int32_t count)
     * }
     */
    public static MemorySegment ecs_bulk_new_w_id(MemorySegment world, long component, int count) {
        var mh$ = ecs_bulk_new_w_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_bulk_new_w_id", world, component, count);
            }
            return (MemorySegment)mh$.invokeExact(world, component, count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG,
            flecs_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_clone(ecs_world_t *world, ecs_entity_t dst, ecs_entity_t src, _Bool copy_value)
     * }
     */
    public static FunctionDescriptor ecs_clone$descriptor() {
        return ecs_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_clone(ecs_world_t *world, ecs_entity_t dst, ecs_entity_t src, _Bool copy_value)
     * }
     */
    public static MethodHandle ecs_clone$handle() {
        return ecs_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_clone(ecs_world_t *world, ecs_entity_t dst, ecs_entity_t src, _Bool copy_value)
     * }
     */
    public static MemorySegment ecs_clone$address() {
        return ecs_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_clone(ecs_world_t *world, ecs_entity_t dst, ecs_entity_t src, _Bool copy_value)
     * }
     */
    public static long ecs_clone(MemorySegment world, long dst, long src, boolean copy_value) {
        var mh$ = ecs_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_clone", world, dst, src, copy_value);
            }
            return (long)mh$.invokeExact(world, dst, src, copy_value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_delete(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_delete$descriptor() {
        return ecs_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_delete(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_delete$handle() {
        return ecs_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_delete(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_delete$address() {
        return ecs_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_delete(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static void ecs_delete(MemorySegment world, long entity) {
        var mh$ = ecs_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_delete", world, entity);
            }
            mh$.invokeExact(world, entity);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_delete_with {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_delete_with");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_delete_with(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_delete_with$descriptor() {
        return ecs_delete_with.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_delete_with(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_delete_with$handle() {
        return ecs_delete_with.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_delete_with(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_delete_with$address() {
        return ecs_delete_with.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_delete_with(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static void ecs_delete_with(MemorySegment world, long component) {
        var mh$ = ecs_delete_with.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_delete_with", world, component);
            }
            mh$.invokeExact(world, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_child_order {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_set_child_order");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_child_order(ecs_world_t *world, ecs_entity_t parent, const ecs_entity_t *children, int32_t child_count)
     * }
     */
    public static FunctionDescriptor ecs_set_child_order$descriptor() {
        return ecs_set_child_order.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_child_order(ecs_world_t *world, ecs_entity_t parent, const ecs_entity_t *children, int32_t child_count)
     * }
     */
    public static MethodHandle ecs_set_child_order$handle() {
        return ecs_set_child_order.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_child_order(ecs_world_t *world, ecs_entity_t parent, const ecs_entity_t *children, int32_t child_count)
     * }
     */
    public static MemorySegment ecs_set_child_order$address() {
        return ecs_set_child_order.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_child_order(ecs_world_t *world, ecs_entity_t parent, const ecs_entity_t *children, int32_t child_count)
     * }
     */
    public static void ecs_set_child_order(MemorySegment world, long parent, MemorySegment children, int child_count) {
        var mh$ = ecs_set_child_order.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_child_order", world, parent, children, child_count);
            }
            mh$.invokeExact(world, parent, children, child_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_ordered_children {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_entities_t.layout(),
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_ordered_children");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entities_t ecs_get_ordered_children(const ecs_world_t *world, ecs_entity_t parent)
     * }
     */
    public static FunctionDescriptor ecs_get_ordered_children$descriptor() {
        return ecs_get_ordered_children.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entities_t ecs_get_ordered_children(const ecs_world_t *world, ecs_entity_t parent)
     * }
     */
    public static MethodHandle ecs_get_ordered_children$handle() {
        return ecs_get_ordered_children.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entities_t ecs_get_ordered_children(const ecs_world_t *world, ecs_entity_t parent)
     * }
     */
    public static MemorySegment ecs_get_ordered_children$address() {
        return ecs_get_ordered_children.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entities_t ecs_get_ordered_children(const ecs_world_t *world, ecs_entity_t parent)
     * }
     */
    public static MemorySegment ecs_get_ordered_children(SegmentAllocator allocator, MemorySegment world, long parent) {
        var mh$ = ecs_get_ordered_children.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_ordered_children", allocator, world, parent);
            }
            return (MemorySegment)mh$.invokeExact(allocator, world, parent);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_add_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_add_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_add_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_add_id$descriptor() {
        return ecs_add_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_add_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_add_id$handle() {
        return ecs_add_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_add_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_add_id$address() {
        return ecs_add_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_add_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static void ecs_add_id(MemorySegment world, long entity, long component) {
        var mh$ = ecs_add_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_add_id", world, entity, component);
            }
            mh$.invokeExact(world, entity, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_remove_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_remove_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_remove_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_remove_id$descriptor() {
        return ecs_remove_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_remove_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_remove_id$handle() {
        return ecs_remove_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_remove_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_remove_id$address() {
        return ecs_remove_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_remove_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static void ecs_remove_id(MemorySegment world, long entity, long component) {
        var mh$ = ecs_remove_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_remove_id", world, entity, component);
            }
            mh$.invokeExact(world, entity, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_auto_override_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_auto_override_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_auto_override_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_auto_override_id$descriptor() {
        return ecs_auto_override_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_auto_override_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_auto_override_id$handle() {
        return ecs_auto_override_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_auto_override_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_auto_override_id$address() {
        return ecs_auto_override_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_auto_override_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static void ecs_auto_override_id(MemorySegment world, long entity, long component) {
        var mh$ = ecs_auto_override_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_auto_override_id", world, entity, component);
            }
            mh$.invokeExact(world, entity, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_clear(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_clear$descriptor() {
        return ecs_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_clear(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_clear$handle() {
        return ecs_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_clear(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_clear$address() {
        return ecs_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_clear(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static void ecs_clear(MemorySegment world, long entity) {
        var mh$ = ecs_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_clear", world, entity);
            }
            mh$.invokeExact(world, entity);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_remove_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_remove_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_remove_all(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_remove_all$descriptor() {
        return ecs_remove_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_remove_all(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_remove_all$handle() {
        return ecs_remove_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_remove_all(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_remove_all$address() {
        return ecs_remove_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_remove_all(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static void ecs_remove_all(MemorySegment world, long component) {
        var mh$ = ecs_remove_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_remove_all", world, component);
            }
            mh$.invokeExact(world, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_with {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_set_with");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_with(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_set_with$descriptor() {
        return ecs_set_with.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_with(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_set_with$handle() {
        return ecs_set_with.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_with(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_set_with$address() {
        return ecs_set_with.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_with(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static long ecs_set_with(MemorySegment world, long component) {
        var mh$ = ecs_set_with.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_with", world, component);
            }
            return (long)mh$.invokeExact(world, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_with {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_with");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_id_t ecs_get_with(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_with$descriptor() {
        return ecs_get_with.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_id_t ecs_get_with(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_with$handle() {
        return ecs_get_with.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_id_t ecs_get_with(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_with$address() {
        return ecs_get_with.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_id_t ecs_get_with(const ecs_world_t *world)
     * }
     */
    public static long ecs_get_with(MemorySegment world) {
        var mh$ = ecs_get_with.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_with", world);
            }
            return (long)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_enable(ecs_world_t *world, ecs_entity_t entity, _Bool enabled)
     * }
     */
    public static FunctionDescriptor ecs_enable$descriptor() {
        return ecs_enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_enable(ecs_world_t *world, ecs_entity_t entity, _Bool enabled)
     * }
     */
    public static MethodHandle ecs_enable$handle() {
        return ecs_enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_enable(ecs_world_t *world, ecs_entity_t entity, _Bool enabled)
     * }
     */
    public static MemorySegment ecs_enable$address() {
        return ecs_enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_enable(ecs_world_t *world, ecs_entity_t entity, _Bool enabled)
     * }
     */
    public static void ecs_enable(MemorySegment world, long entity, boolean enabled) {
        var mh$ = ecs_enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_enable", world, entity, enabled);
            }
            mh$.invokeExact(world, entity, enabled);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_enable_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG,
            flecs_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_enable_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_enable_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component, _Bool enable)
     * }
     */
    public static FunctionDescriptor ecs_enable_id$descriptor() {
        return ecs_enable_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_enable_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component, _Bool enable)
     * }
     */
    public static MethodHandle ecs_enable_id$handle() {
        return ecs_enable_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_enable_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component, _Bool enable)
     * }
     */
    public static MemorySegment ecs_enable_id$address() {
        return ecs_enable_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_enable_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component, _Bool enable)
     * }
     */
    public static void ecs_enable_id(MemorySegment world, long entity, long component, boolean enable) {
        var mh$ = ecs_enable_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_enable_id", world, entity, component, enable);
            }
            mh$.invokeExact(world, entity, component, enable);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_is_enabled_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_is_enabled_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_is_enabled_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_is_enabled_id$descriptor() {
        return ecs_is_enabled_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_is_enabled_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_is_enabled_id$handle() {
        return ecs_is_enabled_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_is_enabled_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_is_enabled_id$address() {
        return ecs_is_enabled_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_is_enabled_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static boolean ecs_is_enabled_id(MemorySegment world, long entity, long component) {
        var mh$ = ecs_is_enabled_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_is_enabled_id", world, entity, component);
            }
            return (boolean)mh$.invokeExact(world, entity, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(false));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const void *ecs_get_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_get_id$descriptor() {
        return ecs_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const void *ecs_get_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_get_id$handle() {
        return ecs_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const void *ecs_get_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_get_id$address() {
        return ecs_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const void *ecs_get_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static long ecs_get_id(MemorySegment world, long entity, long component) {
        var mh$ = ecs_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_id", world, entity, component);
            }
            return (long)mh$.invokeExact(world, entity, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_mut_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_mut_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_get_mut_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_get_mut_id$descriptor() {
        return ecs_get_mut_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_get_mut_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_get_mut_id$handle() {
        return ecs_get_mut_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_get_mut_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_get_mut_id$address() {
        return ecs_get_mut_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_get_mut_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_get_mut_id(MemorySegment world, long entity, long component) {
        var mh$ = ecs_get_mut_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_mut_id", world, entity, component);
            }
            return (MemorySegment)mh$.invokeExact(world, entity, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_ensure_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_ensure_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_ensure_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component, size_t size)
     * }
     */
    public static FunctionDescriptor ecs_ensure_id$descriptor() {
        return ecs_ensure_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_ensure_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component, size_t size)
     * }
     */
    public static MethodHandle ecs_ensure_id$handle() {
        return ecs_ensure_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_ensure_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component, size_t size)
     * }
     */
    public static MemorySegment ecs_ensure_id$address() {
        return ecs_ensure_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_ensure_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component, size_t size)
     * }
     */
    public static MemorySegment ecs_ensure_id(MemorySegment world, long entity, long component, long size) {
        var mh$ = ecs_ensure_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_ensure_id", world, entity, component, size);
            }
            return (MemorySegment)mh$.invokeExact(world, entity, component, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_ref_init_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_ref_t.layout(),
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_ref_init_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_ref_t ecs_ref_init_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_ref_init_id$descriptor() {
        return ecs_ref_init_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_ref_t ecs_ref_init_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_ref_init_id$handle() {
        return ecs_ref_init_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_ref_t ecs_ref_init_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_ref_init_id$address() {
        return ecs_ref_init_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_ref_t ecs_ref_init_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_ref_init_id(SegmentAllocator allocator, MemorySegment world, long entity, long component) {
        var mh$ = ecs_ref_init_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_ref_init_id", allocator, world, entity, component);
            }
            return (MemorySegment)mh$.invokeExact(allocator, world, entity, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_ref_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_ref_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_ref_get_id(const ecs_world_t *world, ecs_ref_t *ref, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_ref_get_id$descriptor() {
        return ecs_ref_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_ref_get_id(const ecs_world_t *world, ecs_ref_t *ref, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_ref_get_id$handle() {
        return ecs_ref_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_ref_get_id(const ecs_world_t *world, ecs_ref_t *ref, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_ref_get_id$address() {
        return ecs_ref_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_ref_get_id(const ecs_world_t *world, ecs_ref_t *ref, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_ref_get_id(MemorySegment world, MemorySegment ref, long component) {
        var mh$ = ecs_ref_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_ref_get_id", world, ref, component);
            }
            return (MemorySegment)mh$.invokeExact(world, ref, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_ref_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_ref_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_ref_update(const ecs_world_t *world, ecs_ref_t *ref)
     * }
     */
    public static FunctionDescriptor ecs_ref_update$descriptor() {
        return ecs_ref_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_ref_update(const ecs_world_t *world, ecs_ref_t *ref)
     * }
     */
    public static MethodHandle ecs_ref_update$handle() {
        return ecs_ref_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_ref_update(const ecs_world_t *world, ecs_ref_t *ref)
     * }
     */
    public static MemorySegment ecs_ref_update$address() {
        return ecs_ref_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_ref_update(const ecs_world_t *world, ecs_ref_t *ref)
     * }
     */
    public static void ecs_ref_update(MemorySegment world, MemorySegment ref) {
        var mh$ = ecs_ref_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_ref_update", world, ref);
            }
            mh$.invokeExact(world, ref);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_emplace_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_emplace_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_emplace_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component, size_t size, _Bool *is_new)
     * }
     */
    public static FunctionDescriptor ecs_emplace_id$descriptor() {
        return ecs_emplace_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_emplace_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component, size_t size, _Bool *is_new)
     * }
     */
    public static MethodHandle ecs_emplace_id$handle() {
        return ecs_emplace_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_emplace_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component, size_t size, _Bool *is_new)
     * }
     */
    public static MemorySegment ecs_emplace_id$address() {
        return ecs_emplace_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_emplace_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component, size_t size, _Bool *is_new)
     * }
     */
    public static MemorySegment ecs_emplace_id(MemorySegment world, long entity, long component, long size, MemorySegment is_new) {
        var mh$ = ecs_emplace_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_emplace_id", world, entity, component, size, is_new);
            }
            return (MemorySegment)mh$.invokeExact(world, entity, component, size, is_new);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_modified_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_modified_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_modified_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_modified_id$descriptor() {
        return ecs_modified_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_modified_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_modified_id$handle() {
        return ecs_modified_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_modified_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_modified_id$address() {
        return ecs_modified_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_modified_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static void ecs_modified_id(MemorySegment world, long entity, long component) {
        var mh$ = ecs_modified_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_modified_id", world, entity, component);
            }
            mh$.invokeExact(world, entity, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_set_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component, size_t size, const void *ptr)
     * }
     */
    public static FunctionDescriptor ecs_set_id$descriptor() {
        return ecs_set_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component, size_t size, const void *ptr)
     * }
     */
    public static MethodHandle ecs_set_id$handle() {
        return ecs_set_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component, size_t size, const void *ptr)
     * }
     */
    public static MemorySegment ecs_set_id$address() {
        return ecs_set_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t component, size_t size, const void *ptr)
     * }
     */
    public static void ecs_set_id(MemorySegment world, long entity, long component, long size, MemorySegment ptr) {
        var mh$ = ecs_set_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_id", world, entity, component, size, ptr);
            }
            mh$.invokeExact(world, entity, component, size, ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_is_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_is_valid(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static FunctionDescriptor ecs_is_valid$descriptor() {
        return ecs_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_is_valid(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static MethodHandle ecs_is_valid$handle() {
        return ecs_is_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_is_valid(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static MemorySegment ecs_is_valid$address() {
        return ecs_is_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_is_valid(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static boolean ecs_is_valid(MemorySegment world, long e) {
        var mh$ = ecs_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_is_valid", world, e);
            }
            return (boolean)mh$.invokeExact(world, e);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_is_alive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_is_alive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_is_alive(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static FunctionDescriptor ecs_is_alive$descriptor() {
        return ecs_is_alive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_is_alive(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static MethodHandle ecs_is_alive$handle() {
        return ecs_is_alive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_is_alive(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static MemorySegment ecs_is_alive$address() {
        return ecs_is_alive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_is_alive(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static boolean ecs_is_alive(MemorySegment world, long e) {
        var mh$ = ecs_is_alive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_is_alive", world, e);
            }
            return (boolean)mh$.invokeExact(world, e);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strip_generation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_strip_generation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_id_t ecs_strip_generation(ecs_entity_t e)
     * }
     */
    public static FunctionDescriptor ecs_strip_generation$descriptor() {
        return ecs_strip_generation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_id_t ecs_strip_generation(ecs_entity_t e)
     * }
     */
    public static MethodHandle ecs_strip_generation$handle() {
        return ecs_strip_generation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_id_t ecs_strip_generation(ecs_entity_t e)
     * }
     */
    public static MemorySegment ecs_strip_generation$address() {
        return ecs_strip_generation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_id_t ecs_strip_generation(ecs_entity_t e)
     * }
     */
    public static long ecs_strip_generation(long e) {
        var mh$ = ecs_strip_generation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strip_generation", e);
            }
            return (long)mh$.invokeExact(e);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_alive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_alive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_alive(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static FunctionDescriptor ecs_get_alive$descriptor() {
        return ecs_get_alive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_alive(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static MethodHandle ecs_get_alive$handle() {
        return ecs_get_alive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_alive(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static MemorySegment ecs_get_alive$address() {
        return ecs_get_alive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_alive(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static long ecs_get_alive(MemorySegment world, long e) {
        var mh$ = ecs_get_alive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_alive", world, e);
            }
            return (long)mh$.invokeExact(world, e);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_make_alive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_make_alive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_make_alive(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_make_alive$descriptor() {
        return ecs_make_alive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_make_alive(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_make_alive$handle() {
        return ecs_make_alive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_make_alive(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_make_alive$address() {
        return ecs_make_alive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_make_alive(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static void ecs_make_alive(MemorySegment world, long entity) {
        var mh$ = ecs_make_alive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_make_alive", world, entity);
            }
            mh$.invokeExact(world, entity);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_make_alive_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_make_alive_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_make_alive_id(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_make_alive_id$descriptor() {
        return ecs_make_alive_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_make_alive_id(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_make_alive_id$handle() {
        return ecs_make_alive_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_make_alive_id(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_make_alive_id$address() {
        return ecs_make_alive_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_make_alive_id(ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static void ecs_make_alive_id(MemorySegment world, long component) {
        var mh$ = ecs_make_alive_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_make_alive_id", world, component);
            }
            mh$.invokeExact(world, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_exists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_exists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_exists(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_exists$descriptor() {
        return ecs_exists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_exists(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_exists$handle() {
        return ecs_exists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_exists(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_exists$address() {
        return ecs_exists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_exists(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static boolean ecs_exists(MemorySegment world, long entity) {
        var mh$ = ecs_exists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_exists", world, entity);
            }
            return (boolean)mh$.invokeExact(world, entity);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_set_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_version(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_set_version$descriptor() {
        return ecs_set_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_version(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_set_version$handle() {
        return ecs_set_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_version(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_set_version$address() {
        return ecs_set_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_version(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static void ecs_set_version(MemorySegment world, long entity) {
        var mh$ = ecs_set_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_version", world, entity);
            }
            mh$.invokeExact(world, entity);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ecs_get_version(ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_get_version$descriptor() {
        return ecs_get_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ecs_get_version(ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_get_version$handle() {
        return ecs_get_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ecs_get_version(ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_version$address() {
        return ecs_get_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ecs_get_version(ecs_entity_t entity)
     * }
     */
    public static int ecs_get_version(long entity) {
        var mh$ = ecs_get_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_version", entity);
            }
            return (int)mh$.invokeExact(entity);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_type_t *ecs_get_type(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_get_type$descriptor() {
        return ecs_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_type_t *ecs_get_type(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_get_type$handle() {
        return ecs_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_type_t *ecs_get_type(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_type$address() {
        return ecs_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_type_t *ecs_get_type(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_type(MemorySegment world, long entity) {
        var mh$ = ecs_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_type", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_table {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_table");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_get_table(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_get_table$descriptor() {
        return ecs_get_table.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_get_table(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_get_table$handle() {
        return ecs_get_table.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_get_table(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_table$address() {
        return ecs_get_table.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_table_t *ecs_get_table(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_table(MemorySegment world, long entity) {
        var mh$ = ecs_get_table.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_table", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_type_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_type_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_type_str(const ecs_world_t *world, const ecs_type_t *type)
     * }
     */
    public static FunctionDescriptor ecs_type_str$descriptor() {
        return ecs_type_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_type_str(const ecs_world_t *world, const ecs_type_t *type)
     * }
     */
    public static MethodHandle ecs_type_str$handle() {
        return ecs_type_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_type_str(const ecs_world_t *world, const ecs_type_t *type)
     * }
     */
    public static MemorySegment ecs_type_str$address() {
        return ecs_type_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_type_str(const ecs_world_t *world, const ecs_type_t *type)
     * }
     */
    public static MemorySegment ecs_type_str(MemorySegment world, MemorySegment type) {
        var mh$ = ecs_type_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_type_str", world, type);
            }
            return (MemorySegment)mh$.invokeExact(world, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_table_str(const ecs_world_t *world, const ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_table_str$descriptor() {
        return ecs_table_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_table_str(const ecs_world_t *world, const ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_table_str$handle() {
        return ecs_table_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_table_str(const ecs_world_t *world, const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_str$address() {
        return ecs_table_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_table_str(const ecs_world_t *world, const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_str(MemorySegment world, MemorySegment table) {
        var mh$ = ecs_table_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_str", world, table);
            }
            return (MemorySegment)mh$.invokeExact(world, table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_entity_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_entity_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_entity_str(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_entity_str$descriptor() {
        return ecs_entity_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_entity_str(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_entity_str$handle() {
        return ecs_entity_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_entity_str(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_entity_str$address() {
        return ecs_entity_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_entity_str(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_entity_str(MemorySegment world, long entity) {
        var mh$ = ecs_entity_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_entity_str", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_has_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_has_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_has_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_has_id$descriptor() {
        return ecs_has_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_has_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_has_id$handle() {
        return ecs_has_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_has_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_has_id$address() {
        return ecs_has_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_has_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static boolean ecs_has_id(MemorySegment world, long entity, long component) {
        var mh$ = ecs_has_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_has_id", world, entity, component);
            }
            return (boolean)mh$.invokeExact(world, entity, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_owns_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_owns_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_owns_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_owns_id$descriptor() {
        return ecs_owns_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_owns_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_owns_id$handle() {
        return ecs_owns_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_owns_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_owns_id$address() {
        return ecs_owns_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_owns_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t component)
     * }
     */
    public static boolean ecs_owns_id(MemorySegment world, long entity, long component) {
        var mh$ = ecs_owns_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_owns_id", world, entity, component);
            }
            return (boolean)mh$.invokeExact(world, entity, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_target {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_target");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_target(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel, int32_t index)
     * }
     */
    public static FunctionDescriptor ecs_get_target$descriptor() {
        return ecs_get_target.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_target(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel, int32_t index)
     * }
     */
    public static MethodHandle ecs_get_target$handle() {
        return ecs_get_target.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_target(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel, int32_t index)
     * }
     */
    public static MemorySegment ecs_get_target$address() {
        return ecs_get_target.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_target(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel, int32_t index)
     * }
     */
    public static long ecs_get_target(MemorySegment world, long entity, long rel, int index) {
        var mh$ = ecs_get_target.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_target", world, entity, rel, index);
            }
            return (long)mh$.invokeExact(world, entity, rel, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_parent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_parent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_parent(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_get_parent$descriptor() {
        return ecs_get_parent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_parent(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_get_parent$handle() {
        return ecs_get_parent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_parent(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_parent$address() {
        return ecs_get_parent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_parent(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static long ecs_get_parent(MemorySegment world, long entity) {
        var mh$ = ecs_get_parent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_parent", world, entity);
            }
            return (long)mh$.invokeExact(world, entity);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_target_for_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_target_for_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_target_for_id(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_get_target_for_id$descriptor() {
        return ecs_get_target_for_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_target_for_id(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_get_target_for_id$handle() {
        return ecs_get_target_for_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_target_for_id(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_get_target_for_id$address() {
        return ecs_get_target_for_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_target_for_id(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel, ecs_id_t component)
     * }
     */
    public static long ecs_get_target_for_id(MemorySegment world, long entity, long rel, long component) {
        var mh$ = ecs_get_target_for_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_target_for_id", world, entity, rel, component);
            }
            return (long)mh$.invokeExact(world, entity, rel, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_depth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_depth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_get_depth(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel)
     * }
     */
    public static FunctionDescriptor ecs_get_depth$descriptor() {
        return ecs_get_depth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_get_depth(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel)
     * }
     */
    public static MethodHandle ecs_get_depth$handle() {
        return ecs_get_depth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_get_depth(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel)
     * }
     */
    public static MemorySegment ecs_get_depth$address() {
        return ecs_get_depth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_get_depth(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel)
     * }
     */
    public static int ecs_get_depth(MemorySegment world, long entity, long rel) {
        var mh$ = ecs_get_depth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_depth", world, entity, rel);
            }
            return (int)mh$.invokeExact(world, entity, rel);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_count_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_count_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_count_id(const ecs_world_t *world, ecs_id_t entity)
     * }
     */
    public static FunctionDescriptor ecs_count_id$descriptor() {
        return ecs_count_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_count_id(const ecs_world_t *world, ecs_id_t entity)
     * }
     */
    public static MethodHandle ecs_count_id$handle() {
        return ecs_count_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_count_id(const ecs_world_t *world, ecs_id_t entity)
     * }
     */
    public static MemorySegment ecs_count_id$address() {
        return ecs_count_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_count_id(const ecs_world_t *world, ecs_id_t entity)
     * }
     */
    public static int ecs_count_id(MemorySegment world, long entity) {
        var mh$ = ecs_count_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_count_id", world, entity);
            }
            return (int)mh$.invokeExact(world, entity);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_get_name(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_get_name$descriptor() {
        return ecs_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_get_name(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_get_name$handle() {
        return ecs_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_get_name(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_name$address() {
        return ecs_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_get_name(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_name(MemorySegment world, long entity) {
        var mh$ = ecs_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_name", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_symbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_symbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_get_symbol(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_get_symbol$descriptor() {
        return ecs_get_symbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_get_symbol(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_get_symbol$handle() {
        return ecs_get_symbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_get_symbol(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_symbol$address() {
        return ecs_get_symbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_get_symbol(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_symbol(MemorySegment world, long entity) {
        var mh$ = ecs_get_symbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_symbol", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_set_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_name(ecs_world_t *world, ecs_entity_t entity, const char *name)
     * }
     */
    public static FunctionDescriptor ecs_set_name$descriptor() {
        return ecs_set_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_name(ecs_world_t *world, ecs_entity_t entity, const char *name)
     * }
     */
    public static MethodHandle ecs_set_name$handle() {
        return ecs_set_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_name(ecs_world_t *world, ecs_entity_t entity, const char *name)
     * }
     */
    public static MemorySegment ecs_set_name$address() {
        return ecs_set_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_name(ecs_world_t *world, ecs_entity_t entity, const char *name)
     * }
     */
    public static long ecs_set_name(MemorySegment world, long entity, MemorySegment name) {
        var mh$ = ecs_set_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_name", world, entity, name);
            }
            return (long)mh$.invokeExact(world, entity, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_symbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_set_symbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_symbol(ecs_world_t *world, ecs_entity_t entity, const char *symbol)
     * }
     */
    public static FunctionDescriptor ecs_set_symbol$descriptor() {
        return ecs_set_symbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_symbol(ecs_world_t *world, ecs_entity_t entity, const char *symbol)
     * }
     */
    public static MethodHandle ecs_set_symbol$handle() {
        return ecs_set_symbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_symbol(ecs_world_t *world, ecs_entity_t entity, const char *symbol)
     * }
     */
    public static MemorySegment ecs_set_symbol$address() {
        return ecs_set_symbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_symbol(ecs_world_t *world, ecs_entity_t entity, const char *symbol)
     * }
     */
    public static long ecs_set_symbol(MemorySegment world, long entity, MemorySegment symbol) {
        var mh$ = ecs_set_symbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_symbol", world, entity, symbol);
            }
            return (long)mh$.invokeExact(world, entity, symbol);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_alias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_set_alias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_alias(ecs_world_t *world, ecs_entity_t entity, const char *alias)
     * }
     */
    public static FunctionDescriptor ecs_set_alias$descriptor() {
        return ecs_set_alias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_alias(ecs_world_t *world, ecs_entity_t entity, const char *alias)
     * }
     */
    public static MethodHandle ecs_set_alias$handle() {
        return ecs_set_alias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_alias(ecs_world_t *world, ecs_entity_t entity, const char *alias)
     * }
     */
    public static MemorySegment ecs_set_alias$address() {
        return ecs_set_alias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_alias(ecs_world_t *world, ecs_entity_t entity, const char *alias)
     * }
     */
    public static void ecs_set_alias(MemorySegment world, long entity, MemorySegment alias) {
        var mh$ = ecs_set_alias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_alias", world, entity, alias);
            }
            mh$.invokeExact(world, entity, alias);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(false));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup(const ecs_world_t *world, const char *path)
     * }
     */
    public static FunctionDescriptor ecs_lookup$descriptor() {
        return ecs_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup(const ecs_world_t *world, const char *path)
     * }
     */
    public static MethodHandle ecs_lookup$handle() {
        return ecs_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup(const ecs_world_t *world, const char *path)
     * }
     */
    public static MemorySegment ecs_lookup$address() {
        return ecs_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup(const ecs_world_t *world, const char *path)
     * }
     */
    public static long ecs_lookup(MemorySegment world, MemorySegment path) {
        var mh$ = ecs_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_lookup", world, path);
            }
            return (long)mh$.invokeExact(world, path);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_lookup_child {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_lookup_child");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(false));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_child(const ecs_world_t *world, ecs_entity_t parent, const char *name)
     * }
     */
    public static FunctionDescriptor ecs_lookup_child$descriptor() {
        return ecs_lookup_child.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_child(const ecs_world_t *world, ecs_entity_t parent, const char *name)
     * }
     */
    public static MethodHandle ecs_lookup_child$handle() {
        return ecs_lookup_child.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_child(const ecs_world_t *world, ecs_entity_t parent, const char *name)
     * }
     */
    public static MemorySegment ecs_lookup_child$address() {
        return ecs_lookup_child.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_child(const ecs_world_t *world, ecs_entity_t parent, const char *name)
     * }
     */
    public static long ecs_lookup_child(MemorySegment world, long parent, MemorySegment name) {
        var mh$ = ecs_lookup_child.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_lookup_child", world, parent, name);
            }
            return (long)mh$.invokeExact(world, parent, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_lookup_path_w_sep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_lookup_path_w_sep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix, _Bool recursive)
     * }
     */
    public static FunctionDescriptor ecs_lookup_path_w_sep$descriptor() {
        return ecs_lookup_path_w_sep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix, _Bool recursive)
     * }
     */
    public static MethodHandle ecs_lookup_path_w_sep$handle() {
        return ecs_lookup_path_w_sep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix, _Bool recursive)
     * }
     */
    public static MemorySegment ecs_lookup_path_w_sep$address() {
        return ecs_lookup_path_w_sep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix, _Bool recursive)
     * }
     */
    public static long ecs_lookup_path_w_sep(MemorySegment world, long parent, MemorySegment path, MemorySegment sep, MemorySegment prefix, boolean recursive) {
        var mh$ = ecs_lookup_path_w_sep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_lookup_path_w_sep", world, parent, path, sep, prefix, recursive);
            }
            return (long)mh$.invokeExact(world, parent, path, sep, prefix, recursive);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_lookup_symbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_BOOL,
            flecs_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_lookup_symbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_symbol(const ecs_world_t *world, const char *symbol, _Bool lookup_as_path, _Bool recursive)
     * }
     */
    public static FunctionDescriptor ecs_lookup_symbol$descriptor() {
        return ecs_lookup_symbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_symbol(const ecs_world_t *world, const char *symbol, _Bool lookup_as_path, _Bool recursive)
     * }
     */
    public static MethodHandle ecs_lookup_symbol$handle() {
        return ecs_lookup_symbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_symbol(const ecs_world_t *world, const char *symbol, _Bool lookup_as_path, _Bool recursive)
     * }
     */
    public static MemorySegment ecs_lookup_symbol$address() {
        return ecs_lookup_symbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_symbol(const ecs_world_t *world, const char *symbol, _Bool lookup_as_path, _Bool recursive)
     * }
     */
    public static long ecs_lookup_symbol(MemorySegment world, MemorySegment symbol, boolean lookup_as_path, boolean recursive) {
        var mh$ = ecs_lookup_symbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_lookup_symbol", world, symbol, lookup_as_path, recursive);
            }
            return (long)mh$.invokeExact(world, symbol, lookup_as_path, recursive);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_path_w_sep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_path_w_sep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_get_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix)
     * }
     */
    public static FunctionDescriptor ecs_get_path_w_sep$descriptor() {
        return ecs_get_path_w_sep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_get_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix)
     * }
     */
    public static MethodHandle ecs_get_path_w_sep$handle() {
        return ecs_get_path_w_sep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_get_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix)
     * }
     */
    public static MemorySegment ecs_get_path_w_sep$address() {
        return ecs_get_path_w_sep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_get_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix)
     * }
     */
    public static MemorySegment ecs_get_path_w_sep(MemorySegment world, long parent, long child, MemorySegment sep, MemorySegment prefix) {
        var mh$ = ecs_get_path_w_sep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_path_w_sep", world, parent, child, sep, prefix);
            }
            return (MemorySegment)mh$.invokeExact(world, parent, child, sep, prefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_path_w_sep_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_path_w_sep_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_get_path_w_sep_buf(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix, ecs_strbuf_t *buf, _Bool escape)
     * }
     */
    public static FunctionDescriptor ecs_get_path_w_sep_buf$descriptor() {
        return ecs_get_path_w_sep_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_get_path_w_sep_buf(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix, ecs_strbuf_t *buf, _Bool escape)
     * }
     */
    public static MethodHandle ecs_get_path_w_sep_buf$handle() {
        return ecs_get_path_w_sep_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_get_path_w_sep_buf(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix, ecs_strbuf_t *buf, _Bool escape)
     * }
     */
    public static MemorySegment ecs_get_path_w_sep_buf$address() {
        return ecs_get_path_w_sep_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_get_path_w_sep_buf(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix, ecs_strbuf_t *buf, _Bool escape)
     * }
     */
    public static void ecs_get_path_w_sep_buf(MemorySegment world, long parent, long child, MemorySegment sep, MemorySegment prefix, MemorySegment buf, boolean escape) {
        var mh$ = ecs_get_path_w_sep_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_path_w_sep_buf", world, parent, child, sep, prefix, buf, escape);
            }
            mh$.invokeExact(world, parent, child, sep, prefix, buf, escape);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_new_from_path_w_sep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_new_from_path_w_sep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_from_path_w_sep(ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix)
     * }
     */
    public static FunctionDescriptor ecs_new_from_path_w_sep$descriptor() {
        return ecs_new_from_path_w_sep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_from_path_w_sep(ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix)
     * }
     */
    public static MethodHandle ecs_new_from_path_w_sep$handle() {
        return ecs_new_from_path_w_sep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_from_path_w_sep(ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix)
     * }
     */
    public static MemorySegment ecs_new_from_path_w_sep$address() {
        return ecs_new_from_path_w_sep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_from_path_w_sep(ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix)
     * }
     */
    public static long ecs_new_from_path_w_sep(MemorySegment world, long parent, MemorySegment path, MemorySegment sep, MemorySegment prefix) {
        var mh$ = ecs_new_from_path_w_sep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_new_from_path_w_sep", world, parent, path, sep, prefix);
            }
            return (long)mh$.invokeExact(world, parent, path, sep, prefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_add_path_w_sep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_add_path_w_sep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_add_path_w_sep(ecs_world_t *world, ecs_entity_t entity, ecs_entity_t parent, const char *path, const char *sep, const char *prefix)
     * }
     */
    public static FunctionDescriptor ecs_add_path_w_sep$descriptor() {
        return ecs_add_path_w_sep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_add_path_w_sep(ecs_world_t *world, ecs_entity_t entity, ecs_entity_t parent, const char *path, const char *sep, const char *prefix)
     * }
     */
    public static MethodHandle ecs_add_path_w_sep$handle() {
        return ecs_add_path_w_sep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_add_path_w_sep(ecs_world_t *world, ecs_entity_t entity, ecs_entity_t parent, const char *path, const char *sep, const char *prefix)
     * }
     */
    public static MemorySegment ecs_add_path_w_sep$address() {
        return ecs_add_path_w_sep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_add_path_w_sep(ecs_world_t *world, ecs_entity_t entity, ecs_entity_t parent, const char *path, const char *sep, const char *prefix)
     * }
     */
    public static long ecs_add_path_w_sep(MemorySegment world, long entity, long parent, MemorySegment path, MemorySegment sep, MemorySegment prefix) {
        var mh$ = ecs_add_path_w_sep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_add_path_w_sep", world, entity, parent, path, sep, prefix);
            }
            return (long)mh$.invokeExact(world, entity, parent, path, sep, prefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_scope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_set_scope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_scope(ecs_world_t *world, ecs_entity_t scope)
     * }
     */
    public static FunctionDescriptor ecs_set_scope$descriptor() {
        return ecs_set_scope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_scope(ecs_world_t *world, ecs_entity_t scope)
     * }
     */
    public static MethodHandle ecs_set_scope$handle() {
        return ecs_set_scope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_scope(ecs_world_t *world, ecs_entity_t scope)
     * }
     */
    public static MemorySegment ecs_set_scope$address() {
        return ecs_set_scope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_scope(ecs_world_t *world, ecs_entity_t scope)
     * }
     */
    public static long ecs_set_scope(MemorySegment world, long scope) {
        var mh$ = ecs_set_scope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_scope", world, scope);
            }
            return (long)mh$.invokeExact(world, scope);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_scope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_scope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_scope(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_scope$descriptor() {
        return ecs_get_scope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_scope(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_scope$handle() {
        return ecs_get_scope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_scope(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_scope$address() {
        return ecs_get_scope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_scope(const ecs_world_t *world)
     * }
     */
    public static long ecs_get_scope(MemorySegment world) {
        var mh$ = ecs_get_scope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_scope", world);
            }
            return (long)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_name_prefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_set_name_prefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_set_name_prefix(ecs_world_t *world, const char *prefix)
     * }
     */
    public static FunctionDescriptor ecs_set_name_prefix$descriptor() {
        return ecs_set_name_prefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_set_name_prefix(ecs_world_t *world, const char *prefix)
     * }
     */
    public static MethodHandle ecs_set_name_prefix$handle() {
        return ecs_set_name_prefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_set_name_prefix(ecs_world_t *world, const char *prefix)
     * }
     */
    public static MemorySegment ecs_set_name_prefix$address() {
        return ecs_set_name_prefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_set_name_prefix(ecs_world_t *world, const char *prefix)
     * }
     */
    public static MemorySegment ecs_set_name_prefix(MemorySegment world, MemorySegment prefix) {
        var mh$ = ecs_set_name_prefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_name_prefix", world, prefix);
            }
            return (MemorySegment)mh$.invokeExact(world, prefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_lookup_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_set_lookup_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t *ecs_set_lookup_path(ecs_world_t *world, const ecs_entity_t *lookup_path)
     * }
     */
    public static FunctionDescriptor ecs_set_lookup_path$descriptor() {
        return ecs_set_lookup_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t *ecs_set_lookup_path(ecs_world_t *world, const ecs_entity_t *lookup_path)
     * }
     */
    public static MethodHandle ecs_set_lookup_path$handle() {
        return ecs_set_lookup_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t *ecs_set_lookup_path(ecs_world_t *world, const ecs_entity_t *lookup_path)
     * }
     */
    public static MemorySegment ecs_set_lookup_path$address() {
        return ecs_set_lookup_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t *ecs_set_lookup_path(ecs_world_t *world, const ecs_entity_t *lookup_path)
     * }
     */
    public static MemorySegment ecs_set_lookup_path(MemorySegment world, MemorySegment lookup_path) {
        var mh$ = ecs_set_lookup_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_lookup_path", world, lookup_path);
            }
            return (MemorySegment)mh$.invokeExact(world, lookup_path);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_lookup_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_lookup_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t *ecs_get_lookup_path(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_lookup_path$descriptor() {
        return ecs_get_lookup_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t *ecs_get_lookup_path(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_lookup_path$handle() {
        return ecs_get_lookup_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t *ecs_get_lookup_path(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_lookup_path$address() {
        return ecs_get_lookup_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t *ecs_get_lookup_path(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_lookup_path(MemorySegment world) {
        var mh$ = ecs_get_lookup_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_lookup_path", world);
            }
            return (MemorySegment)mh$.invokeExact(world);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_component_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_component_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_component_init(ecs_world_t *world, const ecs_component_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_component_init$descriptor() {
        return ecs_component_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_component_init(ecs_world_t *world, const ecs_component_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_component_init$handle() {
        return ecs_component_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_component_init(ecs_world_t *world, const ecs_component_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_component_init$address() {
        return ecs_component_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_component_init(ecs_world_t *world, const ecs_component_desc_t *desc)
     * }
     */
    public static long ecs_component_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_component_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_component_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_type_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_type_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_type_info_t *ecs_get_type_info(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_get_type_info$descriptor() {
        return ecs_get_type_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_type_info_t *ecs_get_type_info(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_get_type_info$handle() {
        return ecs_get_type_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_type_info_t *ecs_get_type_info(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_get_type_info$address() {
        return ecs_get_type_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_type_info_t *ecs_get_type_info(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_get_type_info(MemorySegment world, long component) {
        var mh$ = ecs_get_type_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_type_info", world, component);
            }
            return (MemorySegment)mh$.invokeExact(world, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_hooks_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_set_hooks_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_hooks_id(ecs_world_t *world, ecs_entity_t component, const ecs_type_hooks_t *hooks)
     * }
     */
    public static FunctionDescriptor ecs_set_hooks_id$descriptor() {
        return ecs_set_hooks_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_hooks_id(ecs_world_t *world, ecs_entity_t component, const ecs_type_hooks_t *hooks)
     * }
     */
    public static MethodHandle ecs_set_hooks_id$handle() {
        return ecs_set_hooks_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_hooks_id(ecs_world_t *world, ecs_entity_t component, const ecs_type_hooks_t *hooks)
     * }
     */
    public static MemorySegment ecs_set_hooks_id$address() {
        return ecs_set_hooks_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_hooks_id(ecs_world_t *world, ecs_entity_t component, const ecs_type_hooks_t *hooks)
     * }
     */
    public static void ecs_set_hooks_id(MemorySegment world, long component, MemorySegment hooks) {
        var mh$ = ecs_set_hooks_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_hooks_id", world, component, hooks);
            }
            mh$.invokeExact(world, component, hooks);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_hooks_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_hooks_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_type_hooks_t *ecs_get_hooks_id(const ecs_world_t *world, ecs_entity_t component)
     * }
     */
    public static FunctionDescriptor ecs_get_hooks_id$descriptor() {
        return ecs_get_hooks_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_type_hooks_t *ecs_get_hooks_id(const ecs_world_t *world, ecs_entity_t component)
     * }
     */
    public static MethodHandle ecs_get_hooks_id$handle() {
        return ecs_get_hooks_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_type_hooks_t *ecs_get_hooks_id(const ecs_world_t *world, ecs_entity_t component)
     * }
     */
    public static MemorySegment ecs_get_hooks_id$address() {
        return ecs_get_hooks_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_type_hooks_t *ecs_get_hooks_id(const ecs_world_t *world, ecs_entity_t component)
     * }
     */
    public static MemorySegment ecs_get_hooks_id(MemorySegment world, long component) {
        var mh$ = ecs_get_hooks_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_hooks_id", world, component);
            }
            return (MemorySegment)mh$.invokeExact(world, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_is_tag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_id_is_tag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_id_is_tag(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_id_is_tag$descriptor() {
        return ecs_id_is_tag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_id_is_tag(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_id_is_tag$handle() {
        return ecs_id_is_tag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_id_is_tag(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_id_is_tag$address() {
        return ecs_id_is_tag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_id_is_tag(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static boolean ecs_id_is_tag(MemorySegment world, long component) {
        var mh$ = ecs_id_is_tag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_is_tag", world, component);
            }
            return (boolean)mh$.invokeExact(world, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_in_use {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_id_in_use");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_id_in_use(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_id_in_use$descriptor() {
        return ecs_id_in_use.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_id_in_use(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_id_in_use$handle() {
        return ecs_id_in_use.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_id_in_use(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_id_in_use$address() {
        return ecs_id_in_use.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_id_in_use(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static boolean ecs_id_in_use(MemorySegment world, long component) {
        var mh$ = ecs_id_in_use.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_in_use", world, component);
            }
            return (boolean)mh$.invokeExact(world, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_typeid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_get_typeid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_typeid(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_get_typeid$descriptor() {
        return ecs_get_typeid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_typeid(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_get_typeid$handle() {
        return ecs_get_typeid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_typeid(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_get_typeid$address() {
        return ecs_get_typeid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_typeid(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static long ecs_get_typeid(MemorySegment world, long component) {
        var mh$ = ecs_get_typeid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_typeid", world, component);
            }
            return (long)mh$.invokeExact(world, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_match {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_id_match");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_id_match(ecs_id_t component, ecs_id_t pattern)
     * }
     */
    public static FunctionDescriptor ecs_id_match$descriptor() {
        return ecs_id_match.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_id_match(ecs_id_t component, ecs_id_t pattern)
     * }
     */
    public static MethodHandle ecs_id_match$handle() {
        return ecs_id_match.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_id_match(ecs_id_t component, ecs_id_t pattern)
     * }
     */
    public static MemorySegment ecs_id_match$address() {
        return ecs_id_match.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_id_match(ecs_id_t component, ecs_id_t pattern)
     * }
     */
    public static boolean ecs_id_match(long component, long pattern) {
        var mh$ = ecs_id_match.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_match", component, pattern);
            }
            return (boolean)mh$.invokeExact(component, pattern);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_is_pair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_id_is_pair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_id_is_pair(ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_id_is_pair$descriptor() {
        return ecs_id_is_pair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_id_is_pair(ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_id_is_pair$handle() {
        return ecs_id_is_pair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_id_is_pair(ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_id_is_pair$address() {
        return ecs_id_is_pair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_id_is_pair(ecs_id_t component)
     * }
     */
    public static boolean ecs_id_is_pair(long component) {
        var mh$ = ecs_id_is_pair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_is_pair", component);
            }
            return (boolean)mh$.invokeExact(component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_is_wildcard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_id_is_wildcard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_id_is_wildcard(ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_id_is_wildcard$descriptor() {
        return ecs_id_is_wildcard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_id_is_wildcard(ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_id_is_wildcard$handle() {
        return ecs_id_is_wildcard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_id_is_wildcard(ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_id_is_wildcard$address() {
        return ecs_id_is_wildcard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_id_is_wildcard(ecs_id_t component)
     * }
     */
    public static boolean ecs_id_is_wildcard(long component) {
        var mh$ = ecs_id_is_wildcard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_is_wildcard", component);
            }
            return (boolean)mh$.invokeExact(component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_is_any {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_id_is_any");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_id_is_any(ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_id_is_any$descriptor() {
        return ecs_id_is_any.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_id_is_any(ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_id_is_any$handle() {
        return ecs_id_is_any.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_id_is_any(ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_id_is_any$address() {
        return ecs_id_is_any.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_id_is_any(ecs_id_t component)
     * }
     */
    public static boolean ecs_id_is_any(long component) {
        var mh$ = ecs_id_is_any.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_is_any", component);
            }
            return (boolean)mh$.invokeExact(component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_id_is_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_id_is_valid(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_id_is_valid$descriptor() {
        return ecs_id_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_id_is_valid(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_id_is_valid$handle() {
        return ecs_id_is_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_id_is_valid(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_id_is_valid$address() {
        return ecs_id_is_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_id_is_valid(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static boolean ecs_id_is_valid(MemorySegment world, long component) {
        var mh$ = ecs_id_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_is_valid", world, component);
            }
            return (boolean)mh$.invokeExact(world, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_get_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_id_get_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_flags32_t ecs_id_get_flags(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_id_get_flags$descriptor() {
        return ecs_id_get_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_flags32_t ecs_id_get_flags(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_id_get_flags$handle() {
        return ecs_id_get_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_flags32_t ecs_id_get_flags(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_id_get_flags$address() {
        return ecs_id_get_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_flags32_t ecs_id_get_flags(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static int ecs_id_get_flags(MemorySegment world, long component) {
        var mh$ = ecs_id_get_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_get_flags", world, component);
            }
            return (int)mh$.invokeExact(world, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_flag_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_id_flag_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_id_flag_str(ecs_id_t component_flags)
     * }
     */
    public static FunctionDescriptor ecs_id_flag_str$descriptor() {
        return ecs_id_flag_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_id_flag_str(ecs_id_t component_flags)
     * }
     */
    public static MethodHandle ecs_id_flag_str$handle() {
        return ecs_id_flag_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_id_flag_str(ecs_id_t component_flags)
     * }
     */
    public static MemorySegment ecs_id_flag_str$address() {
        return ecs_id_flag_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_id_flag_str(ecs_id_t component_flags)
     * }
     */
    public static MemorySegment ecs_id_flag_str(long component_flags) {
        var mh$ = ecs_id_flag_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_flag_str", component_flags);
            }
            return (MemorySegment)mh$.invokeExact(component_flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_id_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_id_str(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_id_str$descriptor() {
        return ecs_id_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_id_str(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_id_str$handle() {
        return ecs_id_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_id_str(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_id_str$address() {
        return ecs_id_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_id_str(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_id_str(MemorySegment world, long component) {
        var mh$ = ecs_id_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_str", world, component);
            }
            return (MemorySegment)mh$.invokeExact(world, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_str_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_id_str_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_id_str_buf(const ecs_world_t *world, ecs_id_t component, ecs_strbuf_t *buf)
     * }
     */
    public static FunctionDescriptor ecs_id_str_buf$descriptor() {
        return ecs_id_str_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_id_str_buf(const ecs_world_t *world, ecs_id_t component, ecs_strbuf_t *buf)
     * }
     */
    public static MethodHandle ecs_id_str_buf$handle() {
        return ecs_id_str_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_id_str_buf(const ecs_world_t *world, ecs_id_t component, ecs_strbuf_t *buf)
     * }
     */
    public static MemorySegment ecs_id_str_buf$address() {
        return ecs_id_str_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_id_str_buf(const ecs_world_t *world, ecs_id_t component, ecs_strbuf_t *buf)
     * }
     */
    public static void ecs_id_str_buf(MemorySegment world, long component, MemorySegment buf) {
        var mh$ = ecs_id_str_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_str_buf", world, component, buf);
            }
            mh$.invokeExact(world, component, buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_from_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_id_from_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_id_t ecs_id_from_str(const ecs_world_t *world, const char *expr)
     * }
     */
    public static FunctionDescriptor ecs_id_from_str$descriptor() {
        return ecs_id_from_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_id_t ecs_id_from_str(const ecs_world_t *world, const char *expr)
     * }
     */
    public static MethodHandle ecs_id_from_str$handle() {
        return ecs_id_from_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_id_t ecs_id_from_str(const ecs_world_t *world, const char *expr)
     * }
     */
    public static MemorySegment ecs_id_from_str$address() {
        return ecs_id_from_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_id_t ecs_id_from_str(const ecs_world_t *world, const char *expr)
     * }
     */
    public static long ecs_id_from_str(MemorySegment world, MemorySegment expr) {
        var mh$ = ecs_id_from_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_from_str", world, expr);
            }
            return (long)mh$.invokeExact(world, expr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_term_ref_is_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_term_ref_is_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_term_ref_is_set(const ecs_term_ref_t *ref)
     * }
     */
    public static FunctionDescriptor ecs_term_ref_is_set$descriptor() {
        return ecs_term_ref_is_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_term_ref_is_set(const ecs_term_ref_t *ref)
     * }
     */
    public static MethodHandle ecs_term_ref_is_set$handle() {
        return ecs_term_ref_is_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_term_ref_is_set(const ecs_term_ref_t *ref)
     * }
     */
    public static MemorySegment ecs_term_ref_is_set$address() {
        return ecs_term_ref_is_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_term_ref_is_set(const ecs_term_ref_t *ref)
     * }
     */
    public static boolean ecs_term_ref_is_set(MemorySegment ref) {
        var mh$ = ecs_term_ref_is_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_term_ref_is_set", ref);
            }
            return (boolean)mh$.invokeExact(ref);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_term_is_initialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_term_is_initialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_term_is_initialized(const ecs_term_t *term)
     * }
     */
    public static FunctionDescriptor ecs_term_is_initialized$descriptor() {
        return ecs_term_is_initialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_term_is_initialized(const ecs_term_t *term)
     * }
     */
    public static MethodHandle ecs_term_is_initialized$handle() {
        return ecs_term_is_initialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_term_is_initialized(const ecs_term_t *term)
     * }
     */
    public static MemorySegment ecs_term_is_initialized$address() {
        return ecs_term_is_initialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_term_is_initialized(const ecs_term_t *term)
     * }
     */
    public static boolean ecs_term_is_initialized(MemorySegment term) {
        var mh$ = ecs_term_is_initialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_term_is_initialized", term);
            }
            return (boolean)mh$.invokeExact(term);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_term_match_this {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_term_match_this");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_term_match_this(const ecs_term_t *term)
     * }
     */
    public static FunctionDescriptor ecs_term_match_this$descriptor() {
        return ecs_term_match_this.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_term_match_this(const ecs_term_t *term)
     * }
     */
    public static MethodHandle ecs_term_match_this$handle() {
        return ecs_term_match_this.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_term_match_this(const ecs_term_t *term)
     * }
     */
    public static MemorySegment ecs_term_match_this$address() {
        return ecs_term_match_this.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_term_match_this(const ecs_term_t *term)
     * }
     */
    public static boolean ecs_term_match_this(MemorySegment term) {
        var mh$ = ecs_term_match_this.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_term_match_this", term);
            }
            return (boolean)mh$.invokeExact(term);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_term_match_0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_term_match_0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_term_match_0(const ecs_term_t *term)
     * }
     */
    public static FunctionDescriptor ecs_term_match_0$descriptor() {
        return ecs_term_match_0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_term_match_0(const ecs_term_t *term)
     * }
     */
    public static MethodHandle ecs_term_match_0$handle() {
        return ecs_term_match_0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_term_match_0(const ecs_term_t *term)
     * }
     */
    public static MemorySegment ecs_term_match_0$address() {
        return ecs_term_match_0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_term_match_0(const ecs_term_t *term)
     * }
     */
    public static boolean ecs_term_match_0(MemorySegment term) {
        var mh$ = ecs_term_match_0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_term_match_0", term);
            }
            return (boolean)mh$.invokeExact(term);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_term_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_term_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_term_str(const ecs_world_t *world, const ecs_term_t *term)
     * }
     */
    public static FunctionDescriptor ecs_term_str$descriptor() {
        return ecs_term_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_term_str(const ecs_world_t *world, const ecs_term_t *term)
     * }
     */
    public static MethodHandle ecs_term_str$handle() {
        return ecs_term_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_term_str(const ecs_world_t *world, const ecs_term_t *term)
     * }
     */
    public static MemorySegment ecs_term_str$address() {
        return ecs_term_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_term_str(const ecs_world_t *world, const ecs_term_t *term)
     * }
     */
    public static MemorySegment ecs_term_str(MemorySegment world, MemorySegment term) {
        var mh$ = ecs_term_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_term_str", world, term);
            }
            return (MemorySegment)mh$.invokeExact(world, term);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_query_str(const ecs_query_t *query)
     * }
     */
    public static FunctionDescriptor ecs_query_str$descriptor() {
        return ecs_query_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_query_str(const ecs_query_t *query)
     * }
     */
    public static MethodHandle ecs_query_str$handle() {
        return ecs_query_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_query_str(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_str$address() {
        return ecs_query_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_query_str(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_str(MemorySegment query) {
        var mh$ = ecs_query_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_str", query);
            }
            return (MemorySegment)mh$.invokeExact(query);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_each_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_iter_t.layout(),
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_each_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_each_id(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_each_id$descriptor() {
        return ecs_each_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_each_id(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_each_id$handle() {
        return ecs_each_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_each_id(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_each_id$address() {
        return ecs_each_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_iter_t ecs_each_id(const ecs_world_t *world, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_each_id(SegmentAllocator allocator, MemorySegment world, long component) {
        var mh$ = ecs_each_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_each_id", allocator, world, component);
            }
            return (MemorySegment)mh$.invokeExact(allocator, world, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_each_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_each_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_each_next(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_each_next$descriptor() {
        return ecs_each_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_each_next(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_each_next$handle() {
        return ecs_each_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_each_next(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_each_next$address() {
        return ecs_each_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_each_next(ecs_iter_t *it)
     * }
     */
    public static boolean ecs_each_next(MemorySegment it) {
        var mh$ = ecs_each_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_each_next", it);
            }
            return (boolean)mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_children {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_iter_t.layout(),
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_children");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_children(const ecs_world_t *world, ecs_entity_t parent)
     * }
     */
    public static FunctionDescriptor ecs_children$descriptor() {
        return ecs_children.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_children(const ecs_world_t *world, ecs_entity_t parent)
     * }
     */
    public static MethodHandle ecs_children$handle() {
        return ecs_children.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_children(const ecs_world_t *world, ecs_entity_t parent)
     * }
     */
    public static MemorySegment ecs_children$address() {
        return ecs_children.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_iter_t ecs_children(const ecs_world_t *world, ecs_entity_t parent)
     * }
     */
    public static MemorySegment ecs_children(SegmentAllocator allocator, MemorySegment world, long parent) {
        var mh$ = ecs_children.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_children", allocator, world, parent);
            }
            return (MemorySegment)mh$.invokeExact(allocator, world, parent);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_children_w_rel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_iter_t.layout(),
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_children_w_rel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_children_w_rel(const ecs_world_t *world, ecs_entity_t relationship, ecs_entity_t parent)
     * }
     */
    public static FunctionDescriptor ecs_children_w_rel$descriptor() {
        return ecs_children_w_rel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_children_w_rel(const ecs_world_t *world, ecs_entity_t relationship, ecs_entity_t parent)
     * }
     */
    public static MethodHandle ecs_children_w_rel$handle() {
        return ecs_children_w_rel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_children_w_rel(const ecs_world_t *world, ecs_entity_t relationship, ecs_entity_t parent)
     * }
     */
    public static MemorySegment ecs_children_w_rel$address() {
        return ecs_children_w_rel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_iter_t ecs_children_w_rel(const ecs_world_t *world, ecs_entity_t relationship, ecs_entity_t parent)
     * }
     */
    public static MemorySegment ecs_children_w_rel(SegmentAllocator allocator, MemorySegment world, long relationship, long parent) {
        var mh$ = ecs_children_w_rel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_children_w_rel", allocator, world, relationship, parent);
            }
            return (MemorySegment)mh$.invokeExact(allocator, world, relationship, parent);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_children_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_children_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_children_next(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_children_next$descriptor() {
        return ecs_children_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_children_next(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_children_next$handle() {
        return ecs_children_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_children_next(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_children_next$address() {
        return ecs_children_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_children_next(ecs_iter_t *it)
     * }
     */
    public static boolean ecs_children_next(MemorySegment it) {
        var mh$ = ecs_children_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_children_next", it);
            }
            return (boolean)mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_query_t *ecs_query_init(ecs_world_t *world, const ecs_query_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_query_init$descriptor() {
        return ecs_query_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_query_t *ecs_query_init(ecs_world_t *world, const ecs_query_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_query_init$handle() {
        return ecs_query_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_query_t *ecs_query_init(ecs_world_t *world, const ecs_query_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_query_init$address() {
        return ecs_query_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_query_t *ecs_query_init(ecs_world_t *world, const ecs_query_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_query_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_query_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_init", world, desc);
            }
            return (MemorySegment)mh$.invokeExact(world, desc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_query_fini(ecs_query_t *query)
     * }
     */
    public static FunctionDescriptor ecs_query_fini$descriptor() {
        return ecs_query_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_query_fini(ecs_query_t *query)
     * }
     */
    public static MethodHandle ecs_query_fini$handle() {
        return ecs_query_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_query_fini(ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_fini$address() {
        return ecs_query_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_query_fini(ecs_query_t *query)
     * }
     */
    public static void ecs_query_fini(MemorySegment query) {
        var mh$ = ecs_query_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_fini", query);
            }
            mh$.invokeExact(query);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_find_var {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_find_var");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_query_find_var(const ecs_query_t *query, const char *name)
     * }
     */
    public static FunctionDescriptor ecs_query_find_var$descriptor() {
        return ecs_query_find_var.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_query_find_var(const ecs_query_t *query, const char *name)
     * }
     */
    public static MethodHandle ecs_query_find_var$handle() {
        return ecs_query_find_var.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_query_find_var(const ecs_query_t *query, const char *name)
     * }
     */
    public static MemorySegment ecs_query_find_var$address() {
        return ecs_query_find_var.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_query_find_var(const ecs_query_t *query, const char *name)
     * }
     */
    public static int ecs_query_find_var(MemorySegment query, MemorySegment name) {
        var mh$ = ecs_query_find_var.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_find_var", query, name);
            }
            return (int)mh$.invokeExact(query, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_var_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_var_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_query_var_name(const ecs_query_t *query, int32_t var_id)
     * }
     */
    public static FunctionDescriptor ecs_query_var_name$descriptor() {
        return ecs_query_var_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_query_var_name(const ecs_query_t *query, int32_t var_id)
     * }
     */
    public static MethodHandle ecs_query_var_name$handle() {
        return ecs_query_var_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_query_var_name(const ecs_query_t *query, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_query_var_name$address() {
        return ecs_query_var_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_query_var_name(const ecs_query_t *query, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_query_var_name(MemorySegment query, int var_id) {
        var mh$ = ecs_query_var_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_var_name", query, var_id);
            }
            return (MemorySegment)mh$.invokeExact(query, var_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_var_is_entity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_var_is_entity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_query_var_is_entity(const ecs_query_t *query, int32_t var_id)
     * }
     */
    public static FunctionDescriptor ecs_query_var_is_entity$descriptor() {
        return ecs_query_var_is_entity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_query_var_is_entity(const ecs_query_t *query, int32_t var_id)
     * }
     */
    public static MethodHandle ecs_query_var_is_entity$handle() {
        return ecs_query_var_is_entity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_query_var_is_entity(const ecs_query_t *query, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_query_var_is_entity$address() {
        return ecs_query_var_is_entity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_query_var_is_entity(const ecs_query_t *query, int32_t var_id)
     * }
     */
    public static boolean ecs_query_var_is_entity(MemorySegment query, int var_id) {
        var mh$ = ecs_query_var_is_entity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_var_is_entity", query, var_id);
            }
            return (boolean)mh$.invokeExact(query, var_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_iter_t.layout(),
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_query_iter(const ecs_world_t *world, const ecs_query_t *query)
     * }
     */
    public static FunctionDescriptor ecs_query_iter$descriptor() {
        return ecs_query_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_query_iter(const ecs_world_t *world, const ecs_query_t *query)
     * }
     */
    public static MethodHandle ecs_query_iter$handle() {
        return ecs_query_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_query_iter(const ecs_world_t *world, const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_iter$address() {
        return ecs_query_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_iter_t ecs_query_iter(const ecs_world_t *world, const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_iter(SegmentAllocator allocator, MemorySegment world, MemorySegment query) {
        var mh$ = ecs_query_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_iter", allocator, world, query);
            }
            return (MemorySegment)mh$.invokeExact(allocator, world, query);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_query_next(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_query_next$descriptor() {
        return ecs_query_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_query_next(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_query_next$handle() {
        return ecs_query_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_query_next(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_query_next$address() {
        return ecs_query_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_query_next(ecs_iter_t *it)
     * }
     */
    public static boolean ecs_query_next(MemorySegment it) {
        var mh$ = ecs_query_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_next", it);
            }
            return (boolean)mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_has {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_has");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_query_has(ecs_query_t *query, ecs_entity_t entity, ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_query_has$descriptor() {
        return ecs_query_has.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_query_has(ecs_query_t *query, ecs_entity_t entity, ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_query_has$handle() {
        return ecs_query_has.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_query_has(ecs_query_t *query, ecs_entity_t entity, ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_query_has$address() {
        return ecs_query_has.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_query_has(ecs_query_t *query, ecs_entity_t entity, ecs_iter_t *it)
     * }
     */
    public static boolean ecs_query_has(MemorySegment query, long entity, MemorySegment it) {
        var mh$ = ecs_query_has.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_has", query, entity, it);
            }
            return (boolean)mh$.invokeExact(query, entity, it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_has_table {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_has_table");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_query_has_table(ecs_query_t *query, ecs_table_t *table, ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_query_has_table$descriptor() {
        return ecs_query_has_table.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_query_has_table(ecs_query_t *query, ecs_table_t *table, ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_query_has_table$handle() {
        return ecs_query_has_table.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_query_has_table(ecs_query_t *query, ecs_table_t *table, ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_query_has_table$address() {
        return ecs_query_has_table.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_query_has_table(ecs_query_t *query, ecs_table_t *table, ecs_iter_t *it)
     * }
     */
    public static boolean ecs_query_has_table(MemorySegment query, MemorySegment table, MemorySegment it) {
        var mh$ = ecs_query_has_table.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_has_table", query, table, it);
            }
            return (boolean)mh$.invokeExact(query, table, it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_has_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_has_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_query_has_range(ecs_query_t *query, ecs_table_range_t *range, ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_query_has_range$descriptor() {
        return ecs_query_has_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_query_has_range(ecs_query_t *query, ecs_table_range_t *range, ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_query_has_range$handle() {
        return ecs_query_has_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_query_has_range(ecs_query_t *query, ecs_table_range_t *range, ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_query_has_range$address() {
        return ecs_query_has_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_query_has_range(ecs_query_t *query, ecs_table_range_t *range, ecs_iter_t *it)
     * }
     */
    public static boolean ecs_query_has_range(MemorySegment query, MemorySegment range, MemorySegment it) {
        var mh$ = ecs_query_has_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_has_range", query, range, it);
            }
            return (boolean)mh$.invokeExact(query, range, it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_match_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_match_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_query_match_count(const ecs_query_t *query)
     * }
     */
    public static FunctionDescriptor ecs_query_match_count$descriptor() {
        return ecs_query_match_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_query_match_count(const ecs_query_t *query)
     * }
     */
    public static MethodHandle ecs_query_match_count$handle() {
        return ecs_query_match_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_query_match_count(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_match_count$address() {
        return ecs_query_match_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_query_match_count(const ecs_query_t *query)
     * }
     */
    public static int ecs_query_match_count(MemorySegment query) {
        var mh$ = ecs_query_match_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_match_count", query);
            }
            return (int)mh$.invokeExact(query);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_plan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_plan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_query_plan(const ecs_query_t *query)
     * }
     */
    public static FunctionDescriptor ecs_query_plan$descriptor() {
        return ecs_query_plan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_query_plan(const ecs_query_t *query)
     * }
     */
    public static MethodHandle ecs_query_plan$handle() {
        return ecs_query_plan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_query_plan(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_plan$address() {
        return ecs_query_plan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_query_plan(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_plan(MemorySegment query) {
        var mh$ = ecs_query_plan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_plan", query);
            }
            return (MemorySegment)mh$.invokeExact(query);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_plan_w_profile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_plan_w_profile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_query_plan_w_profile(const ecs_query_t *query, const ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_query_plan_w_profile$descriptor() {
        return ecs_query_plan_w_profile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_query_plan_w_profile(const ecs_query_t *query, const ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_query_plan_w_profile$handle() {
        return ecs_query_plan_w_profile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_query_plan_w_profile(const ecs_query_t *query, const ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_query_plan_w_profile$address() {
        return ecs_query_plan_w_profile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_query_plan_w_profile(const ecs_query_t *query, const ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_query_plan_w_profile(MemorySegment query, MemorySegment it) {
        var mh$ = ecs_query_plan_w_profile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_plan_w_profile", query, it);
            }
            return (MemorySegment)mh$.invokeExact(query, it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_args_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_args_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_query_args_parse(ecs_query_t *query, ecs_iter_t *it, const char *expr)
     * }
     */
    public static FunctionDescriptor ecs_query_args_parse$descriptor() {
        return ecs_query_args_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_query_args_parse(ecs_query_t *query, ecs_iter_t *it, const char *expr)
     * }
     */
    public static MethodHandle ecs_query_args_parse$handle() {
        return ecs_query_args_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_query_args_parse(ecs_query_t *query, ecs_iter_t *it, const char *expr)
     * }
     */
    public static MemorySegment ecs_query_args_parse$address() {
        return ecs_query_args_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_query_args_parse(ecs_query_t *query, ecs_iter_t *it, const char *expr)
     * }
     */
    public static MemorySegment ecs_query_args_parse(MemorySegment query, MemorySegment it, MemorySegment expr) {
        var mh$ = ecs_query_args_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_args_parse", query, it, expr);
            }
            return (MemorySegment)mh$.invokeExact(query, it, expr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_changed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_changed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_query_changed(ecs_query_t *query)
     * }
     */
    public static FunctionDescriptor ecs_query_changed$descriptor() {
        return ecs_query_changed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_query_changed(ecs_query_t *query)
     * }
     */
    public static MethodHandle ecs_query_changed$handle() {
        return ecs_query_changed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_query_changed(ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_changed$address() {
        return ecs_query_changed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_query_changed(ecs_query_t *query)
     * }
     */
    public static boolean ecs_query_changed(MemorySegment query) {
        var mh$ = ecs_query_changed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_changed", query);
            }
            return (boolean)mh$.invokeExact(query);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_query_t *ecs_query_get(const ecs_world_t *world, ecs_entity_t query)
     * }
     */
    public static FunctionDescriptor ecs_query_get$descriptor() {
        return ecs_query_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_query_t *ecs_query_get(const ecs_world_t *world, ecs_entity_t query)
     * }
     */
    public static MethodHandle ecs_query_get$handle() {
        return ecs_query_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_query_t *ecs_query_get(const ecs_world_t *world, ecs_entity_t query)
     * }
     */
    public static MemorySegment ecs_query_get$address() {
        return ecs_query_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_query_t *ecs_query_get(const ecs_world_t *world, ecs_entity_t query)
     * }
     */
    public static MemorySegment ecs_query_get(MemorySegment world, long query) {
        var mh$ = ecs_query_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_get", world, query);
            }
            return (MemorySegment)mh$.invokeExact(world, query);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_skip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_skip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_iter_skip(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_skip$descriptor() {
        return ecs_iter_skip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_iter_skip(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_skip$handle() {
        return ecs_iter_skip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_iter_skip(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_skip$address() {
        return ecs_iter_skip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_iter_skip(ecs_iter_t *it)
     * }
     */
    public static void ecs_iter_skip(MemorySegment it) {
        var mh$ = ecs_iter_skip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_skip", it);
            }
            mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_set_group {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_set_group");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_iter_set_group(ecs_iter_t *it, uint64_t group_id)
     * }
     */
    public static FunctionDescriptor ecs_iter_set_group$descriptor() {
        return ecs_iter_set_group.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_iter_set_group(ecs_iter_t *it, uint64_t group_id)
     * }
     */
    public static MethodHandle ecs_iter_set_group$handle() {
        return ecs_iter_set_group.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_iter_set_group(ecs_iter_t *it, uint64_t group_id)
     * }
     */
    public static MemorySegment ecs_iter_set_group$address() {
        return ecs_iter_set_group.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_iter_set_group(ecs_iter_t *it, uint64_t group_id)
     * }
     */
    public static void ecs_iter_set_group(MemorySegment it, long group_id) {
        var mh$ = ecs_iter_set_group.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_set_group", it, group_id);
            }
            mh$.invokeExact(it, group_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_get_group_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_get_group_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_query_get_group_ctx(const ecs_query_t *query, uint64_t group_id)
     * }
     */
    public static FunctionDescriptor ecs_query_get_group_ctx$descriptor() {
        return ecs_query_get_group_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_query_get_group_ctx(const ecs_query_t *query, uint64_t group_id)
     * }
     */
    public static MethodHandle ecs_query_get_group_ctx$handle() {
        return ecs_query_get_group_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_query_get_group_ctx(const ecs_query_t *query, uint64_t group_id)
     * }
     */
    public static MemorySegment ecs_query_get_group_ctx$address() {
        return ecs_query_get_group_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_query_get_group_ctx(const ecs_query_t *query, uint64_t group_id)
     * }
     */
    public static MemorySegment ecs_query_get_group_ctx(MemorySegment query, long group_id) {
        var mh$ = ecs_query_get_group_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_get_group_ctx", query, group_id);
            }
            return (MemorySegment)mh$.invokeExact(query, group_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_get_group_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_get_group_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_query_group_info_t *ecs_query_get_group_info(const ecs_query_t *query, uint64_t group_id)
     * }
     */
    public static FunctionDescriptor ecs_query_get_group_info$descriptor() {
        return ecs_query_get_group_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_query_group_info_t *ecs_query_get_group_info(const ecs_query_t *query, uint64_t group_id)
     * }
     */
    public static MethodHandle ecs_query_get_group_info$handle() {
        return ecs_query_get_group_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_query_group_info_t *ecs_query_get_group_info(const ecs_query_t *query, uint64_t group_id)
     * }
     */
    public static MemorySegment ecs_query_get_group_info$address() {
        return ecs_query_get_group_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_query_group_info_t *ecs_query_get_group_info(const ecs_query_t *query, uint64_t group_id)
     * }
     */
    public static MemorySegment ecs_query_get_group_info(MemorySegment query, long group_id) {
        var mh$ = ecs_query_get_group_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_get_group_info", query, group_id);
            }
            return (MemorySegment)mh$.invokeExact(query, group_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_query_count_t.layout(),
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_query_count_t ecs_query_count(const ecs_query_t *query)
     * }
     */
    public static FunctionDescriptor ecs_query_count$descriptor() {
        return ecs_query_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_query_count_t ecs_query_count(const ecs_query_t *query)
     * }
     */
    public static MethodHandle ecs_query_count$handle() {
        return ecs_query_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_query_count_t ecs_query_count(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_count$address() {
        return ecs_query_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_query_count_t ecs_query_count(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_count(SegmentAllocator allocator, MemorySegment query) {
        var mh$ = ecs_query_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_count", allocator, query);
            }
            return (MemorySegment)mh$.invokeExact(allocator, query);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_is_true {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_is_true");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_query_is_true(const ecs_query_t *query)
     * }
     */
    public static FunctionDescriptor ecs_query_is_true$descriptor() {
        return ecs_query_is_true.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_query_is_true(const ecs_query_t *query)
     * }
     */
    public static MethodHandle ecs_query_is_true$handle() {
        return ecs_query_is_true.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_query_is_true(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_is_true$address() {
        return ecs_query_is_true.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_query_is_true(const ecs_query_t *query)
     * }
     */
    public static boolean ecs_query_is_true(MemorySegment query) {
        var mh$ = ecs_query_is_true.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_is_true", query);
            }
            return (boolean)mh$.invokeExact(query);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_get_cache_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_query_get_cache_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_query_t *ecs_query_get_cache_query(const ecs_query_t *query)
     * }
     */
    public static FunctionDescriptor ecs_query_get_cache_query$descriptor() {
        return ecs_query_get_cache_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_query_t *ecs_query_get_cache_query(const ecs_query_t *query)
     * }
     */
    public static MethodHandle ecs_query_get_cache_query$handle() {
        return ecs_query_get_cache_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_query_t *ecs_query_get_cache_query(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_get_cache_query$address() {
        return ecs_query_get_cache_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_query_t *ecs_query_get_cache_query(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_get_cache_query(MemorySegment query) {
        var mh$ = ecs_query_get_cache_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_get_cache_query", query);
            }
            return (MemorySegment)mh$.invokeExact(query);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_emit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_emit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_emit(ecs_world_t *world, ecs_event_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_emit$descriptor() {
        return ecs_emit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_emit(ecs_world_t *world, ecs_event_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_emit$handle() {
        return ecs_emit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_emit(ecs_world_t *world, ecs_event_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_emit$address() {
        return ecs_emit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_emit(ecs_world_t *world, ecs_event_desc_t *desc)
     * }
     */
    public static void ecs_emit(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_emit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_emit", world, desc);
            }
            mh$.invokeExact(world, desc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_enqueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_enqueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_enqueue(ecs_world_t *world, ecs_event_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_enqueue$descriptor() {
        return ecs_enqueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_enqueue(ecs_world_t *world, ecs_event_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_enqueue$handle() {
        return ecs_enqueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_enqueue(ecs_world_t *world, ecs_event_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_enqueue$address() {
        return ecs_enqueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_enqueue(ecs_world_t *world, ecs_event_desc_t *desc)
     * }
     */
    public static void ecs_enqueue(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_enqueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_enqueue", world, desc);
            }
            mh$.invokeExact(world, desc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_observer_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_observer_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_observer_init(ecs_world_t *world, const ecs_observer_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_observer_init$descriptor() {
        return ecs_observer_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_observer_init(ecs_world_t *world, const ecs_observer_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_observer_init$handle() {
        return ecs_observer_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_observer_init(ecs_world_t *world, const ecs_observer_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_observer_init$address() {
        return ecs_observer_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_observer_init(ecs_world_t *world, const ecs_observer_desc_t *desc)
     * }
     */
    public static long ecs_observer_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_observer_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_observer_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_observer_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_observer_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_observer_t *ecs_observer_get(const ecs_world_t *world, ecs_entity_t observer)
     * }
     */
    public static FunctionDescriptor ecs_observer_get$descriptor() {
        return ecs_observer_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_observer_t *ecs_observer_get(const ecs_world_t *world, ecs_entity_t observer)
     * }
     */
    public static MethodHandle ecs_observer_get$handle() {
        return ecs_observer_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_observer_t *ecs_observer_get(const ecs_world_t *world, ecs_entity_t observer)
     * }
     */
    public static MemorySegment ecs_observer_get$address() {
        return ecs_observer_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_observer_t *ecs_observer_get(const ecs_world_t *world, ecs_entity_t observer)
     * }
     */
    public static MemorySegment ecs_observer_get(MemorySegment world, long observer) {
        var mh$ = ecs_observer_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_observer_get", world, observer);
            }
            return (MemorySegment)mh$.invokeExact(world, observer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_iter_next(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_next$descriptor() {
        return ecs_iter_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_iter_next(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_next$handle() {
        return ecs_iter_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_iter_next(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_next$address() {
        return ecs_iter_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_iter_next(ecs_iter_t *it)
     * }
     */
    public static boolean ecs_iter_next(MemorySegment it) {
        var mh$ = ecs_iter_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_next", it);
            }
            return (boolean)mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_iter_fini(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_fini$descriptor() {
        return ecs_iter_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_iter_fini(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_fini$handle() {
        return ecs_iter_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_iter_fini(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_fini$address() {
        return ecs_iter_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_iter_fini(ecs_iter_t *it)
     * }
     */
    public static void ecs_iter_fini(MemorySegment it) {
        var mh$ = ecs_iter_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_fini", it);
            }
            mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_iter_count(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_count$descriptor() {
        return ecs_iter_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_iter_count(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_count$handle() {
        return ecs_iter_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_iter_count(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_count$address() {
        return ecs_iter_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_iter_count(ecs_iter_t *it)
     * }
     */
    public static int ecs_iter_count(MemorySegment it) {
        var mh$ = ecs_iter_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_count", it);
            }
            return (int)mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_is_true {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_is_true");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_iter_is_true(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_is_true$descriptor() {
        return ecs_iter_is_true.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_iter_is_true(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_is_true$handle() {
        return ecs_iter_is_true.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_iter_is_true(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_is_true$address() {
        return ecs_iter_is_true.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_iter_is_true(ecs_iter_t *it)
     * }
     */
    public static boolean ecs_iter_is_true(MemorySegment it) {
        var mh$ = ecs_iter_is_true.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_is_true", it);
            }
            return (boolean)mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_first {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_first");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_iter_first(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_first$descriptor() {
        return ecs_iter_first.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_iter_first(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_first$handle() {
        return ecs_iter_first.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_iter_first(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_first$address() {
        return ecs_iter_first.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_iter_first(ecs_iter_t *it)
     * }
     */
    public static long ecs_iter_first(MemorySegment it) {
        var mh$ = ecs_iter_first.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_first", it);
            }
            return (long)mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_set_var {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_set_var");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_iter_set_var(ecs_iter_t *it, int32_t var_id, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_iter_set_var$descriptor() {
        return ecs_iter_set_var.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_iter_set_var(ecs_iter_t *it, int32_t var_id, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_iter_set_var$handle() {
        return ecs_iter_set_var.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_iter_set_var(ecs_iter_t *it, int32_t var_id, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_iter_set_var$address() {
        return ecs_iter_set_var.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_iter_set_var(ecs_iter_t *it, int32_t var_id, ecs_entity_t entity)
     * }
     */
    public static void ecs_iter_set_var(MemorySegment it, int var_id, long entity) {
        var mh$ = ecs_iter_set_var.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_set_var", it, var_id, entity);
            }
            mh$.invokeExact(it, var_id, entity);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_set_var_as_table {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_set_var_as_table");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_iter_set_var_as_table(ecs_iter_t *it, int32_t var_id, const ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_iter_set_var_as_table$descriptor() {
        return ecs_iter_set_var_as_table.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_iter_set_var_as_table(ecs_iter_t *it, int32_t var_id, const ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_iter_set_var_as_table$handle() {
        return ecs_iter_set_var_as_table.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_iter_set_var_as_table(ecs_iter_t *it, int32_t var_id, const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_iter_set_var_as_table$address() {
        return ecs_iter_set_var_as_table.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_iter_set_var_as_table(ecs_iter_t *it, int32_t var_id, const ecs_table_t *table)
     * }
     */
    public static void ecs_iter_set_var_as_table(MemorySegment it, int var_id, MemorySegment table) {
        var mh$ = ecs_iter_set_var_as_table.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_set_var_as_table", it, var_id, table);
            }
            mh$.invokeExact(it, var_id, table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_set_var_as_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_set_var_as_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_iter_set_var_as_range(ecs_iter_t *it, int32_t var_id, const ecs_table_range_t *range)
     * }
     */
    public static FunctionDescriptor ecs_iter_set_var_as_range$descriptor() {
        return ecs_iter_set_var_as_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_iter_set_var_as_range(ecs_iter_t *it, int32_t var_id, const ecs_table_range_t *range)
     * }
     */
    public static MethodHandle ecs_iter_set_var_as_range$handle() {
        return ecs_iter_set_var_as_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_iter_set_var_as_range(ecs_iter_t *it, int32_t var_id, const ecs_table_range_t *range)
     * }
     */
    public static MemorySegment ecs_iter_set_var_as_range$address() {
        return ecs_iter_set_var_as_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_iter_set_var_as_range(ecs_iter_t *it, int32_t var_id, const ecs_table_range_t *range)
     * }
     */
    public static void ecs_iter_set_var_as_range(MemorySegment it, int var_id, MemorySegment range) {
        var mh$ = ecs_iter_set_var_as_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_set_var_as_range", it, var_id, range);
            }
            mh$.invokeExact(it, var_id, range);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_get_var {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_get_var");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_iter_get_var(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static FunctionDescriptor ecs_iter_get_var$descriptor() {
        return ecs_iter_get_var.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_iter_get_var(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MethodHandle ecs_iter_get_var$handle() {
        return ecs_iter_get_var.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_iter_get_var(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_iter_get_var$address() {
        return ecs_iter_get_var.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_iter_get_var(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static long ecs_iter_get_var(MemorySegment it, int var_id) {
        var mh$ = ecs_iter_get_var.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_get_var", it, var_id);
            }
            return (long)mh$.invokeExact(it, var_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_get_var_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_get_var_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_iter_get_var_name(const ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static FunctionDescriptor ecs_iter_get_var_name$descriptor() {
        return ecs_iter_get_var_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_iter_get_var_name(const ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MethodHandle ecs_iter_get_var_name$handle() {
        return ecs_iter_get_var_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_iter_get_var_name(const ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_iter_get_var_name$address() {
        return ecs_iter_get_var_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_iter_get_var_name(const ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_iter_get_var_name(MemorySegment it, int var_id) {
        var mh$ = ecs_iter_get_var_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_get_var_name", it, var_id);
            }
            return (MemorySegment)mh$.invokeExact(it, var_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_get_var_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_get_var_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_iter_get_var_count(const ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_get_var_count$descriptor() {
        return ecs_iter_get_var_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_iter_get_var_count(const ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_get_var_count$handle() {
        return ecs_iter_get_var_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_iter_get_var_count(const ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_get_var_count$address() {
        return ecs_iter_get_var_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_iter_get_var_count(const ecs_iter_t *it)
     * }
     */
    public static int ecs_iter_get_var_count(MemorySegment it) {
        var mh$ = ecs_iter_get_var_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_get_var_count", it);
            }
            return (int)mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_get_vars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_get_vars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_var_t *ecs_iter_get_vars(const ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_get_vars$descriptor() {
        return ecs_iter_get_vars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_var_t *ecs_iter_get_vars(const ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_get_vars$handle() {
        return ecs_iter_get_vars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_var_t *ecs_iter_get_vars(const ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_get_vars$address() {
        return ecs_iter_get_vars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_var_t *ecs_iter_get_vars(const ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_get_vars(MemorySegment it) {
        var mh$ = ecs_iter_get_vars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_get_vars", it);
            }
            return (MemorySegment)mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_get_var_as_table {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_get_var_as_table");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_iter_get_var_as_table(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static FunctionDescriptor ecs_iter_get_var_as_table$descriptor() {
        return ecs_iter_get_var_as_table.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_iter_get_var_as_table(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MethodHandle ecs_iter_get_var_as_table$handle() {
        return ecs_iter_get_var_as_table.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_iter_get_var_as_table(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_iter_get_var_as_table$address() {
        return ecs_iter_get_var_as_table.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_table_t *ecs_iter_get_var_as_table(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_iter_get_var_as_table(MemorySegment it, int var_id) {
        var mh$ = ecs_iter_get_var_as_table.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_get_var_as_table", it, var_id);
            }
            return (MemorySegment)mh$.invokeExact(it, var_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_get_var_as_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_table_range_t.layout(),
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_get_var_as_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_table_range_t ecs_iter_get_var_as_range(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static FunctionDescriptor ecs_iter_get_var_as_range$descriptor() {
        return ecs_iter_get_var_as_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_table_range_t ecs_iter_get_var_as_range(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MethodHandle ecs_iter_get_var_as_range$handle() {
        return ecs_iter_get_var_as_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_table_range_t ecs_iter_get_var_as_range(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_iter_get_var_as_range$address() {
        return ecs_iter_get_var_as_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_table_range_t ecs_iter_get_var_as_range(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_iter_get_var_as_range(SegmentAllocator allocator, MemorySegment it, int var_id) {
        var mh$ = ecs_iter_get_var_as_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_get_var_as_range", allocator, it, var_id);
            }
            return (MemorySegment)mh$.invokeExact(allocator, it, var_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_var_is_constrained {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_var_is_constrained");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_iter_var_is_constrained(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static FunctionDescriptor ecs_iter_var_is_constrained$descriptor() {
        return ecs_iter_var_is_constrained.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_iter_var_is_constrained(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MethodHandle ecs_iter_var_is_constrained$handle() {
        return ecs_iter_var_is_constrained.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_iter_var_is_constrained(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_iter_var_is_constrained$address() {
        return ecs_iter_var_is_constrained.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_iter_var_is_constrained(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static boolean ecs_iter_var_is_constrained(MemorySegment it, int var_id) {
        var mh$ = ecs_iter_var_is_constrained.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_var_is_constrained", it, var_id);
            }
            return (boolean)mh$.invokeExact(it, var_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_get_group {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_get_group");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t ecs_iter_get_group(const ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_get_group$descriptor() {
        return ecs_iter_get_group.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t ecs_iter_get_group(const ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_get_group$handle() {
        return ecs_iter_get_group.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t ecs_iter_get_group(const ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_get_group$address() {
        return ecs_iter_get_group.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t ecs_iter_get_group(const ecs_iter_t *it)
     * }
     */
    public static long ecs_iter_get_group(MemorySegment it) {
        var mh$ = ecs_iter_get_group.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_get_group", it);
            }
            return (long)mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_changed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_changed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_iter_changed(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_changed$descriptor() {
        return ecs_iter_changed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_iter_changed(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_changed$handle() {
        return ecs_iter_changed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_iter_changed(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_changed$address() {
        return ecs_iter_changed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_iter_changed(ecs_iter_t *it)
     * }
     */
    public static boolean ecs_iter_changed(MemorySegment it) {
        var mh$ = ecs_iter_changed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_changed", it);
            }
            return (boolean)mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_iter_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_iter_str(const ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_str$descriptor() {
        return ecs_iter_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_iter_str(const ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_str$handle() {
        return ecs_iter_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_iter_str(const ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_str$address() {
        return ecs_iter_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_iter_str(const ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_str(MemorySegment it) {
        var mh$ = ecs_iter_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_str", it);
            }
            return (MemorySegment)mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_page_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_iter_t.layout(),
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_page_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_page_iter(const ecs_iter_t *it, int32_t offset, int32_t limit)
     * }
     */
    public static FunctionDescriptor ecs_page_iter$descriptor() {
        return ecs_page_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_page_iter(const ecs_iter_t *it, int32_t offset, int32_t limit)
     * }
     */
    public static MethodHandle ecs_page_iter$handle() {
        return ecs_page_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_page_iter(const ecs_iter_t *it, int32_t offset, int32_t limit)
     * }
     */
    public static MemorySegment ecs_page_iter$address() {
        return ecs_page_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_iter_t ecs_page_iter(const ecs_iter_t *it, int32_t offset, int32_t limit)
     * }
     */
    public static MemorySegment ecs_page_iter(SegmentAllocator allocator, MemorySegment it, int offset, int limit) {
        var mh$ = ecs_page_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_page_iter", allocator, it, offset, limit);
            }
            return (MemorySegment)mh$.invokeExact(allocator, it, offset, limit);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_page_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_page_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_page_next(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_page_next$descriptor() {
        return ecs_page_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_page_next(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_page_next$handle() {
        return ecs_page_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_page_next(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_page_next$address() {
        return ecs_page_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_page_next(ecs_iter_t *it)
     * }
     */
    public static boolean ecs_page_next(MemorySegment it) {
        var mh$ = ecs_page_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_page_next", it);
            }
            return (boolean)mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_worker_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_iter_t.layout(),
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_worker_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_worker_iter(const ecs_iter_t *it, int32_t index, int32_t count)
     * }
     */
    public static FunctionDescriptor ecs_worker_iter$descriptor() {
        return ecs_worker_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_worker_iter(const ecs_iter_t *it, int32_t index, int32_t count)
     * }
     */
    public static MethodHandle ecs_worker_iter$handle() {
        return ecs_worker_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_worker_iter(const ecs_iter_t *it, int32_t index, int32_t count)
     * }
     */
    public static MemorySegment ecs_worker_iter$address() {
        return ecs_worker_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_iter_t ecs_worker_iter(const ecs_iter_t *it, int32_t index, int32_t count)
     * }
     */
    public static MemorySegment ecs_worker_iter(SegmentAllocator allocator, MemorySegment it, int index, int count) {
        var mh$ = ecs_worker_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_worker_iter", allocator, it, index, count);
            }
            return (MemorySegment)mh$.invokeExact(allocator, it, index, count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_worker_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_worker_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_worker_next(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_worker_next$descriptor() {
        return ecs_worker_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_worker_next(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_worker_next$handle() {
        return ecs_worker_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_worker_next(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_worker_next$address() {
        return ecs_worker_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_worker_next(ecs_iter_t *it)
     * }
     */
    public static boolean ecs_worker_next(MemorySegment it) {
        var mh$ = ecs_worker_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_worker_next", it);
            }
            return (boolean)mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_w_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_field_w_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(false));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_field_w_size(const ecs_iter_t *it, size_t size, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_w_size$descriptor() {
        return ecs_field_w_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_field_w_size(const ecs_iter_t *it, size_t size, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_w_size$handle() {
        return ecs_field_w_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_field_w_size(const ecs_iter_t *it, size_t size, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_w_size$address() {
        return ecs_field_w_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_field_w_size(const ecs_iter_t *it, size_t size, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_w_size(MemorySegment it, long size, byte index) {
        var mh$ = ecs_field_w_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_w_size", it, size, index);
            }
            return (MemorySegment)mh$.invokeExact(it, size, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_at_w_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_CHAR,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_field_at_w_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_field_at_w_size(const ecs_iter_t *it, size_t size, int8_t index, int32_t row)
     * }
     */
    public static FunctionDescriptor ecs_field_at_w_size$descriptor() {
        return ecs_field_at_w_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_field_at_w_size(const ecs_iter_t *it, size_t size, int8_t index, int32_t row)
     * }
     */
    public static MethodHandle ecs_field_at_w_size$handle() {
        return ecs_field_at_w_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_field_at_w_size(const ecs_iter_t *it, size_t size, int8_t index, int32_t row)
     * }
     */
    public static MemorySegment ecs_field_at_w_size$address() {
        return ecs_field_at_w_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_field_at_w_size(const ecs_iter_t *it, size_t size, int8_t index, int32_t row)
     * }
     */
    public static MemorySegment ecs_field_at_w_size(MemorySegment it, long size, byte index, int row) {
        var mh$ = ecs_field_at_w_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_at_w_size", it, size, index, row);
            }
            return (MemorySegment)mh$.invokeExact(it, size, index, row);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_is_readonly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_field_is_readonly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_field_is_readonly(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_is_readonly$descriptor() {
        return ecs_field_is_readonly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_field_is_readonly(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_is_readonly$handle() {
        return ecs_field_is_readonly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_field_is_readonly(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_is_readonly$address() {
        return ecs_field_is_readonly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_field_is_readonly(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static boolean ecs_field_is_readonly(MemorySegment it, byte index) {
        var mh$ = ecs_field_is_readonly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_is_readonly", it, index);
            }
            return (boolean)mh$.invokeExact(it, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_is_writeonly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_field_is_writeonly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_field_is_writeonly(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_is_writeonly$descriptor() {
        return ecs_field_is_writeonly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_field_is_writeonly(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_is_writeonly$handle() {
        return ecs_field_is_writeonly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_field_is_writeonly(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_is_writeonly$address() {
        return ecs_field_is_writeonly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_field_is_writeonly(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static boolean ecs_field_is_writeonly(MemorySegment it, byte index) {
        var mh$ = ecs_field_is_writeonly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_is_writeonly", it, index);
            }
            return (boolean)mh$.invokeExact(it, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_is_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_field_is_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_field_is_set(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_is_set$descriptor() {
        return ecs_field_is_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_field_is_set(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_is_set$handle() {
        return ecs_field_is_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_field_is_set(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_is_set$address() {
        return ecs_field_is_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_field_is_set(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static boolean ecs_field_is_set(MemorySegment it, byte index) {
        var mh$ = ecs_field_is_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_is_set", it, index);
            }
            return (boolean)mh$.invokeExact(it, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_field_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_id_t ecs_field_id(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_id$descriptor() {
        return ecs_field_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_id_t ecs_field_id(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_id$handle() {
        return ecs_field_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_id_t ecs_field_id(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_id$address() {
        return ecs_field_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_id_t ecs_field_id(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static long ecs_field_id(MemorySegment it, byte index) {
        var mh$ = ecs_field_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_id", it, index);
            }
            return (long)mh$.invokeExact(it, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_column {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_field_column");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_field_column(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_column$descriptor() {
        return ecs_field_column.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_field_column(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_column$handle() {
        return ecs_field_column.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_field_column(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_column$address() {
        return ecs_field_column.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_field_column(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static int ecs_field_column(MemorySegment it, byte index) {
        var mh$ = ecs_field_column.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_column", it, index);
            }
            return (int)mh$.invokeExact(it, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_src {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_field_src");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_field_src(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_src$descriptor() {
        return ecs_field_src.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_field_src(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_src$handle() {
        return ecs_field_src.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_field_src(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_src$address() {
        return ecs_field_src.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_field_src(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static long ecs_field_src(MemorySegment it, byte index) {
        var mh$ = ecs_field_src.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_src", it, index);
            }
            return (long)mh$.invokeExact(it, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_field_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t ecs_field_size(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_size$descriptor() {
        return ecs_field_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t ecs_field_size(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_size$handle() {
        return ecs_field_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t ecs_field_size(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_size$address() {
        return ecs_field_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t ecs_field_size(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static long ecs_field_size(MemorySegment it, byte index) {
        var mh$ = ecs_field_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_size", it, index);
            }
            return (long)mh$.invokeExact(it, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_is_self {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_field_is_self");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_field_is_self(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_is_self$descriptor() {
        return ecs_field_is_self.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_field_is_self(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_is_self$handle() {
        return ecs_field_is_self.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_field_is_self(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_is_self$address() {
        return ecs_field_is_self.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_field_is_self(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static boolean ecs_field_is_self(MemorySegment it, byte index) {
        var mh$ = ecs_field_is_self.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_is_self", it, index);
            }
            return (boolean)mh$.invokeExact(it, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_type_t *ecs_table_get_type(const ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_table_get_type$descriptor() {
        return ecs_table_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_type_t *ecs_table_get_type(const ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_table_get_type$handle() {
        return ecs_table_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_type_t *ecs_table_get_type(const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_get_type$address() {
        return ecs_table_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_type_t *ecs_table_get_type(const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_get_type(MemorySegment table) {
        var mh$ = ecs_table_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_get_type", table);
            }
            return (MemorySegment)mh$.invokeExact(table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_get_type_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_get_type_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_type_index(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_table_get_type_index$descriptor() {
        return ecs_table_get_type_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_type_index(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_table_get_type_index$handle() {
        return ecs_table_get_type_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_type_index(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_table_get_type_index$address() {
        return ecs_table_get_type_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_table_get_type_index(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static int ecs_table_get_type_index(MemorySegment world, MemorySegment table, long component) {
        var mh$ = ecs_table_get_type_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_get_type_index", world, table, component);
            }
            return (int)mh$.invokeExact(world, table, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_get_column_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_get_column_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_column_index(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_table_get_column_index$descriptor() {
        return ecs_table_get_column_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_column_index(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_table_get_column_index$handle() {
        return ecs_table_get_column_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_column_index(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_table_get_column_index$address() {
        return ecs_table_get_column_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_table_get_column_index(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static int ecs_table_get_column_index(MemorySegment world, MemorySegment table, long component) {
        var mh$ = ecs_table_get_column_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_get_column_index", world, table, component);
            }
            return (int)mh$.invokeExact(world, table, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_column_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_column_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_table_column_count(const ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_table_column_count$descriptor() {
        return ecs_table_column_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_table_column_count(const ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_table_column_count$handle() {
        return ecs_table_column_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_table_column_count(const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_column_count$address() {
        return ecs_table_column_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_table_column_count(const ecs_table_t *table)
     * }
     */
    public static int ecs_table_column_count(MemorySegment table) {
        var mh$ = ecs_table_column_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_column_count", table);
            }
            return (int)mh$.invokeExact(table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_type_to_column_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_type_to_column_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_table_type_to_column_index(const ecs_table_t *table, int32_t index)
     * }
     */
    public static FunctionDescriptor ecs_table_type_to_column_index$descriptor() {
        return ecs_table_type_to_column_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_table_type_to_column_index(const ecs_table_t *table, int32_t index)
     * }
     */
    public static MethodHandle ecs_table_type_to_column_index$handle() {
        return ecs_table_type_to_column_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_table_type_to_column_index(const ecs_table_t *table, int32_t index)
     * }
     */
    public static MemorySegment ecs_table_type_to_column_index$address() {
        return ecs_table_type_to_column_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_table_type_to_column_index(const ecs_table_t *table, int32_t index)
     * }
     */
    public static int ecs_table_type_to_column_index(MemorySegment table, int index) {
        var mh$ = ecs_table_type_to_column_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_type_to_column_index", table, index);
            }
            return (int)mh$.invokeExact(table, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_column_to_type_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_column_to_type_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_table_column_to_type_index(const ecs_table_t *table, int32_t index)
     * }
     */
    public static FunctionDescriptor ecs_table_column_to_type_index$descriptor() {
        return ecs_table_column_to_type_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_table_column_to_type_index(const ecs_table_t *table, int32_t index)
     * }
     */
    public static MethodHandle ecs_table_column_to_type_index$handle() {
        return ecs_table_column_to_type_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_table_column_to_type_index(const ecs_table_t *table, int32_t index)
     * }
     */
    public static MemorySegment ecs_table_column_to_type_index$address() {
        return ecs_table_column_to_type_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_table_column_to_type_index(const ecs_table_t *table, int32_t index)
     * }
     */
    public static int ecs_table_column_to_type_index(MemorySegment table, int index) {
        var mh$ = ecs_table_column_to_type_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_column_to_type_index", table, index);
            }
            return (int)mh$.invokeExact(table, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_get_column {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_get_column");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_table_get_column(const ecs_table_t *table, int32_t index, int32_t offset)
     * }
     */
    public static FunctionDescriptor ecs_table_get_column$descriptor() {
        return ecs_table_get_column.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_table_get_column(const ecs_table_t *table, int32_t index, int32_t offset)
     * }
     */
    public static MethodHandle ecs_table_get_column$handle() {
        return ecs_table_get_column.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_table_get_column(const ecs_table_t *table, int32_t index, int32_t offset)
     * }
     */
    public static MemorySegment ecs_table_get_column$address() {
        return ecs_table_get_column.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_table_get_column(const ecs_table_t *table, int32_t index, int32_t offset)
     * }
     */
    public static MemorySegment ecs_table_get_column(MemorySegment table, int index, int offset) {
        var mh$ = ecs_table_get_column.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_get_column", table, index, offset);
            }
            return (MemorySegment)mh$.invokeExact(table, index, offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_table_get_id(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t component, int32_t offset)
     * }
     */
    public static FunctionDescriptor ecs_table_get_id$descriptor() {
        return ecs_table_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_table_get_id(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t component, int32_t offset)
     * }
     */
    public static MethodHandle ecs_table_get_id$handle() {
        return ecs_table_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_table_get_id(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t component, int32_t offset)
     * }
     */
    public static MemorySegment ecs_table_get_id$address() {
        return ecs_table_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_table_get_id(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t component, int32_t offset)
     * }
     */
    public static MemorySegment ecs_table_get_id(MemorySegment world, MemorySegment table, long component, int offset) {
        var mh$ = ecs_table_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_get_id", world, table, component, offset);
            }
            return (MemorySegment)mh$.invokeExact(world, table, component, offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_get_column_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_get_column_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t ecs_table_get_column_size(const ecs_table_t *table, int32_t index)
     * }
     */
    public static FunctionDescriptor ecs_table_get_column_size$descriptor() {
        return ecs_table_get_column_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t ecs_table_get_column_size(const ecs_table_t *table, int32_t index)
     * }
     */
    public static MethodHandle ecs_table_get_column_size$handle() {
        return ecs_table_get_column_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t ecs_table_get_column_size(const ecs_table_t *table, int32_t index)
     * }
     */
    public static MemorySegment ecs_table_get_column_size$address() {
        return ecs_table_get_column_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t ecs_table_get_column_size(const ecs_table_t *table, int32_t index)
     * }
     */
    public static long ecs_table_get_column_size(MemorySegment table, int index) {
        var mh$ = ecs_table_get_column_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_get_column_size", table, index);
            }
            return (long)mh$.invokeExact(table, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_table_count(const ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_table_count$descriptor() {
        return ecs_table_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_table_count(const ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_table_count$handle() {
        return ecs_table_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_table_count(const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_count$address() {
        return ecs_table_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_table_count(const ecs_table_t *table)
     * }
     */
    public static int ecs_table_count(MemorySegment table) {
        var mh$ = ecs_table_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_count", table);
            }
            return (int)mh$.invokeExact(table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_table_size(const ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_table_size$descriptor() {
        return ecs_table_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_table_size(const ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_table_size$handle() {
        return ecs_table_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_table_size(const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_size$address() {
        return ecs_table_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_table_size(const ecs_table_t *table)
     * }
     */
    public static int ecs_table_size(MemorySegment table) {
        var mh$ = ecs_table_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_size", table);
            }
            return (int)mh$.invokeExact(table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_entities {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_entities");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_table_entities(const ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_table_entities$descriptor() {
        return ecs_table_entities.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_table_entities(const ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_table_entities$handle() {
        return ecs_table_entities.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_table_entities(const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_entities$address() {
        return ecs_table_entities.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_table_entities(const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_entities(MemorySegment table) {
        var mh$ = ecs_table_entities.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_entities", table);
            }
            return (MemorySegment)mh$.invokeExact(table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_has_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_BOOL,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_has_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ecs_table_has_id(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_table_has_id$descriptor() {
        return ecs_table_has_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ecs_table_has_id(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_table_has_id$handle() {
        return ecs_table_has_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ecs_table_has_id(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_table_has_id$address() {
        return ecs_table_has_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ecs_table_has_id(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static boolean ecs_table_has_id(MemorySegment world, MemorySegment table, long component) {
        var mh$ = ecs_table_has_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_has_id", world, table, component);
            }
            return (boolean)mh$.invokeExact(world, table, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_get_target {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_LONG,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_get_target");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_table_get_target(const ecs_world_t *world, const ecs_table_t *table, ecs_entity_t relationship, int32_t index)
     * }
     */
    public static FunctionDescriptor ecs_table_get_target$descriptor() {
        return ecs_table_get_target.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_table_get_target(const ecs_world_t *world, const ecs_table_t *table, ecs_entity_t relationship, int32_t index)
     * }
     */
    public static MethodHandle ecs_table_get_target$handle() {
        return ecs_table_get_target.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_table_get_target(const ecs_world_t *world, const ecs_table_t *table, ecs_entity_t relationship, int32_t index)
     * }
     */
    public static MemorySegment ecs_table_get_target$address() {
        return ecs_table_get_target.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_table_get_target(const ecs_world_t *world, const ecs_table_t *table, ecs_entity_t relationship, int32_t index)
     * }
     */
    public static long ecs_table_get_target(MemorySegment world, MemorySegment table, long relationship, int index) {
        var mh$ = ecs_table_get_target.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_get_target", world, table, relationship, index);
            }
            return (long)mh$.invokeExact(world, table, relationship, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_get_depth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_INT,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_get_depth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_depth(const ecs_world_t *world, const ecs_table_t *table, ecs_entity_t rel)
     * }
     */
    public static FunctionDescriptor ecs_table_get_depth$descriptor() {
        return ecs_table_get_depth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_depth(const ecs_world_t *world, const ecs_table_t *table, ecs_entity_t rel)
     * }
     */
    public static MethodHandle ecs_table_get_depth$handle() {
        return ecs_table_get_depth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_depth(const ecs_world_t *world, const ecs_table_t *table, ecs_entity_t rel)
     * }
     */
    public static MemorySegment ecs_table_get_depth$address() {
        return ecs_table_get_depth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_table_get_depth(const ecs_world_t *world, const ecs_table_t *table, ecs_entity_t rel)
     * }
     */
    public static int ecs_table_get_depth(MemorySegment world, MemorySegment table, long rel) {
        var mh$ = ecs_table_get_depth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_get_depth", world, table, rel);
            }
            return (int)mh$.invokeExact(world, table, rel);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_add_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_add_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_add_id(ecs_world_t *world, ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_table_add_id$descriptor() {
        return ecs_table_add_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_add_id(ecs_world_t *world, ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_table_add_id$handle() {
        return ecs_table_add_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_add_id(ecs_world_t *world, ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_table_add_id$address() {
        return ecs_table_add_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_add_id(ecs_world_t *world, ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_table_add_id(MemorySegment world, MemorySegment table, long component) {
        var mh$ = ecs_table_add_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_add_id", world, table, component);
            }
            return (MemorySegment)mh$.invokeExact(world, table, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_find(ecs_world_t *world, const ecs_id_t *ids, int32_t id_count)
     * }
     */
    public static FunctionDescriptor ecs_table_find$descriptor() {
        return ecs_table_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_find(ecs_world_t *world, const ecs_id_t *ids, int32_t id_count)
     * }
     */
    public static MethodHandle ecs_table_find$handle() {
        return ecs_table_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_find(ecs_world_t *world, const ecs_id_t *ids, int32_t id_count)
     * }
     */
    public static MemorySegment ecs_table_find$address() {
        return ecs_table_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_find(ecs_world_t *world, const ecs_id_t *ids, int32_t id_count)
     * }
     */
    public static MemorySegment ecs_table_find(MemorySegment world, MemorySegment ids, int id_count) {
        var mh$ = ecs_table_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_find", world, ids, id_count);
            }
            return (MemorySegment)mh$.invokeExact(world, ids, id_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_remove_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_POINTER,
            flecs_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_remove_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_remove_id(ecs_world_t *world, ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static FunctionDescriptor ecs_table_remove_id$descriptor() {
        return ecs_table_remove_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_remove_id(ecs_world_t *world, ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static MethodHandle ecs_table_remove_id$handle() {
        return ecs_table_remove_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_remove_id(ecs_world_t *world, ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_table_remove_id$address() {
        return ecs_table_remove_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_remove_id(ecs_world_t *world, ecs_table_t *table, ecs_id_t component)
     * }
     */
    public static MemorySegment ecs_table_remove_id(MemorySegment world, MemorySegment table, long component) {
        var mh$ = ecs_table_remove_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_remove_id", world, table, component);
            }
            return (MemorySegment)mh$.invokeExact(world, table, component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs_h.C_POINTER,
            flecs_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecs_table_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_table_lock(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_table_lock$descriptor() {
        return ecs_table_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_table_lock(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_table_lock$handle() {
        return ecs_table_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_table_lock(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_lock$address() {
        return ecs_table_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_table_lock(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static void ecs_table_lock(MemorySegment world, MemorySegment table) {
        var mh$ = ecs_table_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_lock", world, table);
            }
            mh$.invokeExact(world, table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

