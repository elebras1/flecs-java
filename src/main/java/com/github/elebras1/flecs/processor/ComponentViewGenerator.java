package com.github.elebras1.flecs.processor;

import com.palantir.javapoet.*;

import javax.lang.model.element.*;
import javax.lang.model.type.ArrayType;
import javax.lang.model.type.TypeMirror;
import java.util.ArrayList;
import java.util.List;

public class ComponentViewGenerator extends AbstractGenerator {

    private static final String COMPONENT_VIEW_INTERFACE = "com.github.elebras1.flecs.ComponentView";

    private static final ClassName MEMORY_ACCESS_CLASS = ClassName.get("com.github.elebras1.flecs.util.internal", "MemoryAccess");
    private static final ClassName WORLD_CLASS = ClassName.get("com.github.elebras1.flecs", "World");

    public JavaFile generate(TypeElement recordElement, List<VariableElement> fields)  {
        String packageName = this.getPackageName(recordElement);
        String recordName = recordElement.getSimpleName().toString();
        String componentViewClassName = recordName + "View";

        String componentReference = packageName + "." + recordName + "Component";

        ClassName viewType = ClassName.get(packageName, componentViewClassName);

        TypeSpec componentClass = TypeSpec.classBuilder(componentViewClassName)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addSuperinterface(ClassName.bestGuess(COMPONENT_VIEW_INTERFACE))
                .addFields(this.createFields())
                .addMethod(this.createSetterResource())
                .addMethods(this.createGetterSetterFields(fields, componentReference, viewType))
                .build();

        return JavaFile.builder(packageName, componentClass)
                .addFileComment("Generated by ComponentViewGenerator")
                .indent("    ")
                .build();
    }

    private List<FieldSpec> createFields() {
        return List.of(
                FieldSpec.builder(long.class, "address", Modifier.PRIVATE).build(),
                FieldSpec.builder(long.class, "offset", Modifier.PRIVATE).build()
        );
    }

    private MethodSpec createSetterResource() {
        return MethodSpec.methodBuilder("setResource")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(long.class, "address")
                .addParameter(long.class, "offset")
                .addJavadoc("Internal API - Do not use.\n")
                .addStatement("this.address = address")
                .addStatement("this.offset = offset")
                .build();
    }

    private Iterable<MethodSpec> createGetterSetterFields(List<VariableElement> fields, String componentReference, ClassName viewType) {
        return fields.stream()
                .flatMap(field -> this.createGetterSetterFields(field, componentReference, viewType).stream())
                .toList();
    }

    private List<MethodSpec> createGetterSetterFields(VariableElement field, String componentReference, ClassName viewType) {
        List<MethodSpec> methods = new ArrayList<>();
        String fieldName = field.getSimpleName().toString();
        String offsetName = "OFFSET_" + fieldName.toUpperCase();
        String typeName = field.asType().toString();

        if (typeName.endsWith("[]")) {
            int length = this.getArrayLength(field);
            TypeName elementType = this.getElementType(field);
            String rawType = elementType.toString();

            String suffix = Character.toUpperCase(rawType.charAt(0)) + rawType.substring(1);
            String methodAtIndex = "get" + suffix + "AtIndex";
            String setterAtIndex = "set" + suffix + "AtIndex";

            methods.add(MethodSpec.methodBuilder(fieldName + "Length")
                    .addModifiers(Modifier.PUBLIC)
                    .returns(int.class)
                    .addStatement("return $L", length)
                    .build());

            methods.add(MethodSpec.methodBuilder(fieldName)
                    .addModifiers(Modifier.PUBLIC)
                    .addParameter(int.class, "index")
                    .returns(elementType)
                    .addStatement("return $T.$L($T.WHOLE_MEMORY, address + offset + $L.$L, index)", MEMORY_ACCESS_CLASS, methodAtIndex, WORLD_CLASS, componentReference, offsetName)
                    .build());

            methods.add(MethodSpec.methodBuilder(fieldName)
                    .addModifiers(Modifier.PUBLIC)
                    .addParameter(int.class, "index")
                    .addParameter(elementType, "value")
                    .returns(viewType)
                    .addStatement("$T.$L($T.WHOLE_MEMORY, address + offset + $L.$L, index, value)", MEMORY_ACCESS_CLASS, setterAtIndex, WORLD_CLASS, componentReference, offsetName)
                    .addStatement("return this")
                    .build());

        } else {
            MethodSpec.Builder getter = MethodSpec.methodBuilder(fieldName).addModifiers(Modifier.PUBLIC).returns(TypeName.get(field.asType()));
            String getterHelper = this.getGetterMethod(typeName);
            if ("java.lang.String".equals(typeName)) {
                int size = this.getStringSize(field);
                getter.addStatement("return $T.$L($T.WHOLE_MEMORY, address + offset + $L.$L, $L)", MEMORY_ACCESS_CLASS, getterHelper, WORLD_CLASS, componentReference, offsetName, size);
            } else {
                getter.addStatement("return $T.$L($T.WHOLE_MEMORY, address + offset + $L.$L)", MEMORY_ACCESS_CLASS, getterHelper, WORLD_CLASS, componentReference, offsetName);
            }
            methods.add(getter.build());

            MethodSpec.Builder setter = MethodSpec.methodBuilder(fieldName).addModifiers(Modifier.PUBLIC).addParameter(TypeName.get(field.asType()), "value").returns(viewType);
            if ("java.lang.String".equals(typeName)) {
                int size = this.getStringSize(field);
                setter.addStatement("$T.set($T.WHOLE_MEMORY, address + offset + $L.$L, value, $L)", MEMORY_ACCESS_CLASS, WORLD_CLASS, componentReference, offsetName, size);
            } else {
                setter.addStatement("$T.set($T.WHOLE_MEMORY, address + offset + $L.$L, value)", MEMORY_ACCESS_CLASS, WORLD_CLASS, componentReference, offsetName);
            }
            setter.addStatement("return this");
            methods.add(setter.build());
        }

        return methods;
    }

    private TypeName getElementType(VariableElement field) {
        TypeMirror typeMirror = field.asType();
        if (typeMirror instanceof ArrayType arrayType) {
            return TypeName.get(arrayType.getComponentType());
        }
        return TypeName.get(typeMirror);
    }
}