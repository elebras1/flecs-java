package com.github.elebras1.flecs.processor;

import com.palantir.javapoet.*;

import javax.lang.model.element.*;
import java.lang.foreign.MemorySegment;
import java.util.List;

import static com.github.elebras1.flecs.processor.ComponentGenerator.LAYOUT_FIELD_CLASS;

public class ComponentViewGenerator extends AbstractGenerator {
    private static final String COMPONENT_VIEW_INTERFACE = "com.github.elebras1.flecs.ComponentView";

    public JavaFile generate(TypeElement recordElement, List<VariableElement> fields)  {
        String packageName = this.getPackageName(recordElement);
        String recordName = recordElement.getSimpleName().toString();
        String componentViewClassName = recordName + "ComponentView";

        String componentReference = packageName + "." + recordName + "Component";

        TypeSpec componentClass = TypeSpec.classBuilder(componentViewClassName)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addSuperinterface(ClassName.bestGuess(COMPONENT_VIEW_INTERFACE))
                .addField(this.createField())
                .addMethod(this.createSetterMethod())
                .addMethods(this.createMethods(fields, componentReference))
                .build();

        return JavaFile.builder(packageName, componentClass).addFileComment("Generated by ComponentViewGenerator").indent("    ").build();
    }

    private FieldSpec createField() {
        return FieldSpec.builder(MemorySegment.class, "memorySegment", Modifier.PRIVATE).build();
    }

    private MethodSpec createSetterMethod() {
        return MethodSpec.methodBuilder("setMemorySegment")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(MemorySegment.class, "memorySegment")
                .addJavadoc("Internal API - Do not use.\n")
                .addStatement("this.memorySegment = memorySegment")
                .build();
    }

    private Iterable<MethodSpec> createMethods(List<VariableElement> fields, String componentReference) {
        return fields.stream().map(field -> this.createMethod(field, componentReference)).toList();
    }

    private MethodSpec createMethod(VariableElement field, String componentReference) {
        MethodSpec.Builder method = MethodSpec.methodBuilder(field.getSimpleName().toString()).addModifiers(Modifier.PUBLIC).returns(TypeName.get(field.asType()));

        String fieldName = field.getSimpleName().toString();
        String offsetName = "OFFSET_" + fieldName.toUpperCase();
        String typeName = field.asType().toString();
        String getterMethod = this.getGetterMethod(typeName);
        if ("java.lang.String".equals(typeName)) {
            int size = this.getStringSize(field);
            method.addStatement("$T $L = $L.$L(memorySegment, $L.$L, $L)", String.class, fieldName, LAYOUT_FIELD_CLASS, getterMethod, componentReference, offsetName, size);
        } else if (typeName.endsWith("[]")) {
            int length = this.getArrayLength(field);
            method.addStatement("$L $L = $L.$L(memorySegment, $L.$L, $L)", typeName, fieldName, LAYOUT_FIELD_CLASS, getterMethod, componentReference, offsetName, length);
        } else {
            method.addStatement("$L $L = $L.$L(memorySegment, $L.$L)", typeName, fieldName, LAYOUT_FIELD_CLASS, getterMethod, componentReference, offsetName);
        }

        method.addStatement("return $L", fieldName);

        return method.build();
    }
}
